{
  "submissions_dump": [
    {
      "id": 1851865001,
      "question_id": 1343,
      "lang": "java",
      "lang_name": "Java",
      "time": "2minutes",
      "timestamp": 1765358042,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "20 ms",
      "url": "/submissions/detail/1851865001/",
      "is_pending": "Not Pending",
      "title": "Dice Roll Simulation",
      "memory": "48.1 MB",
      "code": "class Solution {\n    private static final int MOD = 1000000007;\n    \n    public int dieSimulator(int n, int[] rollMax) {\n        // dp[roll][face][cnt] : sequences of length roll ending with 'face' appearing 'cnt' times consecutively\n        int maxCnt = 15; // per constraints\n        int[][][] dp = new int[n + 1][6][maxCnt + 1];\n\n        // base: first roll\n        for (int face = 0; face < 6; face++) {\n            dp[1][face][1] = 1;\n        }\n\n        for (int len = 1; len < n; len++) {\n            for (int face = 0; face < 6; face++) {\n                for (int cnt = 1; cnt <= rollMax[face]; cnt++) {\n                    int cur = dp[len][face][cnt];\n                    if (cur == 0) continue;\n\n                    // continue same face if allowed\n                    if (cnt + 1 <= rollMax[face]) {\n                        dp[len + 1][face][cnt + 1] = (dp[len + 1][face][cnt + 1] + cur) % MOD;\n                    }\n\n                    // switch to a different face\n                    for (int next = 0; next < 6; next++) {\n                        if (next == face) continue;\n                        dp[len + 1][next][1] = (dp[len + 1][next][1] + cur) % MOD;\n                    }\n                }\n            }\n        }\n\n        int ans = 0;\n        for (int face = 0; face < 6; face++) {\n            for (int cnt = 1; cnt <= rollMax[face]; cnt++) {\n                ans = (ans + dp[n][face][cnt]) % MOD;\n            }\n        }\n\n        return ans;\n    }\n}\n    ",
      "compare_result": "11111111111111111111111111111111",
      "title_slug": "dice-roll-simulation",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 909,
      "statusCode": 10,
      "totalTestcases": 32,
      "question": {
        "title": "Dice Roll Simulation",
        "titleSlug": "dice-roll-simulation",
        "questionId": "1343"
      },
      "status_code": 10,
      "passedTestCaseCnt": 32,
      "totalTestCaseCnt": 32
    },
    {
      "id": 1851861594,
      "question_id": 54,
      "lang": "java",
      "lang_name": "Java",
      "time": "7minutes",
      "timestamp": 1765357772,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "0 ms",
      "url": "/submissions/detail/1851861594/",
      "is_pending": "Not Pending",
      "title": "Spiral Matrix",
      "memory": "43 MB",
      "code": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List<Integer> result = new ArrayList<>();\n        if (matrix == null || matrix.length == 0) {\n            return result;\n        }\n        \n        int top = 0, bottom = matrix.length - 1;\n        int left = 0, right = matrix[0].length - 1;\n        \n        while (top <= bottom && left <= right) {\n            // left to right\n            for (int col = left; col <= right; col++) {\n                result.add(matrix[top][col]);\n            }\n            top++;\n            \n            // top to bottom\n            for (int row = top; row <= bottom; row++) {\n                result.add(matrix[row][right]);\n            }\n            right--;\n            \n            if (top <= bottom) {\n                // right to left\n                for (int col = right; col >= left; col--) {\n                    result.add(matrix[bottom][col]);\n                }\n                bottom--;\n            }\n            \n            if (left <= right) {\n                // bottom to top\n                for (int row = bottom; row >= top; row--) {\n                    result.add(matrix[row][left]);\n                }\n                left++;\n            }\n        }\n        \n        return result;\n    }\n}\n    ",
      "compare_result": "11111111111111111111111111",
      "title_slug": "spiral-matrix",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 908,
      "statusCode": 10,
      "totalTestcases": 26,
      "question": {
        "title": "Spiral Matrix",
        "titleSlug": "spiral-matrix",
        "questionId": "54"
      },
      "status_code": 10,
      "passedTestCaseCnt": 26,
      "totalTestCaseCnt": 26
    },
    {
      "id": 1851857067,
      "question_id": 78,
      "lang": "java",
      "lang_name": "Java",
      "time": "13minutes",
      "timestamp": 1765357408,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "1 ms",
      "url": "/submissions/detail/1851857067/",
      "is_pending": "Not Pending",
      "title": "Subsets",
      "memory": "44.3 MB",
      "code": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        backtrack(nums, 0, new ArrayList<>(), result);\n        return result;\n    }\n\n    private void backtrack(int[] nums, int index, List<Integer> current, List<List<Integer>> result) {\n        if (index == nums.length) {\n            result.add(new ArrayList<>(current));\n            return;\n        }\n\n        // Exclude current number\n        backtrack(nums, index + 1, current, result);\n\n        // Include current number\n        current.add(nums[index]);\n        backtrack(nums, index + 1, current, result);\n        current.remove(current.size() - 1);\n    }\n}\n    ",
      "compare_result": "1111111111",
      "title_slug": "subsets",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 907,
      "statusCode": 10,
      "totalTestcases": 10,
      "question": {
        "title": "Subsets",
        "titleSlug": "subsets",
        "questionId": "78"
      },
      "status_code": 10,
      "passedTestCaseCnt": 10,
      "totalTestCaseCnt": 10
    },
    {
      "id": 1851854641,
      "question_id": 17,
      "lang": "java",
      "lang_name": "Java",
      "time": "16minutes",
      "timestamp": 1765357204,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "0 ms",
      "url": "/submissions/detail/1851854641/",
      "is_pending": "Not Pending",
      "title": "Letter Combinations of a Phone Number",
      "memory": "43.2 MB",
      "code": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<String> letterCombinations(String digits) {\n        List<String> result = new ArrayList<>();\n        if (digits == null || digits.length() == 0) {\n            return result;\n        }\n        \n        String[] mapping = new String[] {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n        backtrack(digits, 0, new StringBuilder(), result, mapping);\n        return result;\n    }\n\n    private void backtrack(String digits, int index, StringBuilder current, List<String> result, String[] mapping) {\n        if (index == digits.length()) {\n            result.add(current.toString());\n            return;\n        }\n\n        String letters = mapping[digits.charAt(index) - '0'];\n        for (char c : letters.toCharArray()) {\n            current.append(c);\n            backtrack(digits, index + 1, current, result, mapping);\n            current.deleteCharAt(current.length() - 1);\n        }\n    }\n}\n    ",
      "compare_result": "111111111111111111111111",
      "title_slug": "letter-combinations-of-a-phone-number",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 906,
      "statusCode": 10,
      "totalTestcases": 24,
      "question": {
        "title": "Letter Combinations of a Phone Number",
        "titleSlug": "letter-combinations-of-a-phone-number",
        "questionId": "17"
      },
      "status_code": 10,
      "passedTestCaseCnt": 24,
      "totalTestCaseCnt": 24
    },
    {
      "id": 1851851219,
      "question_id": 146,
      "lang": "java",
      "lang_name": "Java",
      "time": "21minutes",
      "timestamp": 1765356933,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "44 ms",
      "url": "/submissions/detail/1851851219/",
      "is_pending": "Not Pending",
      "title": "LRU Cache",
      "memory": "130.5 MB",
      "code": "import java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n/**\n * LRU cache using LinkedHashMap with access order for O(1) get/put and eviction.\n */\nclass LRUCache {\n    private final int capacity;\n    private final LinkedHashMap<Integer, Integer> cache;\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        this.cache = new LinkedHashMap<>(capacity, 0.75f, true);\n    }\n    \n    public int get(int key) {\n        return cache.getOrDefault(key, -1);\n    }\n    \n    public void put(int key, int value) {\n        cache.put(key, value);\n        if (cache.size() > capacity) {\n            Iterator<Map.Entry<Integer, Integer>> it = cache.entrySet().iterator();\n            it.next(); // least recently used\n            it.remove();\n        }\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n    ",
      "compare_result": "111111111111111111111111",
      "title_slug": "lru-cache",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 905,
      "statusCode": 10,
      "totalTestcases": 24,
      "question": {
        "title": "LRU Cache",
        "titleSlug": "lru-cache",
        "questionId": "146"
      },
      "status_code": 10,
      "passedTestCaseCnt": 24,
      "totalTestCaseCnt": 24
    },
    {
      "id": 1851848007,
      "question_id": 133,
      "lang": "java",
      "lang_name": "Java",
      "time": "25minutes",
      "timestamp": 1765356660,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "26 ms",
      "url": "/submissions/detail/1851848007/",
      "is_pending": "Not Pending",
      "title": "Clone Graph",
      "memory": "44.3 MB",
      "code": "import java.util.*;\n\nclass Solution {\n    public Node cloneGraph(Node node) {\n        if (node == null) {\n            return null;\n        }\n\n        Map<Node, Node> visited = new HashMap<>();\n        return cloneNode(node, visited);\n    }\n    \n    private Node cloneNode(Node node, Map<Node, Node> visited) {\n        if (visited.containsKey(node)) {\n            return visited.get(node);\n        }\n\n        Node copy = new Node(node.val);\n        visited.put(node, copy);\n\n        for (Node neighbor : node.neighbors) {\n            copy.neighbors.add(cloneNode(neighbor, visited));\n        }\n\n        return copy;\n    }\n}",
      "compare_result": "1111111111111111111111",
      "title_slug": "clone-graph",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 904,
      "statusCode": 10,
      "totalTestcases": 22,
      "question": {
        "title": "Clone Graph",
        "titleSlug": "clone-graph",
        "questionId": "133"
      },
      "status_code": 10,
      "passedTestCaseCnt": 22,
      "totalTestCaseCnt": 22
    },
    {
      "id": 1851763519,
      "question_id": 200,
      "lang": "java",
      "lang_name": "Java",
      "time": "2hours, 27minutes",
      "timestamp": 1765349361,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "3 ms",
      "url": "/submissions/detail/1851763519/",
      "is_pending": "Not Pending",
      "title": "Number of Islands",
      "memory": "52.3 MB",
      "code": "class Solution {\n    public int numIslands(char[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int islands = 0;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == '1') {\n                    islands++;\n                    dfs(grid, i, j);\n                }\n            }\n        }\n        return islands;\n    }\n\n    private void dfs(char[][] grid, int i, int j) {\n        int m = grid.length;\n        int n = grid[0].length;\n\n        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] != '1') {\n            return;\n        }\n\n        grid[i][j] = '0'; // mark visited\n\n        dfs(grid, i + 1, j);\n        dfs(grid, i - 1, j);\n        dfs(grid, i, j + 1);\n        dfs(grid, i, j - 1);\n    }\n}\n            ",
      "compare_result": "1111111111111111111111111111111111111111111111111",
      "title_slug": "number-of-islands",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 903,
      "statusCode": 10,
      "totalTestcases": 49,
      "question": {
        "title": "Number of Islands",
        "titleSlug": "number-of-islands",
        "questionId": "200"
      },
      "status_code": 10,
      "passedTestCaseCnt": 49,
      "totalTestCaseCnt": 49
    },
    {
      "id": 1851752615,
      "question_id": 33,
      "lang": "java",
      "lang_name": "Java",
      "time": "2hours, 40minutes",
      "timestamp": 1765348588,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "0 ms",
      "url": "/submissions/detail/1851752615/",
      "is_pending": "Not Pending",
      "title": "Search in Rotated Sorted Array",
      "memory": "43.9 MB",
      "code": "class Solution {\n    public int search(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n\n            if (nums[mid] == target) {\n                return mid;\n            }\n\n            // Determine which half is sorted and discard the other half.\n            if (nums[left] <= nums[mid]) { // left half is sorted\n                if (nums[left] <= target && target < nums[mid]) {\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            } else { // right half is sorted\n                if (nums[mid] < target && target <= nums[right]) {\n                    left = mid + 1;\n                } else {\n                    right = mid - 1;\n                }\n            }\n        }\n        return -1;\n    }\n}",
      "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "search-in-rotated-sorted-array",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 902,
      "statusCode": 10,
      "totalTestcases": 196,
      "question": {
        "title": "Search in Rotated Sorted Array",
        "titleSlug": "search-in-rotated-sorted-array",
        "questionId": "33"
      },
      "status_code": 10,
      "passedTestCaseCnt": 196,
      "totalTestCaseCnt": 196
    }
  ]
}