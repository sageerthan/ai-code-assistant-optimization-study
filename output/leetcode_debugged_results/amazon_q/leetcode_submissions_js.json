{
  "submissions_dump": [
    {
      "id": 1850425929,
      "question_id": 1343,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "0minutes",
      "timestamp": 1765217777,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "77 ms",
      "url": "/submissions/detail/1850425929/",
      "is_pending": "Not Pending",
      "title": "Dice Roll Simulation",
      "memory": "67.6 MB",
      "code": "\n/**\n * @param {number} n\n * @param {number[]} rollMax\n * @return {number}\n */\nvar dieSimulator = function(n, rollMax) {\n    const MOD = 1e9 + 7;\n    const dp = Array.from({ length: n + 1 }, () => Array(6).fill(0).map(() => Array(16).fill(0)));\n    \n    for (let j = 0; j < 6; j++) {\n        dp[1][j][1] = 1;\n    }\n    \n    for (let i = 2; i <= n; i++) {\n        for (let j = 0; j < 6; j++) {\n            for (let p = 0; p < 6; p++) {\n                if (p !== j) {\n                    for (let k = 1; k <= rollMax[p]; k++) {\n                        dp[i][j][1] = (dp[i][j][1] + dp[i - 1][p][k]) % MOD;\n                    }\n                } else {\n                    for (let k = 1; k < rollMax[j]; k++) {\n                        dp[i][j][k + 1] = (dp[i][j][k + 1] + dp[i - 1][j][k]) % MOD;\n                    }\n                }\n            }\n        }\n    }\n    \n    let result = 0;\n    for (let j = 0; j < 6; j++) {\n        for (let k = 1; k <= rollMax[j]; k++) {\n            result = (result + dp[n][j][k]) % MOD;\n        }\n    }\n    \n    return result;\n};\n    ",
      "compare_result": "11111111111111111111111111111111",
      "title_slug": "dice-roll-simulation",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 850,
      "statusCode": 10,
      "totalTestcases": 32,
      "question": {
        "title": "Dice Roll Simulation",
        "titleSlug": "dice-roll-simulation",
        "questionId": "1343"
      },
      "status_code": 10,
      "passedTestCaseCnt": 32,
      "totalTestCaseCnt": 32
    },
    {
      "id": 1850409765,
      "question_id": 1740,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "18minutes",
      "timestamp": 1765216716,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "586 ms",
      "url": "/submissions/detail/1850409765/",
      "is_pending": "Not Pending",
      "title": "Count Subtrees With Max Distance Between Cities",
      "memory": "66.1 MB",
      "code": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {number[]}\n */\nvar countSubgraphsForEachDiameter = function(n, edges) {\n    const adj = Array(n).fill().map(() => []);\n    for (const [u, v] of edges) {\n        adj[u - 1].push(v - 1);\n        adj[v - 1].push(u - 1);\n    }\n    \n    const res = Array(n - 1).fill(0);\n    \n    for (let mask = 1; mask < (1 << n); mask++) {\n        if (__builtin_popcount(mask) < 2) continue;\n        \n        const cities = [];\n        for (let i = 0; i < n; i++) {\n            if (mask & (1 << i)) cities.push(i);\n        }\n        \n        if (!isConnected(cities, adj, mask)) continue;\n        \n        const maxDist = getMaxDistance(cities, adj);\n        if (maxDist > 0) res[maxDist - 1]++;\n    }\n    \n    return res;\n};\n\nfunction __builtin_popcount(x) {\n    return x.toString(2).split('1').length - 1;\n}\n\nfunction isConnected(cities, adj, mask) {\n    const visited = new Set();\n    const dfs = (node) => {\n        visited.add(node);\n        for (const neighbor of adj[node]) {\n            if ((mask & (1 << neighbor)) && !visited.has(neighbor)) {\n                dfs(neighbor);\n            }\n        }\n    };\n    \n    dfs(cities[0]);\n    return visited.size === cities.length;\n}\n\nfunction getMaxDistance(cities, adj) {\n    let maxDist = 0;\n    \n    for (let i = 0; i < cities.length; i++) {\n        for (let j = i + 1; j < cities.length; j++) {\n            const dist = bfs(cities[i], cities[j], adj, cities);\n            maxDist = Math.max(maxDist, dist);\n        }\n    }\n    \n    return maxDist;\n}\n\nfunction bfs(start, end, adj, cities) {\n    if (start === end) return 0;\n    \n    const citySet = new Set(cities);\n    const visited = new Set([start]);\n    const queue = [start];\n    let dist = 0;\n    \n    while (queue.length > 0) {\n        const size = queue.length;\n        dist++;\n        \n        for (let i = 0; i < size; i++) {\n            const curr = queue.shift();\n            \n            for (const neighbor of adj[curr]) {\n                if (neighbor === end) return dist;\n                if (citySet.has(neighbor) && !visited.has(neighbor)) {\n                    visited.add(neighbor);\n                    queue.push(neighbor);\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n    ",
      "compare_result": "1111111111111111111111111111111",
      "title_slug": "count-subtrees-with-max-distance-between-cities",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 849,
      "statusCode": 10,
      "totalTestcases": 31,
      "question": {
        "title": "Count Subtrees With Max Distance Between Cities",
        "titleSlug": "count-subtrees-with-max-distance-between-cities",
        "questionId": "1740"
      },
      "status_code": 10,
      "passedTestCaseCnt": 31,
      "totalTestCaseCnt": 31
    },
    {
      "id": 1850404030,
      "question_id": 438,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "24minutes",
      "timestamp": 1765216347,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "42 ms",
      "url": "/submissions/detail/1850404030/",
      "is_pending": "Not Pending",
      "title": "Find All Anagrams in a String",
      "memory": "64 MB",
      "code": "/**\n * @param {string} s\n * @param {string} p\n * @return {number[]}\n */\nvar findAnagrams = function(s, p) {\n    const result = [];\n    const pMap = new Map();\n    const sMap = new Map();\n\n    // Initialize the frequency map for string p\n    for (const char of p) {\n        pMap.set(char, (pMap.get(char) || 0) + 1);\n    }\n\n    let left = 0;\n    let right = 0;\n\n    while (right < s.length) {\n        // Expand the window to the right\n        sMap.set(s[right], (sMap.get(s[right]) || 0) + 1);\n\n        // Shrink the window from the left if the window size exceeds p.length\n        if (right - left + 1 > p.length) {\n            sMap.set(s[left], sMap.get(s[left]) - 1);\n            if (sMap.get(s[left]) === 0) {\n                sMap.delete(s[left]);\n            }\n            left++;\n        }\n\n        // Check if the current window is an anagram of p\n        if (right - left + 1 === p.length && compareMaps(sMap, pMap)) {\n            result.push(left);\n        }\n\n        right++;\n    }\n\n    return result;\n};\n\nfunction compareMaps(map1, map2) {\n    if (map1.size !== map2.size) return false;\n    for (let [key, value] of map1) {\n        if (map2.get(key) !== value) return false;\n    }\n    return true;\n}\n    ",
      "compare_result": "11111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "find-all-anagrams-in-a-string",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 848,
      "statusCode": 10,
      "totalTestcases": 65,
      "question": {
        "title": "Find All Anagrams in a String",
        "titleSlug": "find-all-anagrams-in-a-string",
        "questionId": "438"
      },
      "status_code": 10,
      "passedTestCaseCnt": 65,
      "totalTestCaseCnt": 65
    },
    {
      "id": 1850400082,
      "question_id": 200,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "28minutes",
      "timestamp": 1765216092,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "63 ms",
      "url": "/submissions/detail/1850400082/",
      "is_pending": "Not Pending",
      "title": "Number of Islands",
      "memory": "56.8 MB",
      "code": "\n/**\n * @param {character[][]} grid\n * @return {number}\n */\nvar numIslands = function(grid) {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === '1') {\n                count++;\n                dfs(grid, i, j);\n            }\n        }\n    }\n    return count;\n};\n\nfunction dfs(grid, i, j) {\n    if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === '0') return;\n    grid[i][j] = '0';\n    dfs(grid, i + 1, j);\n    dfs(grid, i - 1, j);\n    dfs(grid, i, j + 1);\n    dfs(grid, i, j - 1);\n}\n    ",
      "compare_result": "1111111111111111111111111111111111111111111111111",
      "title_slug": "number-of-islands",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 847,
      "statusCode": 10,
      "totalTestcases": 49,
      "question": {
        "title": "Number of Islands",
        "titleSlug": "number-of-islands",
        "questionId": "200"
      },
      "status_code": 10,
      "passedTestCaseCnt": 49,
      "totalTestCaseCnt": 49
    }
  ]
}