{
  "submissions_dump": [
    {
      "id": 1850467884,
      "question_id": 1343,
      "lang": "python",
      "lang_name": "Python",
      "time": "0minutes",
      "timestamp": 1765221185,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "947 ms",
      "url": "/submissions/detail/1850467884/",
      "is_pending": "Not Pending",
      "title": "Dice Roll Simulation",
      "memory": "27.3 MB",
      "code": "class Solution(object):\n    def dieSimulator(self, n, rollMax):\n        \"\"\"\n        :type n: int\n        :type rollMax: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 1000000007\n        dp = [[[0 for _ in range(16)] for _ in range(6)] for _ in range(n + 1)]\n        \n        for j in range(6):\n            dp[1][j][1] = 1\n        \n        for i in range(2, n + 1):\n            for j in range(6):\n                for p in range(6):\n                    if p != j:\n                        for k in range(1, rollMax[p] + 1):\n                            dp[i][j][1] = (dp[i][j][1] + dp[i - 1][p][k]) % MOD\n                    else:\n                        for k in range(1, rollMax[j]):\n                            dp[i][j][k + 1] = (dp[i][j][k + 1] + dp[i - 1][j][k]) % MOD\n        \n        result = 0\n        for j in range(6):\n            for k in range(1, rollMax[j] + 1):\n                result = (result + dp[n][j][k]) % MOD\n        \n        return result                                                          \n    ",
      "compare_result": "11111111111111111111111111111111",
      "title_slug": "dice-roll-simulation",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 858,
      "statusCode": 10,
      "totalTestcases": 32,
      "question": {
        "title": "Dice Roll Simulation",
        "titleSlug": "dice-roll-simulation",
        "questionId": "1343"
      },
      "status_code": 10,
      "passedTestCaseCnt": 32,
      "totalTestCaseCnt": 32
    },
    {
      "id": 1850465409,
      "question_id": 1740,
      "lang": "python",
      "lang_name": "Python",
      "time": "4minutes",
      "timestamp": 1765220950,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "2151 ms",
      "url": "/submissions/detail/1850465409/",
      "is_pending": "Not Pending",
      "title": "Count Subtrees With Max Distance Between Cities",
      "memory": "13.7 MB",
      "code": "from collections import defaultdict, deque\n\nclass Solution(object):\n    def countSubgraphsForEachDiameter(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u-1].append(v-1)\n            graph[v-1].append(u-1)\n        \n        result = [0] * (n - 1)\n        \n        for mask in range(1, 1 << n):\n            if bin(mask).count('1') < 2:\n                continue\n            \n            cities = [i for i in range(n) if mask & (1 << i)]\n            \n            if not self.isConnected(cities, graph, mask):\n                continue\n            \n            max_dist = self.getMaxDistance(cities, graph)\n            if max_dist > 0:\n                result[max_dist - 1] += 1\n        \n        return result\n    \n    def isConnected(self, cities, graph, mask):\n        if not cities:\n            return False\n        \n        visited = set()\n        queue = deque([cities[0]])\n        visited.add(cities[0])\n        \n        while queue:\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if (mask & (1 << neighbor)) and neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n        \n        return len(visited) == len(cities)\n    \n    def getMaxDistance(self, cities, graph):\n        max_dist = 0\n        \n        for i in range(len(cities)):\n            for j in range(i + 1, len(cities)):\n                dist = self.bfs(cities[i], cities[j], graph, set(cities))\n                max_dist = max(max_dist, dist)\n        \n        return max_dist\n    \n    def bfs(self, start, end, graph, city_set):\n        if start == end:\n            return 0\n        \n        visited = set([start])\n        queue = deque([start])\n        dist = 0\n        \n        while queue:\n            size = len(queue)\n            dist += 1\n            \n            for _ in range(size):\n                curr = queue.popleft()\n                \n                for neighbor in graph[curr]:\n                    if neighbor == end:\n                        return dist\n                    if neighbor in city_set and neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append(neighbor)\n        \n        return -1                                                      \n    ",
      "compare_result": "1111111111111111111111111111111",
      "title_slug": "count-subtrees-with-max-distance-between-cities",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 857,
      "statusCode": 10,
      "totalTestcases": 31,
      "question": {
        "title": "Count Subtrees With Max Distance Between Cities",
        "titleSlug": "count-subtrees-with-max-distance-between-cities",
        "questionId": "1740"
      },
      "status_code": 10,
      "passedTestCaseCnt": 31,
      "totalTestCaseCnt": 31
    },
    {
      "id": 1850461985,
      "question_id": 23,
      "lang": "python",
      "lang_name": "Python",
      "time": "9minutes",
      "timestamp": 1765220628,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "28 ms",
      "url": "/submissions/detail/1850461985/",
      "is_pending": "Not Pending",
      "title": "Merge k Sorted Lists",
      "memory": "18.3 MB",
      "code": "class Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[Optional[ListNode]]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        if not lists or len(lists) == 0:\n            return None\n\n        while len(lists) > 1:\n            mergedLists = []\n            for i in range(0, len(lists), 2):\n                l1 = lists[i]\n                l2 = lists[i + 1] if (i + 1) < len(lists) else None\n                mergedLists.append(self.mergeList(l1, l2))\n            lists = mergedLists\n        return lists[0]\n    \n    def mergeList(self, l1, l2):\n        dummy = ListNode()\n        tail = dummy\n        \n        while l1 and l2:\n            if l1.val < l2.val:\n                tail.next = l1\n                l1 = l1.next\n            else:\n                tail.next = l2\n                l2 = l2.next\n            tail = tail.next\n        \n        if l1:\n            tail.next = l1\n        if l2:\n            tail.next = l2\n            \n        return dummy.next                           \n    ",
      "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "merge-k-sorted-lists",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 856,
      "statusCode": 10,
      "totalTestcases": 134,
      "question": {
        "title": "Merge k Sorted Lists",
        "titleSlug": "merge-k-sorted-lists",
        "questionId": "23"
      },
      "status_code": 10,
      "passedTestCaseCnt": 134,
      "totalTestCaseCnt": 134
    },
    {
      "id": 1850459570,
      "question_id": 78,
      "lang": "python",
      "lang_name": "Python",
      "time": "13minutes",
      "timestamp": 1765220402,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "0 ms",
      "url": "/submissions/detail/1850459570/",
      "is_pending": "Not Pending",
      "title": "Subsets",
      "memory": "12.6 MB",
      "code": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        subset = []\n\n        def dfs(i):\n            if i >= len(nums):\n                res.append(subset[:])\n                return\n            subset.append(nums[i])\n            dfs(i + 1)\n            subset.pop()\n            dfs(i + 1)\n\n        dfs(0)\n        return res\n           \n    ",
      "compare_result": "1111111111",
      "title_slug": "subsets",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 855,
      "statusCode": 10,
      "totalTestcases": 10,
      "question": {
        "title": "Subsets",
        "titleSlug": "subsets",
        "questionId": "78"
      },
      "status_code": 10,
      "passedTestCaseCnt": 10,
      "totalTestCaseCnt": 10
    }
  ]
}