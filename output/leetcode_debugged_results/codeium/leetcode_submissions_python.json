{
  "submissions_dump": [
    {
      "id": 1851717160,
      "question_id": 460,
      "lang": "python",
      "lang_name": "Python",
      "time": "9minutes",
      "timestamp": 1765346087,
      "status": 15,
      "status_display": "Runtime Error",
      "runtime": "N/A",
      "url": "/submissions/detail/1851717160/",
      "is_pending": "Not Pending",
      "title": "LFU Cache",
      "memory": "N/A",
      "code": "class LFUCache:\n    class Node:\n        def __init__(self, key, value, count):\n            self.key = key\n            self.value = value\n            self.count = count\n            self.prev = None\n            self.next = None\n\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.key_node = {}\n        self.count_node = {}\n        self.min_count = 0\n\n    # Rest of your code...\n\n    def put(self, key, value):\n        if not self.capacity:\n            return\n        if key in self.key_node:\n            node = self.key_node[key]\n            del self.key_node[key]\n            self.count_node[node.count].remove(key)\n\n            if not self.count_node[node.count]:\n                del self.count_node[node.count]\n        else:\n            if len(self.key_node) == self.capacity:\n                k, n = self.count_node[self.min_count].popitem(last=False)\n                del self.key_node[k]\n            self.min_count = 1\n        self.key_node[key] = self.Node(key, value, self.min_count)\n        self.count_node.setdefault(self.min_count, set()).add(key)",
      "compare_result": "0000000000000000000000000",
      "title_slug": "lfu-cache",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 901,
      "statusCode": 15,
      "totalTestcases": 25,
      "question": {
        "title": "LFU Cache",
        "titleSlug": "lfu-cache",
        "questionId": "460"
      },
      "status_code": 15,
      "passedTestCaseCnt": 0,
      "totalTestCaseCnt": 25
    },
    {
      "id": 1851713359,
      "question_id": 312,
      "lang": "python",
      "lang_name": "Python",
      "time": "14minutes",
      "timestamp": 1765345795,
      "status": 15,
      "status_display": "Runtime Error",
      "runtime": "N/A",
      "url": "/submissions/detail/1851713359/",
      "is_pending": "Not Pending",
      "title": "Burst Balloons",
      "memory": "N/A",
      "code": "def shortestPath(self, grid, k):\n    \"\"\"\n    :type grid: List[List[int]]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[[float('inf')] * (k + 1) for _ in range(n)] for _ in range(m)]\n    dp[0][0][0] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(m):\n        for j in range(n):\n            for r in range(min(k + 1, i + j + 1)):\n                for dx, dy in directions:\n                    nx, ny = i + dx, j + dy\n                    if 0 <= nx < m and 0 <= ny < n:\n                        if grid[nx][ny] == 1:\n                            dp[nx][ny][r + 1] = min(dp[nx][ny][r + 1], dp[i][j][r] + 1)\n                        else:\n                            dp[nx][ny][r] = min(dp[nx][ny][r], dp[i][j][r] + 1)\n    return dp[m - 1][n - 1][k] if dp[m - 1][n - 1][k] != float('inf') else -1",
      "compare_result": "0000000000000000000000000000000000000000000000000000000000000000000000000",
      "title_slug": "burst-balloons",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 899,
      "statusCode": 15,
      "totalTestcases": 73,
      "question": {
        "title": "Burst Balloons",
        "titleSlug": "burst-balloons",
        "questionId": "312"
      },
      "status_code": 15,
      "passedTestCaseCnt": 0,
      "totalTestCaseCnt": 73
    },
    {
      "id": 1851708632,
      "question_id": 1414,
      "lang": "python",
      "lang_name": "Python",
      "time": "20minutes",
      "timestamp": 1765345444,
      "status": 15,
      "status_display": "Runtime Error",
      "runtime": "N/A",
      "url": "/submissions/detail/1851708632/",
      "is_pending": "Not Pending",
      "title": "Shortest Path in a Grid with Obstacles Elimination",
      "memory": "N/A",
      "code": "def shortestPath(self, grid, k):\n    \"\"\"\n    :type grid: List[List[int]]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    m, n = len(grid), len(grid[0])\n    dp = [[[float('inf')] * (k + 1) for _ in range(n)] for _ in range(m)]\n    dp[0][0][0] = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    for i in range(m):\n        for j in range(n):\n            for r in range(min(k + 1, i + j + 1)):\n                for dx, dy in directions:\n                    nx, ny = i + dx, j + dy\n                    if 0 <= nx < m and 0 <= ny < n:\n                        if grid[nx][ny] == 1:\n                            dp[nx][ny][r + 1] = min(dp[nx][ny][r + 1], dp[i][j][r] + 1)\n                        else:\n                            dp[nx][ny][r] = min(dp[nx][ny][r], dp[i][j][r] + 1)\n                    else:\n                        break\n    return dp[m - 1][n - 1][0] if dp[m - 1][n - 1][0] != float('inf') else -1",
      "compare_result": "0000000000000000000000000000000000000000000000000000000",
      "title_slug": "shortest-path-in-a-grid-with-obstacles-elimination",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 897,
      "statusCode": 15,
      "totalTestcases": 55,
      "question": {
        "title": "Shortest Path in a Grid with Obstacles Elimination",
        "titleSlug": "shortest-path-in-a-grid-with-obstacles-elimination",
        "questionId": "1414"
      },
      "status_code": 15,
      "passedTestCaseCnt": 0,
      "totalTestCaseCnt": 55
    },
    {
      "id": 1851706463,
      "question_id": 1343,
      "lang": "python",
      "lang_name": "Python",
      "time": "23minutes",
      "timestamp": 1765345279,
      "status": 11,
      "status_display": "Wrong Answer",
      "runtime": "N/A",
      "url": "/submissions/detail/1851706463/",
      "is_pending": "Not Pending",
      "title": "Dice Roll Simulation",
      "memory": "N/A",
      "code": "class Solution(object):\n    def dieSimulator(self, n, rollMax):\n        MOD = 10**9 + 7\n        dp = [[0]*7 for _ in range(n+1)]\n        dp[0] = [1]*7\n        for i in range(1, n+1):\n            for j in range(6, 0, -1):\n                if i <= rollMax[j-1]:\n                    dp[i][j] = (dp[i-1][0] + dp[i-1][j]) % MOD\n                else:\n                    dp[i][j] = (dp[i-1][0] + dp[i-1][j] - dp[i-rollMax[j-1]-1][j]) % MOD\n                    if dp[i][j] < 0:\n                        dp[i][j] += MOD\n        return sum(dp[n]) % MOD",
      "compare_result": "00000000000000000000000000000000",
      "title_slug": "dice-roll-simulation",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 896,
      "statusCode": 11,
      "totalTestcases": 32,
      "question": {
        "title": "Dice Roll Simulation",
        "titleSlug": "dice-roll-simulation",
        "questionId": "1343"
      },
      "status_code": 11,
      "passedTestCaseCnt": 0,
      "totalTestCaseCnt": 32
    },
    {
      "id": 1851703502,
      "question_id": 1740,
      "lang": "python",
      "lang_name": "Python",
      "time": "27minutes",
      "timestamp": 1765345050,
      "status": 11,
      "status_display": "Wrong Answer",
      "runtime": "N/A",
      "url": "/submissions/detail/1851703502/",
      "is_pending": "Not Pending",
      "title": "Count Subtrees With Max Distance Between Cities",
      "memory": "N/A",
      "code": "class Solution(object):\n    def countSubgraphsForEachDiameter(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        graph = [[] for _ in range(n+1)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        res = [0] * (n-1)\n        for i in range(1, n+1):\n            depths = [0] * (n+1)\n            self.dfs(i, graph, depths)\n            for d in range(1, n):\n                res[d-1] += depths[d] == d\n        return res\n\n    def dfs(self, node, graph, depths):\n        for i in graph[node]:\n            if depths[i] == 0:\n                depths[i] = depths[node] + 1\n                self.dfs(i, graph, depths)",
      "compare_result": "0100000000000000000000000000000",
      "title_slug": "count-subtrees-with-max-distance-between-cities",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 895,
      "statusCode": 11,
      "totalTestcases": 31,
      "question": {
        "title": "Count Subtrees With Max Distance Between Cities",
        "titleSlug": "count-subtrees-with-max-distance-between-cities",
        "questionId": "1740"
      },
      "status_code": 11,
      "passedTestCaseCnt": 1,
      "totalTestCaseCnt": 31
    },
    {
      "id": 1851688931,
      "question_id": 4,
      "lang": "python",
      "lang_name": "Python",
      "time": "46minutes",
      "timestamp": 1765343909,
      "status": 11,
      "status_display": "Wrong Answer",
      "runtime": "N/A",
      "url": "/submissions/detail/1851688931/",
      "is_pending": "Not Pending",
      "title": "Median of Two Sorted Arrays",
      "memory": "N/A",
      "code": "class Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        m, n = len(nums1), len(nums2)\n        if (m + n) % 2 == 1:\n            return self.getKth(nums1, 0, nums2, 0, (m + n) // 2 + 1) / 1.0\n        else:\n            return (self.getKth(nums1, 0, nums2, 0, (m + n) // 2) + self.getKth(nums1, 0, nums2, 0, (m + n) // 2 + 1)) / 2.0\n\n    def getKth(self, nums1, p, nums2, q, k):\n        if p > q:\n            return self.getKth(nums2, q, nums1, p, k)\n        if q - p == 0:\n            return nums1[p]\n        if k == 1:\n            return min(nums1[p], nums2[q])\n\n        pa = min(p + (k // 2) - 1, p + (k // 2) + (q - p) - 1)\n        pb = min(q + (k // 2) - 1, p + (k // 2) + (q - p) - 1)\n\n        if nums1[pa] > nums2[pb]:\n            return self.getKth(nums1, p, nums2, pb - (pb - pa), k - (pb - pa))\n        else:\n            return self.getKth(nums1, pa + (pa - p), nums2, q, k - (pa - p))",
      "compare_result": "0010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
      "title_slug": "median-of-two-sorted-arrays",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 894,
      "statusCode": 11,
      "totalTestcases": 2098,
      "question": {
        "title": "Median of Two Sorted Arrays",
        "titleSlug": "median-of-two-sorted-arrays",
        "questionId": "4"
      },
      "status_code": 11,
      "passedTestCaseCnt": 1,
      "totalTestCaseCnt": 2098
    },
    {
      "id": 1851685148,
      "question_id": 101,
      "lang": "python",
      "lang_name": "Python",
      "time": "51minutes",
      "timestamp": 1765343606,
      "status": 15,
      "status_display": "Runtime Error",
      "runtime": "N/A",
      "url": "/submissions/detail/1851685148/",
      "is_pending": "Not Pending",
      "title": "Symmetric Tree",
      "memory": "N/A",
      "code": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\n        if not root:\n            return True\n        \n        def is_mirror(node1, node2):\n            if not node1 and not node2:\n                return True\n            \n            if not node1 or not node2:\n                return False\n            \n            if node1.val != node2.val:\n                return False\n            \n            return is_mirror(node1.left, node2.right) and is_mirror(node1.right, node2.left)\n        \n        return is_mirror(root.left, root.right)",
      "compare_result": "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
      "title_slug": "symmetric-tree",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 893,
      "statusCode": 15,
      "totalTestcases": 200,
      "question": {
        "title": "Symmetric Tree",
        "titleSlug": "symmetric-tree",
        "questionId": "101"
      },
      "status_code": 15,
      "passedTestCaseCnt": 0,
      "totalTestCaseCnt": 200
    }
  ]
}