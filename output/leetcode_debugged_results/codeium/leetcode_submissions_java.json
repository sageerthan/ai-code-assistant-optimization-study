{
  "submissions_dump": [
    {
      "id": 1851050815,
      "question_id": 1414,
      "lang": "java",
      "lang_name": "Java",
      "time": "4minutes",
      "timestamp": 1765281642,
      "status": 20,
      "status_display": "Compile Error",
      "runtime": "N/A",
      "url": "/submissions/detail/1851050815/",
      "is_pending": "Not Pending",
      "title": "Shortest Path in a Grid with Obstacles Elimination",
      "memory": "N/A",
      "code": "class Solution {\n    int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    \n    public int removeObstacles(int[][] grid, int k) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n        int count = 0;\n        \n        // Step 1: Count the number of islands before removing obstacles\n        boolean[][] visited = new boolean[rows][cols];\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j] == 1 && !visited[i][j]) {\n                    count++;\n                    dfs(grid, visited, i, j);\n                }\n            }\n        }\n        \n        // Step 2: Remove the obstacles and count the number of islands again\n        int remaining = count;\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j] == 1) {\n                    grid[i][j] = 0;\n                    if (--k == 0) {\n                        // Create a new visited array for the second DFS\n                        boolean[][] visited2 = new boolean[rows][cols];\n                        if (dfs(grid, visited2, i, j)) {\n                            remaining--;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return remaining;\n    }\n    \n    private void dfs(int[][] grid, boolean[][] visited, int i, int j) {\n        rows = grid.length;\n        cols = grid[0].length;\n        visited[i][j] = true;\n        \n        for (int[] direction : directions) {\n            int x = i + direction[0];\n            int y = j + direction[1];\n            if (x >= 0 && x < rows && y >= 0 && y < cols && !visited[x][y] && grid[x][y] == 1) {\n                dfs(grid, visited, x, y);\n            }\n        }\n    }\n    \n    private boolean dfs(int[][] grid, boolean[][] visited, int i, int j) {\n        rows = grid.length;\n        cols = grid[0].length;\n        visited[i][j] = true;\n        \n        for (int[] direction : directions) {\n            int x = i + direction[0];\n            int y = j + direction[1];\n            if (x >= 0 && x < rows && y >= 0 && y < cols && !visited[x][y] && grid[x][y] == 1) {\n                dfs(grid, visited, x, y);\n            }\n        }\n        \n        return !visited[0][0] || !visited[rows-1][cols-1];\n    }\n}",
      "compare_result": null,
      "title_slug": "shortest-path-in-a-grid-with-obstacles-elimination",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 867,
      "statusCode": 20,
      "totalTestcases": 0,
      "question": {
        "title": "Shortest Path in a Grid with Obstacles Elimination",
        "titleSlug": "shortest-path-in-a-grid-with-obstacles-elimination",
        "questionId": "1414"
      },
      "status_code": 20,
      "passedTestCaseCnt": 0,
      "totalTestCaseCnt": 0
    },
    {
      "id": 1851034564,
      "question_id": 1343,
      "lang": "java",
      "lang_name": "Java",
      "time": "30minutes",
      "timestamp": 1765280070,
      "status": 11,
      "status_display": "Wrong Answer",
      "runtime": "N/A",
      "url": "/submissions/detail/1851034564/",
      "is_pending": "Not Pending",
      "title": "Dice Roll Simulation",
      "memory": "N/A",
      "code": "class Solution {\n    public int dieSimulator(int n, int[] rollMax) {\n        final int MOD = 1000000007;\n        int[] dp = new int[n+1];\n        dp[0] = 1;\n        int[] count = new int[7]; // count[i] represents the number of rolls that have been used for number i\n        Arrays.fill(count, 1);\n        for (int i = 1; i <= n; i++) {\n            int prevCount = dp[i-1];\n            dp[i] = 0;\n            for (int j = 1; j <= 6; j++) {\n                if (count[j] < rollMax[j-1]) {\n                    dp[i] = (dp[i] + prevCount) % MOD;\n                }\n                count[j]++;\n            }\n        }\n        return dp[n];\n    }\n}",
      "compare_result": "00000000000000000000000000000000",
      "title_slug": "dice-roll-simulation",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 866,
      "statusCode": 11,
      "totalTestcases": 32,
      "question": {
        "title": "Dice Roll Simulation",
        "titleSlug": "dice-roll-simulation",
        "questionId": "1343"
      },
      "status_code": 11,
      "passedTestCaseCnt": 0,
      "totalTestCaseCnt": 32
    },
    {
      "id": 1851031969,
      "question_id": 1740,
      "lang": "java",
      "lang_name": "Java",
      "time": "34minutes",
      "timestamp": 1765279817,
      "status": 20,
      "status_display": "Compile Error",
      "runtime": "N/A",
      "url": "/submissions/detail/1851031969/",
      "is_pending": "Not Pending",
      "title": "Count Subtrees With Max Distance Between Cities",
      "memory": "N/A",
      "code": "import java.util.*;\n\nclass Solution {\n    public int[] findEquationValue(int n, int[][] edges, int[] node) {\n        Map<Integer, List<Integer>> graph = new HashMap<>();\n        for (int[] edge : edges) {\n            int u = edge[0], v = edge[1];\n            graph.putIfAbsent(u, new ArrayList<>());\n            graph.get(u).add(v);\n            graph.putIfAbsent(v, new ArrayList<>());\n            graph.get(v).add(u);\n        }\n        int[] result = new int[n];\n        Arrays.fill(result, -1);\n        for (int i = 0; i < n; i++) {\n            if (result[i] != -1) {\n                continue;\n            }\n            Queue<Integer> queue = new LinkedList<>();\n            queue.offer(i);\n            result[i] = node[i];\n            while (!queue.isEmpty()) {\n                int nodeIndex = queue.poll();\n                for (int neighbor : graph.get(nodeIndex)) {\n                    if (result[neighbor] == -1) {\n                        result[neighbor] = result[nodeIndex];\n                        queue.offer(neighbor);\n                    } else if (result[neighbor] != result[nodeIndex]) {\n                        if (result[neighbor] != node[neighbor]) {\n                            return new int[]{-1};\n                        }\n                        result[nodeIndex] = result[neighbor];\n                        queue.offer(nodeIndex);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}",
      "compare_result": null,
      "title_slug": "count-subtrees-with-max-distance-between-cities",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 865,
      "statusCode": 20,
      "totalTestcases": 0,
      "question": {
        "title": "Count Subtrees With Max Distance Between Cities",
        "titleSlug": "count-subtrees-with-max-distance-between-cities",
        "questionId": "1740"
      },
      "status_code": 20,
      "passedTestCaseCnt": 0,
      "totalTestCaseCnt": 0
    },
    {
      "id": 1851028836,
      "question_id": 10,
      "lang": "java",
      "lang_name": "Java",
      "time": "39minutes",
      "timestamp": 1765279512,
      "status": 15,
      "status_display": "Runtime Error",
      "runtime": "N/A",
      "url": "/submissions/detail/1851028836/",
      "is_pending": "Not Pending",
      "title": "Regular Expression Matching",
      "memory": "N/A",
      "code": "class Solution {\n    public boolean isMatch(String s, String p) {\n        int sIndex = 0, pIndex = 0, match = 0, starIndex = -1;\n        char[] sc = s.toCharArray(), pc = p.toCharArray();\n        while (sIndex < sc.length) {\n            if (pIndex < pc.length && (pc[pIndex] == sc[sIndex] || pc[pIndex] == '.')) {\n                sIndex++; pIndex++;\n            } else if (pc[pIndex] == '*') {\n                starIndex = pIndex;\n                match = sIndex;\n                pIndex++;\n            } else if (starIndex != -1) {\n                pIndex = starIndex + 1;\n                match++;\n                sIndex = match;\n            } else {\n                return false;\n            }\n        }\n        while (pIndex < pc.length && pc[pIndex] == '*') pIndex++;\n        return pIndex == pc.length;\n    }\n}",
      "compare_result": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
      "title_slug": "regular-expression-matching",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 864,
      "statusCode": 15,
      "totalTestcases": 354,
      "question": {
        "title": "Regular Expression Matching",
        "titleSlug": "regular-expression-matching",
        "questionId": "10"
      },
      "status_code": 15,
      "passedTestCaseCnt": 0,
      "totalTestCaseCnt": 354
    },
    {
      "id": 1851021355,
      "question_id": 23,
      "lang": "java",
      "lang_name": "Java",
      "time": "51minutes",
      "timestamp": 1765278807,
      "status": 11,
      "status_display": "Wrong Answer",
      "runtime": "N/A",
      "url": "/submissions/detail/1851021355/",
      "is_pending": "Not Pending",
      "title": "Merge k Sorted Lists",
      "memory": "N/A",
      "code": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if (lists == null || lists.length == 0) {\n            return null;\n        }\n\n        int length = lists.length;\n        while (length > 1) {\n            int nextLength = length / 2;\n            ListNode[] mergedLists = new ListNode[length];\n            for (int i = 0; i < length / 2; i++) {\n                mergedLists[i] = mergeTwoLists(lists[i * 2], lists[i * 2 + 1]);\n            }\n            for (int i = length / 2; i < length; i++) {\n                if (i * 2 + 1 < lists.length) {\n                    mergedLists[i] = lists[i * 2 + 1];\n                } else {\n                    mergedLists[i] = null;\n                }\n            }\n            lists = mergedLists;\n            length = nextLength;\n        }\n\n        return lists[0];\n    }\n\n    private ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        if (list1 == null) {\n            return list2;\n        }\n        if (list2 == null) {\n            return list1;\n        }\n\n        if (list1.val < list2.val) {\n            list1.next = mergeTwoLists(list1.next, list2);\n            return list1;\n        } else {\n            list2.next = mergeTwoLists(list1, list2.next);\n            return list2;\n        }\n    }\n}",
      "compare_result": "01111111111101000101111111111111111111110100110001000100101101000011001100101101010010101101011001000110100101001001101100001010010001",
      "title_slug": "merge-k-sorted-lists",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 863,
      "statusCode": 11,
      "totalTestcases": 134,
      "question": {
        "title": "Merge k Sorted Lists",
        "titleSlug": "merge-k-sorted-lists",
        "questionId": "23"
      },
      "status_code": 11,
      "passedTestCaseCnt": 74,
      "totalTestCaseCnt": 134
    },
    {
      "id": 1851020275,
      "question_id": 146,
      "lang": "java",
      "lang_name": "Java",
      "time": "53minutes",
      "timestamp": 1765278704,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "49 ms",
      "url": "/submissions/detail/1851020275/",
      "is_pending": "Not Pending",
      "title": "LRU Cache",
      "memory": "132.3 MB",
      "code": "import java.util.LinkedHashMap;\n\nclass LRUCache {\n    private int capacity;\n    private final LinkedHashMap<Integer, Integer> cache;\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        this.cache = new LinkedHashMap<Integer, Integer>();\n    }\n\n    public int get(int key) {\n        if (cache.containsKey(key)) {\n            int value = cache.get(key);\n            cache.remove(key);\n            cache.put(key, value);\n            return value;\n        }\n        return -1;\n    }\n\n    public void put(int key, int value) {\n        if (cache.containsKey(key)) {\n            cache.remove(key);\n        } else if (cache.size() == capacity) {\n            cache.remove(cache.keySet().iterator().next());\n        }\n        cache.put(key, value);\n    }\n}",
      "compare_result": "111111111111111111111111",
      "title_slug": "lru-cache",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 862,
      "statusCode": 10,
      "totalTestcases": 24,
      "question": {
        "title": "LRU Cache",
        "titleSlug": "lru-cache",
        "questionId": "146"
      },
      "status_code": 10,
      "passedTestCaseCnt": 24,
      "totalTestCaseCnt": 24
    }
  ]
}