{
  "submissions_dump": [
    {
      "id": 1850354469,
      "question_id": 460,
      "lang": "python",
      "lang_name": "Python",
      "time": "3minutes",
      "timestamp": 1765213230,
      "status": 11,
      "status_display": "Wrong Answer",
      "runtime": "N/A",
      "url": "/submissions/detail/1850354469/",
      "is_pending": "Not Pending",
      "title": "LFU Cache",
      "memory": "N/A",
      "code": "class LFUCache(object):\n\n    def __init__(self, capacity):\n        \"\"\"\n        :type capacity: int\n        \"\"\"\n        self.capacity = capacity\n        self.cache = {}           # key -> value\n        self.freq = {}            # key -> frequency\n        self.freq_to_keys = {}    # frequency -> OrderedDict of keys (for LRU)\n        self.min_freq = 0\n\n    def get(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: int\n        \"\"\"\n        if key not in self.cache:\n            return -1\n        \n        self._update_frequency(key)\n        return self.cache[key]\n\n    def put(self, key, value):\n        \"\"\"\n        :type key: int\n        :type value: int\n        :rtype: None\n        \"\"\"\n        if self.capacity <= 0:\n            return\n        \n        if key in self.cache:\n            # Update existing key\n            self.cache[key] = value\n            self._update_frequency(key)\n        else:\n            # Add new key\n            if len(self.cache) >= self.capacity:\n                # Evict LFU key (least recently used among those with min frequency)\n                self._evict()\n            \n            self.cache[key] = value\n            self.freq[key] = 1\n            if 1 not in self.freq_to_keys:\n                self.freq_to_keys[1] = {}\n            self.freq_to_keys[1][key] = True\n            self.min_freq = 1\n    \n    def _update_frequency(self, key):\n        \"\"\"Update frequency of a key and maintain LRU order\"\"\"\n        old_freq = self.freq[key]\n        new_freq = old_freq + 1\n        \n        # Remove from old frequency list\n        del self.freq_to_keys[old_freq][key]\n        \n        # If old frequency list is empty and it was min_freq, increment min_freq\n        if len(self.freq_to_keys[old_freq]) == 0:\n            del self.freq_to_keys[old_freq]\n            if old_freq == self.min_freq:\n                self.min_freq = new_freq\n        \n        # Add to new frequency list\n        if new_freq not in self.freq_to_keys:\n            self.freq_to_keys[new_freq] = {}\n        self.freq_to_keys[new_freq][key] = True\n        \n        # Update frequency\n        self.freq[key] = new_freq\n    \n    def _evict(self):\n        \"\"\"Evict the least frequently used and least recently used key\"\"\"\n        # Get the LRU key from min_freq bucket\n        lfu_key = next(iter(self.freq_to_keys[self.min_freq]))\n        \n        # Remove from cache\n        del self.cache[lfu_key]\n        del self.freq[lfu_key]\n        del self.freq_to_keys[self.min_freq][lfu_key]\n        \n        # Clean up empty frequency bucket\n        if len(self.freq_to_keys[self.min_freq]) == 0:\n            del self.freq_to_keys[self.min_freq]\n        \n# Your LFUCache object will be instantiated and called as such:\n# obj = LFUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)                                                                 \n    ",
      "compare_result": "1111111111111001000000011",
      "title_slug": "lfu-cache",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 844,
      "statusCode": 11,
      "totalTestcases": 25,
      "question": {
        "title": "LFU Cache",
        "titleSlug": "lfu-cache",
        "questionId": "460"
      },
      "status_code": 11,
      "passedTestCaseCnt": 16,
      "totalTestCaseCnt": 25
    },
    {
      "id": 1850347283,
      "question_id": 1343,
      "lang": "python",
      "lang_name": "Python",
      "time": "10minutes",
      "timestamp": 1765212795,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "914 ms",
      "url": "/submissions/detail/1850347283/",
      "is_pending": "Not Pending",
      "title": "Dice Roll Simulation",
      "memory": "27.2 MB",
      "code": "class Solution(object):\n    def dieSimulator(self, n, rollMax):\n        \"\"\"\n        :type n: int\n        :type rollMax: List[int]\n        :rtype: int\n        \"\"\" \n        MOD = 10**9 + 7\n        \n        # dp[i][j][k] = number of sequences of length i, ending with face j (0-5),\n        # with k consecutive j's (1..rollMax[j])\n        dp = [[[0] * 16 for _ in range(6)] for _ in range(n + 1)]\n        \n        # Base case: first roll\n        for j in range(6):\n            dp[1][j][1] = 1\n        \n        # Fill DP table\n        for i in range(2, n + 1):\n            for j in range(6):\n                # Case 1: previous roll is different -> consecutive count becomes 1\n                for prev_j in range(6):\n                    if prev_j != j:\n                        for k in range(1, rollMax[prev_j] + 1):\n                            dp[i][j][1] = (dp[i][j][1] + dp[i - 1][prev_j][k]) % MOD\n                \n                # Case 2: previous roll was same j -> increase consecutive count\n                for k in range(2, rollMax[j] + 1):\n                    dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j][k - 1]) % MOD\n        \n        # Sum all valid ending states\n        result = 0\n        for j in range(6):\n            for k in range(1, rollMax[j] + 1):\n                result = (result + dp[n][j][k]) % MOD\n        \n        return result                                                         \n    ",
      "compare_result": "11111111111111111111111111111111",
      "title_slug": "dice-roll-simulation",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 843,
      "statusCode": 10,
      "totalTestcases": 32,
      "question": {
        "title": "Dice Roll Simulation",
        "titleSlug": "dice-roll-simulation",
        "questionId": "1343"
      },
      "status_code": 10,
      "passedTestCaseCnt": 32,
      "totalTestCaseCnt": 32
    },
    {
      "id": 1850342147,
      "question_id": 1740,
      "lang": "python",
      "lang_name": "Python",
      "time": "15minutes",
      "timestamp": 1765212475,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "608 ms",
      "url": "/submissions/detail/1850342147/",
      "is_pending": "Not Pending",
      "title": "Count Subtrees With Max Distance Between Cities",
      "memory": "13.4 MB",
      "code": "class Solution(object):\n    def countSubgraphsForEachDiameter(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        from collections import defaultdict, deque\n        \n        # Build adjacency list\n        graph = defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def is_connected(mask):\n            \"\"\"Check if nodes in mask form a connected component\"\"\"\n            # Find first node in mask\n            first = -1\n            for i in range(n):\n                if mask & (1 << i):\n                    first = i + 1\n                    break\n            \n            if first == -1:\n                return False\n            \n            # BFS to check connectivity\n            visited = set([first])\n            queue = deque([first])\n            \n            while queue:\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if neighbor not in visited and (mask & (1 << (neighbor - 1))):\n                        visited.add(neighbor)\n                        queue.append(neighbor)\n            \n            # Count nodes in mask\n            count = bin(mask).count('1')\n            return len(visited) == count\n        \n        def get_diameter(mask):\n            \"\"\"Get diameter of tree formed by nodes in mask\"\"\"\n            # Find first node\n            first = -1\n            for i in range(n):\n                if mask & (1 << i):\n                    first = i + 1\n                    break\n            \n            def bfs_farthest(start):\n                \"\"\"BFS to find farthest node from start\"\"\"\n                visited = {start: 0}\n                queue = deque([start])\n                farthest = start\n                max_dist = 0\n                \n                while queue:\n                    node = queue.popleft()\n                    for neighbor in graph[node]:\n                        if neighbor not in visited and (mask & (1 << (neighbor - 1))):\n                            visited[neighbor] = visited[node] + 1\n                            queue.append(neighbor)\n                            if visited[neighbor] > max_dist:\n                                max_dist = visited[neighbor]\n                                farthest = neighbor\n                \n                return farthest, max_dist\n            \n            # Two BFS passes to find diameter\n            farthest1, _ = bfs_farthest(first)\n            farthest2, diameter = bfs_farthest(farthest1)\n            \n            return diameter\n        \n        result = [0] * (n - 1)\n        \n        # Enumerate all non-empty subsets with at least 2 nodes\n        for mask in range(1, 1 << n):\n            node_count = bin(mask).count('1')\n            \n            if node_count < 2:\n                continue\n            \n            # Check edge count: tree with k nodes has k-1 edges\n            edge_count = 0\n            for u, v in edges:\n                if (mask & (1 << (u - 1))) and (mask & (1 << (v - 1))):\n                    edge_count += 1\n            \n            if edge_count != node_count - 1:\n                continue\n            \n            # Check connectivity\n            if not is_connected(mask):\n                continue\n            \n            # Calculate diameter\n            diameter = get_diameter(mask)\n            \n            if 1 <= diameter <= n - 1:\n                result[diameter - 1] += 1\n        \n        return result                                                      \n    ",
      "compare_result": "1111111111111111111111111111111",
      "title_slug": "count-subtrees-with-max-distance-between-cities",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 842,
      "statusCode": 10,
      "totalTestcases": 31,
      "question": {
        "title": "Count Subtrees With Max Distance Between Cities",
        "titleSlug": "count-subtrees-with-max-distance-between-cities",
        "questionId": "1740"
      },
      "status_code": 10,
      "passedTestCaseCnt": 31,
      "totalTestCaseCnt": 31
    },
    {
      "id": 1850336698,
      "question_id": 4,
      "lang": "python",
      "lang_name": "Python",
      "time": "21minutes",
      "timestamp": 1765212133,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "3 ms",
      "url": "/submissions/detail/1850336698/",
      "is_pending": "Not Pending",
      "title": "Median of Two Sorted Arrays",
      "memory": "12.5 MB",
      "code": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\" \n        m, n = len(nums1), len(nums2)\n        if m > n:\n            nums1, nums2, m, n = nums2, nums1, n, m\n\n        low, high = 0, m\n        while low <= high:\n            partition1 = (low + high) // 2\n            partition2 = (m + n + 1) // 2 - partition1\n\n            maxLeft1 = nums1[partition1 - 1] if partition1 > 0 else float('-inf')\n            minRight1 = nums1[partition1] if partition1 < m else float('inf')\n\n            maxLeft2 = nums2[partition2 - 1] if partition2 > 0 else float('-inf')\n            minRight2 = nums2[partition2] if partition2 < n else float('inf')\n\n            if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:\n                # Found the correct partition\n                if (m + n) % 2 == 0:\n                    # Even total length: average of two middle elements\n                    return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2.0\n                else:\n                    # Odd total length: take from the side with more elements\n                    return float(max(maxLeft1, maxLeft2))\n            elif maxLeft1 > minRight2:\n                high = partition1 - 1\n            else:\n                low = partition1 + 1\n\n        raise ValueError(\"Input arrays are not sorted\")\n",
      "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "median-of-two-sorted-arrays",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 841,
      "statusCode": 10,
      "totalTestcases": 2098,
      "question": {
        "title": "Median of Two Sorted Arrays",
        "titleSlug": "median-of-two-sorted-arrays",
        "questionId": "4"
      },
      "status_code": 10,
      "passedTestCaseCnt": 2098,
      "totalTestCaseCnt": 2098
    },
    {
      "id": 1850325832,
      "question_id": 73,
      "lang": "python",
      "lang_name": "Python",
      "time": "32minutes",
      "timestamp": 1765211451,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "6 ms",
      "url": "/submissions/detail/1850325832/",
      "is_pending": "Not Pending",
      "title": "Set Matrix Zeroes",
      "memory": "13.2 MB",
      "code": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\" \n        rows, cols = len(matrix), len(matrix[0])\n        first_row_zero = False\n        first_col_zero = False\n        \n        # Check if first row and first column need to be zeroed\n        for j in range(cols):\n            if matrix[0][j] == 0:\n                first_row_zero = True\n                break\n        \n        for i in range(rows):\n            if matrix[i][0] == 0:\n                first_col_zero = True\n                break\n        \n        # Use first row and column as markers for the rest of the matrix\n        for i in range(1, rows):\n            for j in range(1, cols):\n                if matrix[i][j] == 0:\n                    matrix[i][0] = 0\n                    matrix[0][j] = 0\n        \n        # Set zeroes based on markers (skip first row and column)\n        for i in range(1, rows):\n            for j in range(1, cols):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n        \n        # Handle first row\n        if first_row_zero:\n            for j in range(cols):\n                matrix[0][j] = 0\n        \n        # Handle first column\n        if first_col_zero:\n            for i in range(rows):\n                matrix[i][0] = 0\n        \n        return matrix\n                                                                                 \n    ",
      "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "set-matrix-zeroes",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 840,
      "statusCode": 10,
      "totalTestcases": 202,
      "question": {
        "title": "Set Matrix Zeroes",
        "titleSlug": "set-matrix-zeroes",
        "questionId": "73"
      },
      "status_code": 10,
      "passedTestCaseCnt": 202,
      "totalTestCaseCnt": 202
    }
  ]
}