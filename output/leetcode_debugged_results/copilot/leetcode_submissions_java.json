{
  "submissions_dump": [
    {
      "id": 1849840936,
      "question_id": 460,
      "lang": "java",
      "lang_name": "Java",
      "time": "23minutes",
      "timestamp": 1765172290,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "67 ms",
      "url": "/submissions/detail/1849840936/",
      "is_pending": "Not Pending",
      "title": "LFU Cache",
      "memory": "138.6 MB",
      "code": "import java.util.HashMap;\nimport java.util.LinkedHashSet;\n\nclass Node {\n    int key;\n    int value;\n    int freq;\n    \n    Node(int key, int value) {\n        this.key = key;\n        this.value = value;\n        this.freq = 1;\n    }\n}\n\nclass LFUCache {\n    private int capacity;\n    private int minFreq;\n    private HashMap<Integer, Node> keyMap;\n    private HashMap<Integer, LinkedHashSet<Integer>> freqMap;\n\n    public LFUCache(int capacity) {\n        // Initialize the cache with the given capacity\n        // Use a HashMap to store key-value pairs and another HashMap to store frequency counts\n        // Use a priority queue or a linked list to maintain the order of least frequently used keys\n        // Implement methods for get and put operations\n        // Initialize data structures here\n        // Example:\n        this.capacity = capacity;\n        this.minFreq = 0;\n        this.keyMap = new HashMap<>();\n        this.freqMap = new HashMap<>();\n    }\n    \n    public int get(int key) {\n        if (!keyMap.containsKey(key)) {\n            return -1;\n        }\n        // Update the frequency of the key\n        int freq = keyMap.get(key).freq;\n        keyMap.get(key).freq++;\n        freqMap.get(freq).remove(key);\n        if (freqMap.get(freq).isEmpty()) {\n            freqMap.remove(freq);\n            if (minFreq == freq) {\n                minFreq++;\n            }\n        }\n        freqMap.putIfAbsent(freq + 1, new LinkedHashSet<>());\n        freqMap.get(freq + 1).add(key);\n        return keyMap.get(key).value;\n    }\n    \n    public void put(int key, int value) {\n        if (capacity == 0) return;\n\n        if (keyMap.containsKey(key)) {\n            // Update the value and frequency\n            keyMap.get(key).value = value;\n            get(key); // This will update the frequency\n        } else {\n            if (keyMap.size() >= capacity) {\n                // Evict the least frequently used key\n                evict();\n            }\n            // Insert the new key\n            keyMap.put(key, new Node(key, value));\n            freqMap.putIfAbsent(1, new LinkedHashSet<>());\n            freqMap.get(1).add(key);\n            minFreq = 1;\n        }\n    }\n\n    private void evict() {\n        // Find the least frequently used key\n        LinkedHashSet<Integer> minFreqKeys = freqMap.get(minFreq);\n        if (minFreqKeys != null && !minFreqKeys.isEmpty()) {\n            int lfuKey = minFreqKeys.iterator().next();\n            minFreqKeys.remove(lfuKey);\n            if (minFreqKeys.isEmpty()) {\n                freqMap.remove(minFreq);\n            }\n            keyMap.remove(lfuKey);\n        }\n    }\n}\n\n/**\n * Your LFUCache object will be instantiated and called as such:\n * LFUCache obj = new LFUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n    ",
      "compare_result": "1111111111111111111111111",
      "title_slug": "lfu-cache",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 827,
      "statusCode": 10,
      "totalTestcases": 25,
      "question": {
        "title": "LFU Cache",
        "titleSlug": "lfu-cache",
        "questionId": "460"
      },
      "status_code": 10,
      "passedTestCaseCnt": 25,
      "totalTestCaseCnt": 25
    },
    {
      "id": 1849837395,
      "question_id": 1343,
      "lang": "java",
      "lang_name": "Java",
      "time": "28minutes",
      "timestamp": 1765171981,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "29 ms",
      "url": "/submissions/detail/1849837395/",
      "is_pending": "Not Pending",
      "title": "Dice Roll Simulation",
      "memory": "51.4 MB",
      "code": "class Solution {\n    public int dieSimulator(int n, int[] rollMax) {\n        int MOD = 1000000007;\n        \n        // dp[i][j][k] = number of ways to roll i times, last roll is j, \n        // and we have k consecutive rolls of j\n        long[][][] dp = new long[n + 1][6][16];\n        \n        // Initialize the first roll - each die face can be rolled once\n        for (int j = 0; j < 6; j++) {\n            dp[1][j][1] = 1;\n        }\n        \n        // Fill the dp table\n        for (int i = 2; i <= n; i++) {\n            for (int j = 0; j < 6; j++) {\n                // Case 1: Roll a different number (reset consecutive count to 1)\n                for (int prevJ = 0; prevJ < 6; prevJ++) {\n                    if (prevJ != j) {\n                        for (int k = 1; k <= rollMax[prevJ]; k++) {\n                            dp[i][j][1] = (dp[i][j][1] + dp[i - 1][prevJ][k]) % MOD;\n                        }\n                    }\n                }\n                \n                // Case 2: Roll the same number (increment consecutive count)\n                for (int k = 1; k < rollMax[j]; k++) {\n                    dp[i][j][k + 1] = (dp[i][j][k + 1] + dp[i - 1][j][k]) % MOD;\n                }\n            }\n        }\n        \n        // Sum up all the ways to roll the die after n rolls\n        long result = 0;\n        for (int j = 0; j < 6; j++) {\n            for (int k = 1; k <= rollMax[j]; k++) {\n                result = (result + dp[n][j][k]) % MOD;\n            }\n        }\n        \n        return (int) result;\n    }\n}\n    ",
      "compare_result": "11111111111111111111111111111111",
      "title_slug": "dice-roll-simulation",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 826,
      "statusCode": 10,
      "totalTestcases": 32,
      "question": {
        "title": "Dice Roll Simulation",
        "titleSlug": "dice-roll-simulation",
        "questionId": "1343"
      },
      "status_code": 10,
      "passedTestCaseCnt": 32,
      "totalTestCaseCnt": 32
    },
    {
      "id": 1849828403,
      "question_id": 1740,
      "lang": "java",
      "lang_name": "Java",
      "time": "41minutes",
      "timestamp": 1765171223,
      "status": 20,
      "status_display": "Compile Error",
      "runtime": "N/A",
      "url": "/submissions/detail/1849828403/",
      "is_pending": "Not Pending",
      "title": "Count Subtrees With Max Distance Between Cities",
      "memory": "N/A",
      "code": "class Solution {\n    public int[] countSubgraphsForEachDiameter(int n, int[][] edges) {\n        int[] result = new int[n - 1];\n        int totalSubtrees = 1 << n; // Total possible subsets of nodes\n\n        for (int mask = 1; mask < totalSubtrees; mask++) {\n            int count = Integer.bitCount(mask); // Count of nodes in the subset\n            if (count < 2) continue; // Skip subsets with less than 2 nodes\n\n            // Check if the subset forms a valid tree\n            if (isValidTree(mask, edges, n)) {\n                int diameter = calculateDiameter(mask, edges, n);\n                if (diameter > 0 && diameter <= n - 1) {\n                    result[diameter - 1]++;\n                }\n            }\n        }\n        return result; \n    }\n    \n    private boolean isValidTree(int mask, int[][] edges, int n) {\n        // Check if the subset of nodes forms a connected tree\n        int[] adj = new int[n];\n        int count = 0;\n        \n        for (int[] edge : edges) {\n            int u = edge[0] - 1;\n            int v = edge[1] - 1;\n            if (((mask >> u) & 1) == 1 && ((mask >> v) & 1) == 1) {\n                adj[u]++;\n                adj[v]++;\n                count++;\n            }\n        }\n        \n        // A tree with k nodes has k-1 edges\n        int nodeCount = Integer.bitCount(mask);\n        if (count != nodeCount - 1) return false;\n        \n        // Check connectivity using DFS\n        boolean[] visited = new boolean[n];\n        int first = -1;\n        for (int i = 0; i < n; i++) {\n            if ((mask >> i) & 1) == 1) {\n                first = i;\n                break;\n            }\n        }\n        \n        dfs(first, mask, edges, visited);\n        \n        for (int i = 0; i < n; i++) {\n            if (((mask >> i) & 1) == 1 && !visited[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    private void dfs(int node, int mask, int[][] edges, boolean[] visited) {\n        visited[node] = true;\n        for (int[] edge : edges) {\n            int u = edge[0] - 1;\n            int v = edge[1] - 1;\n            \n            if (u == node && !visited[v] && ((mask >> v) & 1) == 1) {\n                dfs(v, mask, edges, visited);\n            } else if (v == node && !visited[u] && ((mask >> u) & 1) == 1) {\n                dfs(u, mask, edges, visited);\n            }\n        }\n    }\n    \n    private int calculateDiameter(int mask, int[][] edges, int n) {\n        // Find the diameter of the tree formed by the subset\n        int maxDiameter = 0;\n        \n        // For each node in the subset, find the farthest node\n        for (int i = 0; i < n; i++) {\n            if (((mask >> i) & 1) == 1) {\n                int[] dist = new int[n];\n                bfs(i, mask, edges, dist);\n                \n                for (int j = 0; j < n; j++) {\n                    if (((mask >> j) & 1) == 1) {\n                        maxDiameter = Math.max(maxDiameter, dist[j]);\n                    }\n                }\n            }\n        }\n        \n        return maxDiameter;\n    }\n    \n    private void bfs(int start, int mask, int[][] edges, int[] dist) {\n        java.util.Queue<Integer> queue = new java.util.LinkedList<>();\n        boolean[] visited = new boolean[dist.length];\n        \n        queue.offer(start);\n        visited[start] = true;\n        dist[start] = 0;\n        \n        while (!queue.isEmpty()) {\n            int node = queue.poll();\n            for (int[] edge : edges) {\n                int u = edge[0] - 1;\n                int v = edge[1] - 1;\n                \n                if (u == node && !visited[v] && ((mask >> v) & 1) == 1) {\n                    visited[v] = true;\n                    dist[v] = dist[node] + 1;\n                    queue.offer(v);\n                } else if (v == node && !visited[u] && ((mask >> u) & 1) == 1) {\n                    visited[u] = true;\n                    dist[u] = dist[node] + 1;\n                    queue.offer(u);\n                }\n            }\n        }\n    }\n}\n    ",
      "compare_result": null,
      "title_slug": "count-subtrees-with-max-distance-between-cities",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 824,
      "statusCode": 20,
      "totalTestcases": 0,
      "question": {
        "title": "Count Subtrees With Max Distance Between Cities",
        "titleSlug": "count-subtrees-with-max-distance-between-cities",
        "questionId": "1740"
      },
      "status_code": 20,
      "passedTestCaseCnt": 0,
      "totalTestCaseCnt": 0
    },
    {
      "id": 1849821723,
      "question_id": 146,
      "lang": "java",
      "lang_name": "Java",
      "time": "51minutes",
      "timestamp": 1765170631,
      "status": 15,
      "status_display": "Runtime Error",
      "runtime": "N/A",
      "url": "/submissions/detail/1849821723/",
      "is_pending": "Not Pending",
      "title": "LRU Cache",
      "memory": "N/A",
      "code": "import java.util.HashMap;\nimport java.util.LinkedList;\n\nclass LRUCache {\n    private int capacity;\n    private HashMap<Integer, Integer> cache;\n    private LinkedList<Integer> lruList;\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        this.cache = new HashMap<>();\n        this.lruList = new LinkedList<>();\n    }\n    \n    public int get(int key) {\n        if (cache.containsKey(key)) {\n            // Move the accessed key to the front of the LRU list\n            lruList.remove(key);\n            lruList.addFirst(key);\n            return cache.get(key);\n        }\n        return -1; // Key not found\n    }\n    \n    public void put(int key, int value) {\n        if (cache.containsKey(key)) {\n            // Update the value and move the key to the front of the LRU list\n            cache.put(key, value);\n            lruList.remove(key);\n            lruList.addFirst(key);\n        } else {\n            // Add a new key-value pair\n            if (cache.size() >= capacity) {\n                // Evict the least recently used key\n                int lruKey = lruList.removeLast();\n                cache.remove(lruKey);\n            }\n            cache.put(key, value);\n            lruList.addFirst(key);\n        }\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n    ",
      "compare_result": "000000000000000000000000",
      "title_slug": "lru-cache",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 823,
      "statusCode": 15,
      "totalTestcases": 24,
      "question": {
        "title": "LRU Cache",
        "titleSlug": "lru-cache",
        "questionId": "146"
      },
      "status_code": 15,
      "passedTestCaseCnt": 0,
      "totalTestCaseCnt": 24
    },
    {
      "id": 1849812602,
      "question_id": 101,
      "lang": "java",
      "lang_name": "Java",
      "time": "1hour, 4minutes",
      "timestamp": 1765169838,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "0 ms",
      "url": "/submissions/detail/1849812602/",
      "is_pending": "Not Pending",
      "title": "Symmetric Tree",
      "memory": "43.3 MB",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        if (root == null) {\n            return true; // An empty tree is symmetric\n        }\n        return isMirror(root.left, root.right); // Check if left and right subtrees are mirrors of each other\n    }\n    \n    private boolean isMirror(TreeNode left, TreeNode right) {\n        // Both nodes are null - they are mirrors\n        if (left == null && right == null) {\n            return true;\n        }\n        // One is null and the other is not - not mirrors\n        if (left == null || right == null) {\n            return false;\n        }\n        // Check if values are equal and subtrees are mirrors\n        return left.val == right.val && \n               isMirror(left.left, right.right) && \n               isMirror(left.right, right.left);\n    }\n}",
      "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "symmetric-tree",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 822,
      "statusCode": 10,
      "totalTestcases": 200,
      "question": {
        "title": "Symmetric Tree",
        "titleSlug": "symmetric-tree",
        "questionId": "101"
      },
      "status_code": 10,
      "passedTestCaseCnt": 200,
      "totalTestCaseCnt": 200
    }
  ]
}