{
  "submissions_dump": [
    {
      "id": 1850020246,
      "question_id": 460,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "1minute",
      "timestamp": 1765187082,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "605 ms",
      "url": "/submissions/detail/1850020246/",
      "is_pending": "Not Pending",
      "title": "LFU Cache",
      "memory": "116 MB",
      "code": "\n/**\n * @param {number} capacity\n */\nvar LFUCache = function(capacity) {\n    this.capacity = capacity;\n    this.size = 0;\n    this.keyToVal = new Map(); // key -> value\n    this.keyToFreq = new Map(); // key -> freq\n    this.freqToKeys = new Map(); // freq -> ordered Set of keys\n    this.minFreq = 0;\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLFUCache.prototype.get = function(key) {\n    if (!this.keyToVal.has(key)) return -1;\n    // update frequency\n    const freq = this.keyToFreq.get(key);\n    this.keyToFreq.set(key, freq + 1);\n    this.freqToKeys.get(freq).delete(key);\n    if (!this.freqToKeys.has(freq + 1)) this.freqToKeys.set(freq + 1, new Set());\n    this.freqToKeys.get(freq + 1).add(key);\n    if (this.freqToKeys.get(freq).size === 0) {\n        this.freqToKeys.delete(freq);\n        if (this.minFreq === freq) this.minFreq++;\n    }\n    return this.keyToVal.get(key);\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLFUCache.prototype.put = function(key, value) {\n    if (this.capacity === 0) return;\n    if (this.keyToVal.has(key)) {\n        this.keyToVal.set(key, value);\n        this.get(key); // update frequency\n        return;\n    }\n    if (this.size === this.capacity) {\n        // evict least frequently used and least recently used\n        const keys = this.freqToKeys.get(this.minFreq);\n        const lfuKey = keys.values().next().value;\n        keys.delete(lfuKey);\n        if (keys.size === 0) this.freqToKeys.delete(this.minFreq);\n        this.keyToVal.delete(lfuKey);\n        this.keyToFreq.delete(lfuKey);\n        this.size--;\n    }\n    this.keyToVal.set(key, value);\n    this.keyToFreq.set(key, 1);\n    if (!this.freqToKeys.has(1)) this.freqToKeys.set(1, new Set());\n    this.freqToKeys.get(1).add(key);\n    this.minFreq = 1;\n    this.size++;\n};\n\n/** \n * Your LFUCache object will be instantiated and called as such:\n * var obj = new LFUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n    ",
      "compare_result": "1111111111111111111111111",
      "title_slug": "lfu-cache",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 832,
      "statusCode": 10,
      "totalTestcases": 25,
      "question": {
        "title": "LFU Cache",
        "titleSlug": "lfu-cache",
        "questionId": "460"
      },
      "status_code": 10,
      "passedTestCaseCnt": 25,
      "totalTestCaseCnt": 25
    },
    {
      "id": 1850016081,
      "question_id": 1343,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "7minutes",
      "timestamp": 1765186743,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "60 ms",
      "url": "/submissions/detail/1850016081/",
      "is_pending": "Not Pending",
      "title": "Dice Roll Simulation",
      "memory": "67 MB",
      "code": "/**\n * @param {number} n\n * @param {number[]} rollMax\n * @return {number}\n */\nvar dieSimulator = function(n, rollMax) {\n    const MOD = 1000000007;\n    if (n === 0) return 0;\n    // dp[i][j][k]: number of sequences of length i, ending with face j (0-5),\n    // with k consecutive j's (1..rollMax[j])\n    const maxRoll = Math.max(...rollMax);\n    const dp = Array.from({ length: n + 1 }, () =>\n        Array.from({ length: 6 }, () => new Array(maxRoll + 1).fill(0))\n    );\n\n    // base case: first roll\n    for (let j = 0; j < 6; j++) dp[1][j][1] = 1;\n\n    for (let i = 2; i <= n; i++) {\n        for (let j = 0; j < 6; j++) {\n            // Case 1: previous roll is different -> consecutive count becomes 1\n            let sumPrevDifferent = 0;\n            for (let prev = 0; prev < 6; prev++) {\n                if (prev === j) continue;\n                const limit = rollMax[prev];\n                for (let k = 1; k <= limit; k++) {\n                    sumPrevDifferent = (sumPrevDifferent + dp[i - 1][prev][k]) % MOD;\n                }\n            }\n            dp[i][j][1] = (dp[i][j][1] + sumPrevDifferent) % MOD;\n\n            // Case 2: previous roll was same j -> increase consecutive count\n            const limitJ = rollMax[j];\n            for (let k = 2; k <= limitJ; k++) {\n                dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j][k - 1]) % MOD;\n            }\n        }\n    }\n\n    let res = 0;\n    for (let j = 0; j < 6; j++) {\n        for (let k = 1; k <= rollMax[j]; k++) {\n            res = (res + dp[n][j][k]) % MOD;\n        }\n    }\n    return res;\n};\n    ",
      "compare_result": "11111111111111111111111111111111",
      "title_slug": "dice-roll-simulation",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 831,
      "statusCode": 10,
      "totalTestcases": 32,
      "question": {
        "title": "Dice Roll Simulation",
        "titleSlug": "dice-roll-simulation",
        "questionId": "1343"
      },
      "status_code": 10,
      "passedTestCaseCnt": 32,
      "totalTestCaseCnt": 32
    },
    {
      "id": 1850003665,
      "question_id": 1740,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "24minutes",
      "timestamp": 1765185743,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "153 ms",
      "url": "/submissions/detail/1850003665/",
      "is_pending": "Not Pending",
      "title": "Count Subtrees With Max Distance Between Cities",
      "memory": "67.7 MB",
      "code": "\n/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {number[]}\n */\nvar countSubgraphsForEachDiameter = function(n, edges) {\n    const result = new Array(n - 1).fill(0);\n    const graph = Array.from({ length: n + 1 }, () => []);\n\n    for (const [u, v] of edges) {\n        graph[u].push(v);\n        graph[v].push(u);\n    }\n\n    const popcount = (x) => {\n        let c = 0;\n        while (x) {\n            c += x & 1;\n            x >>= 1;\n        }\n        return c;\n    };\n\n    const getFirstNode = (mask) => {\n        for (let i = 0; i < n; i++) if ((mask >> i) & 1) return i + 1;\n        return -1;\n    };\n\n    const isValidTree = (mask) => {\n        const nodeCount = popcount(mask);\n        if (nodeCount < 2) return false;\n        // count edges inside mask\n        let edgeCount = 0;\n        for (const [u, v] of edges) {\n            if (((mask >> (u - 1)) & 1) && ((mask >> (v - 1)) & 1)) edgeCount++;\n        }\n        if (edgeCount !== nodeCount - 1) return false;\n        // connectivity check via BFS\n        const start = getFirstNode(mask);\n        const visited = new Array(n + 1).fill(false);\n        const q = [start];\n        visited[start] = true;\n        let cnt = 1;\n        while (q.length) {\n            const cur = q.shift();\n            for (const nei of graph[cur]) {\n                if (!visited[nei] && ((mask >> (nei - 1)) & 1)) {\n                    visited[nei] = true;\n                    q.push(nei);\n                    cnt++;\n                }\n            }\n        }\n        return cnt === nodeCount;\n    };\n\n    const bfsFarthest = (start, mask) => {\n        const dist = new Array(n + 1).fill(-1);\n        const q = [start];\n        dist[start] = 0;\n        let farNode = start;\n        while (q.length) {\n            const cur = q.shift();\n            for (const nei of graph[cur]) {\n                if (dist[nei] === -1 && ((mask >> (nei - 1)) & 1)) {\n                    dist[nei] = dist[cur] + 1;\n                    q.push(nei);\n                    if (dist[nei] > dist[farNode]) farNode = nei;\n                }\n            }\n        }\n        return { farNode, dist };\n    };\n\n    const calculateDiameter = (mask) => {\n        const start = getFirstNode(mask);\n        const first = bfsFarthest(start, mask);\n        const second = bfsFarthest(first.farNode, mask);\n        // maximum distance between any two nodes in the subset\n        let maxd = 0;\n        for (let i = 1; i <= n; i++) {\n            if (((mask >> (i - 1)) & 1) && second.dist[i] > maxd) maxd = second.dist[i];\n        }\n        return maxd;\n    };\n\n    const totalMasks = 1 << n;\n    for (let mask = 1; mask < totalMasks; mask++) {\n        if (popcount(mask) < 2) continue;\n        if (!isValidTree(mask)) continue;\n        const d = calculateDiameter(mask);\n        if (d >= 1 && d <= n - 1) result[d - 1]++;\n    }\n\n    return result;\n};\n    ",
      "compare_result": "1111111111111111111111111111111",
      "title_slug": "count-subtrees-with-max-distance-between-cities",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 830,
      "statusCode": 10,
      "totalTestcases": 31,
      "question": {
        "title": "Count Subtrees With Max Distance Between Cities",
        "titleSlug": "count-subtrees-with-max-distance-between-cities",
        "questionId": "1740"
      },
      "status_code": 10,
      "passedTestCaseCnt": 31,
      "totalTestCaseCnt": 31
    },
    {
      "id": 1849992464,
      "question_id": 51,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "38minutes",
      "timestamp": 1765184855,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "10 ms",
      "url": "/submissions/detail/1849992464/",
      "is_pending": "Not Pending",
      "title": "N-Queens",
      "memory": "59.7 MB",
      "code": "\n/**\n * @param {number} n\n * @return {string[][]}\n */\nvar solveNQueens = function(n) {\n    const results = []; // Array to store the solutions\n    const board = Array.from({ length: n }, () => '.'.repeat(n)); // Initialize the board with empty strings\n\n    const isSafe = (row, col) => {\n        for (let i = 0; i < row; i++) {\n            if (board[i][col] === 'Q') return false; // Check column\n            if (col - (row - i) >= 0 && board[i][col - (row - i)] === 'Q') return false; // Check left diagonal\n            if (col + (row - i) < n && board[i][col + (row - i)] === 'Q') return false; // Check right diagonal\n        }\n        return true; // Safe to place a queen\n    };\n\n    const solve = (row) => {\n        if (row === n) {\n            results.push([...board]); // Add a valid solution to results\n            return;\n        }\n        for (let col = 0; col < n; col++) {\n            if (isSafe(row, col)) {\n                board[row] = board[row].substring(0, col) + 'Q' + board[row].substring(col + 1); // Place a queen\n                solve(row + 1); // Recur to place the next queen\n                board[row] = board[row].substring(0, col) + '.' + board[row].substring(col + 1); // Backtrack\n            }\n        }\n    };\n\n    solve(0); // Start solving from the first row\n    // Return solutions as arrays of strings (each row is a string)\n    return results;\n};\n    ",
      "compare_result": "111111111",
      "title_slug": "n-queens",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 829,
      "statusCode": 10,
      "totalTestcases": 9,
      "question": {
        "title": "N-Queens",
        "titleSlug": "n-queens",
        "questionId": "51"
      },
      "status_code": 10,
      "passedTestCaseCnt": 9,
      "totalTestCaseCnt": 9
    },
    {
      "id": 1849980956,
      "question_id": 215,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "54minutes",
      "timestamp": 1765183919,
      "status": 14,
      "status_display": "Time Limit Exceeded",
      "runtime": "N/A",
      "url": "/submissions/detail/1849980956/",
      "is_pending": "Not Pending",
      "title": "Kth Largest Element in an Array",
      "memory": "N/A",
      "code": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar findKthLargest = function(nums, k) {\n    // Quickselect approach: find the element with index nums.length - k\n    const target = nums.length - k;\n\n    function swap(i, j) {\n        const t = nums[i]; nums[i] = nums[j]; nums[j] = t;\n    }\n\n    function partition(left, right, pivotIndex) {\n        const pivot = nums[pivotIndex];\n        swap(pivotIndex, right);\n        let store = left;\n        for (let i = left; i < right; i++) {\n            if (nums[i] < pivot) {\n                swap(store, i);\n                store++;\n            }\n        }\n        swap(store, right);\n        return store;\n    }\n\n    function quickSelect(left, right) {\n        if (left === right) return nums[left];\n        const pivotIndex = left + Math.floor(Math.random() * (right - left + 1));\n        const pivotNewIndex = partition(left, right, pivotIndex);\n        if (pivotNewIndex === target) {\n            return nums[pivotNewIndex];\n        } else if (pivotNewIndex < target) {\n            return quickSelect(pivotNewIndex + 1, right);\n        } else {\n            return quickSelect(left, pivotNewIndex - 1);\n        }\n    }\n\n    return quickSelect(0, nums.length - 1);\n};\n    ",
      "compare_result": "111111111111111111111111111111111111111111110",
      "title_slug": "kth-largest-element-in-an-array",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 828,
      "statusCode": 14,
      "totalTestcases": 45,
      "question": {
        "title": "Kth Largest Element in an Array",
        "titleSlug": "kth-largest-element-in-an-array",
        "questionId": "215"
      },
      "status_code": 14,
      "passedTestCaseCnt": 44,
      "totalTestCaseCnt": 45
    }
  ]
}