{
  "submissions_dump": [
    {
      "id": 1850214151,
      "question_id": 460,
      "lang": "php",
      "lang_name": "PHP",
      "time": "1minute",
      "timestamp": 1765203711,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "3042 ms",
      "url": "/submissions/detail/1850214151/",
      "is_pending": "Not Pending",
      "title": "LFU Cache",
      "memory": "105.5 MB",
      "code": "class LFUCache {\n    private $capacity;\n    private $minFreq;\n    private $keyToVal;    // key => value\n    private $keyToFreq;   // key => freq\n    private $freqToKeys;  // freq => ordered list of keys (SplDoublyLinkedList for LRU order)\n\n    /**\n     * @param Integer $capacity\n     */\n    function __construct($capacity) {\n        $this->capacity = $capacity;\n        $this->minFreq = 0;\n        $this->keyToVal = [];\n        $this->keyToFreq = [];\n        $this->freqToKeys = [];\n    }\n\n    /**\n     * @param Integer $key\n     * @return Integer\n     */\n    function get($key) {\n        if (!isset($this->keyToVal[$key])) {\n            return -1;\n        }\n        $this->increaseFreq($key);\n        return $this->keyToVal[$key];\n    }\n\n    /**\n     * @param Integer $key\n     * @param Integer $value\n     * @return NULL\n     */\n    function put($key, $value) {\n        if ($this->capacity == 0) return;\n\n        if (isset($this->keyToVal[$key])) {\n            $this->keyToVal[$key] = $value;\n            $this->increaseFreq($key);\n            return;\n        }\n\n        if (count($this->keyToVal) >= $this->capacity) {\n            // Evict the least frequently used and least recently used key\n            $minFreqKeys = $this->freqToKeys[$this->minFreq];\n            $evictKey = array_shift($minFreqKeys);\n            unset($this->keyToVal[$evictKey]);\n            unset($this->keyToFreq[$evictKey]);\n            $this->freqToKeys[$this->minFreq] = $minFreqKeys;\n            if (empty($this->freqToKeys[$this->minFreq])) {\n                unset($this->freqToKeys[$this->minFreq]);\n            }\n        }\n\n        // Insert new key\n        $this->keyToVal[$key] = $value;\n        $this->keyToFreq[$key] = 1;\n        if (!isset($this->freqToKeys[1])) {\n            $this->freqToKeys[1] = [];\n        }\n        $this->freqToKeys[1][] = $key;\n        $this->minFreq = 1;\n    }\n\n    // Helper to increase frequency and maintain LRU order\n    private function increaseFreq($key) {\n        $freq = $this->keyToFreq[$key];\n        // Remove key from current freq list\n        $idx = array_search($key, $this->freqToKeys[$freq]);\n        array_splice($this->freqToKeys[$freq], $idx, 1);\n        if (empty($this->freqToKeys[$freq])) {\n            unset($this->freqToKeys[$freq]);\n            if ($this->minFreq == $freq) {\n                 $this->minFreq++;\n            }\n        }\n        // Add key to next freq list\n        $this->keyToFreq[$key] = $freq + 1;\n        if (!isset($this->freqToKeys[$freq + 1])) {\n            $this->freqToKeys[$freq + 1] = [];\n        }\n        $this->freqToKeys[$freq + 1][] = $key;\n    }\n}\n\n/**\n * Your LFUCache object will be instantiated and called as such:\n * $obj = LFUCache($capacity);\n * $ret_1 = $obj->get($key);\n * $obj->put($key, $value);\n */\n    \n    ",
      "compare_result": "1111111111111111111111111",
      "title_slug": "lfu-cache",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 839,
      "statusCode": 10,
      "totalTestcases": 25,
      "question": {
        "title": "LFU Cache",
        "titleSlug": "lfu-cache",
        "questionId": "460"
      },
      "status_code": 10,
      "passedTestCaseCnt": 25,
      "totalTestCaseCnt": 25
    },
    {
      "id": 1850207882,
      "question_id": 312,
      "lang": "php",
      "lang_name": "PHP",
      "time": "9minutes",
      "timestamp": 1765203256,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "2379 ms",
      "url": "/submissions/detail/1850207882/",
      "is_pending": "Not Pending",
      "title": "Burst Balloons",
      "memory": "23.8 MB",
      "code": "class Solution {\n\n    /**\n     * Calculate the maximum coins you can collect by bursting the balloons wisely.\n     * Uses dynamic programming with memoization.\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function maxCoins($nums) {\n        // Add 1 to both ends to handle boundaries\n        $n = count($nums);\n        $this->arr = array_merge([1], $nums, [1]);\n        $this->dp = [];\n        return $this->burst(0, $n + 1);\n    }\n\n    /**\n     * Helper function for DP using memoization to calculate max coins\n     * @param Integer $left\n     * @param Integer $right\n     * @return Integer\n     */\n    private function burst($left, $right) {\n        if ($left + 1 == $right) return 0;\n        if (isset($this->dp[$left][$right])) return $this->dp[$left][$right];\n        $maxCoins = 0;\n        for ($i = $left + 1; $i < $right; $i++) {\n            $coins = $this->arr[$left] * $this->arr[$i] * $this->arr[$right];\n            $coins += $this->burst($left, $i);\n            $coins += $this->burst($i, $right);\n            if ($coins > $maxCoins) $maxCoins = $coins;\n        }\n        $this->dp[$left][$right] = $maxCoins;\n        return $maxCoins;\n    }\n}",
      "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "burst-balloons",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 838,
      "statusCode": 10,
      "totalTestcases": 73,
      "question": {
        "title": "Burst Balloons",
        "titleSlug": "burst-balloons",
        "questionId": "312"
      },
      "status_code": 10,
      "passedTestCaseCnt": 73,
      "totalTestCaseCnt": 73
    },
    {
      "id": 1850196071,
      "question_id": 1414,
      "lang": "php",
      "lang_name": "PHP",
      "time": "23minutes",
      "timestamp": 1765202407,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "57 ms",
      "url": "/submissions/detail/1850196071/",
      "is_pending": "Not Pending",
      "title": "Shortest Path in a Grid with Obstacles Elimination",
      "memory": "20.8 MB",
      "code": "class Solution {\n\n    /**\n     * @param Integer[][] $grid\n     * @param Integer $k\n     * @return Integer\n     */\n    function shortestPath($grid, $k) {\n        $m = count($grid);\n        $n = count($grid[0]);\n        $directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n        $queue = new SplQueue();\n        $queue->enqueue([0, 0, 0, $k]); // x, y, steps, remaining_k\n        // visited[x][y] = max remaining obstacles when we visited (x, y)\n        $visited = [];\n        for ($i = 0; $i < $m; $i++) {\n            $visited[$i] = array_fill(0, $n, -1);\n        }\n        $visited[0][0] = $k;\n        \n        while (!$queue->isEmpty()) {\n            [$x, $y, $steps, $remaining_k] = $queue->dequeue();\n            if ($x === $m - 1 && $y === $n - 1) return $steps;\n            \n            foreach ($directions as [$dx, $dy]) {\n                $nx = $x + $dx;\n                $ny = $y + $dy;\n                if ($nx < 0 || $ny < 0 || $nx >= $m || $ny >= $n) continue;\n                \n                $new_remaining_k = $remaining_k;\n                if ($grid[$nx][$ny] === 1) {\n                    if ($remaining_k > 0) {\n                        $new_remaining_k--;\n                    } else {\n                        continue;\n                    }\n                }\n                \n                // Only visit if we haven't visited with more or equal remaining obstacles\n                if ($visited[$nx][$ny] < $new_remaining_k) {\n                    $visited[$nx][$ny] = $new_remaining_k;\n                    $queue->enqueue([$nx, $ny, $steps + 1, $new_remaining_k]);\n                }\n            }\n        }\n        return -1;\n    }\n}",
      "compare_result": "1111111111111111111111111111111111111111111111111111111",
      "title_slug": "shortest-path-in-a-grid-with-obstacles-elimination",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 837,
      "statusCode": 10,
      "totalTestcases": 55,
      "question": {
        "title": "Shortest Path in a Grid with Obstacles Elimination",
        "titleSlug": "shortest-path-in-a-grid-with-obstacles-elimination",
        "questionId": "1414"
      },
      "status_code": 10,
      "passedTestCaseCnt": 55,
      "totalTestCaseCnt": 55
    },
    {
      "id": 1850165262,
      "question_id": 1343,
      "lang": "php",
      "lang_name": "PHP",
      "time": "1hour, 1minute",
      "timestamp": 1765200123,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "620 ms",
      "url": "/submissions/detail/1850165262/",
      "is_pending": "Not Pending",
      "title": "Dice Roll Simulation",
      "memory": "34.5 MB",
      "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[] $rollMax\n     * @return Integer\n     */\n    function dieSimulator($n, $rollMax) {\n        $MOD = 1000000007;\n        $dp = [];\n        return $this->dfs(0, -1, 0, $n, $rollMax, $dp, $MOD);\n    }\n\n    /**\n     * Helper function for DP using memoization\n     * @param Integer $pos\n     * @param Integer $last\n     * @param Integer $cnt\n     * @param Integer $n\n     * @param Integer[] $rollMax\n     * @param Integer[][][] $dp\n     * @param Integer $MOD\n     * @return Integer\n     */\n    private function dfs($pos, $last, $cnt, $n, &$rollMax, &$dp, $MOD) {\n        if ($pos == $n) return 1;\n        if (isset($dp[$pos][$last][$cnt])) return $dp[$pos][$last][$cnt];\n        $res = 0;\n        for ($face = 0; $face < 6; $face++) {\n            if ($face == $last) {\n                if ($cnt + 1 <= $rollMax[$face]) {\n                    $res = ($res + $this->dfs($pos + 1, $face, $cnt + 1, $n, $rollMax, $dp, $MOD)) % $MOD;\n                }\n            } else {\n                $res = ($res + $this->dfs($pos + 1, $face, 1, $n, $rollMax, $dp, $MOD)) % $MOD;\n            }\n        }\n        return $dp[$pos][$last][$cnt] = $res;\n    }\n}\n    ",
      "compare_result": "11111111111111111111111111111111",
      "title_slug": "dice-roll-simulation",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 836,
      "statusCode": 10,
      "totalTestcases": 32,
      "question": {
        "title": "Dice Roll Simulation",
        "titleSlug": "dice-roll-simulation",
        "questionId": "1343"
      },
      "status_code": 10,
      "passedTestCaseCnt": 32,
      "totalTestCaseCnt": 32
    },
    {
      "id": 1850161894,
      "question_id": 51,
      "lang": "php",
      "lang_name": "PHP",
      "time": "1hour, 6minutes",
      "timestamp": 1765199858,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "5 ms",
      "url": "/submissions/detail/1850161894/",
      "is_pending": "Not Pending",
      "title": "N-Queens",
      "memory": "20.8 MB",
      "code": "class Solution {\n\n    /**\n     * Solves the n-queens puzzle and returns all distinct solutions.\n     * Uses backtracking to generate valid board configurations.\n     * @param Integer $n\n     * @return String[][]\n     */\n    function solveNQueens($n) {\n        $res = [];\n        $board = array_fill(0, $n, str_repeat('.', $n));\n        $cols = [];\n        $diag1 = [];\n        $diag2 = [];\n\n        $this->backtrack(0, $n, $board, $cols, $diag1, $diag2, $res);\n        return $res;\n    }\n\n    /**\n     * Helper function for backtracking to place queens\n     * @param Integer $row\n     * @param Integer $n\n     * @param String[] $board\n     * @param Boolean[] $cols\n     * @param Boolean[] $diag1\n     * @param Boolean[] $diag2\n     * @param String[][] $res\n     * @return void\n     */\n    private function backtrack($row, $n, &$board, &$cols, &$diag1, &$diag2, &$res) {\n        if ($row == $n) {\n            $res[] = array_values($board);\n            return;\n        }\n        for ($col = 0; $col < $n; $col++) {\n            if (!empty($cols[$col]) || !empty($diag1[$row - $col]) || !empty($diag2[$row + $col])) {\n                continue;\n            }\n            // Place queen\n            $board[$row] = substr_replace($board[$row], 'Q', $col, 1);\n            $cols[$col] = true;\n            $diag1[$row - $col] = true;\n            $diag2[$row + $col] = true;\n            $this->backtrack($row + 1, $n, $board, $cols, $diag1, $diag2, $res);\n            // Remove queen (backtrack)\n            $board[$row] = substr_replace($board[$row], '.', $col, 1);\n            unset($cols[$col]);\n            unset($diag1[$row - $col]);\n            unset($diag2[$row + $col]);\n        }\n    }\n}",
      "compare_result": "111111111",
      "title_slug": "n-queens",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 835,
      "statusCode": 10,
      "totalTestcases": 9,
      "question": {
        "title": "N-Queens",
        "titleSlug": "n-queens",
        "questionId": "51"
      },
      "status_code": 10,
      "passedTestCaseCnt": 9,
      "totalTestCaseCnt": 9
    },
    {
      "id": 1850158068,
      "question_id": 438,
      "lang": "php",
      "lang_name": "PHP",
      "time": "1hour, 11minutes",
      "timestamp": 1765199549,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "28 ms",
      "url": "/submissions/detail/1850158068/",
      "is_pending": "Not Pending",
      "title": "Find All Anagrams in a String",
      "memory": "21.6 MB",
      "code": "class Solution {\n\n    /**\n     * @param String $s\n     * @param String $p\n     * @return Integer[]\n     */\n    function findAnagrams($s, $p) {\n        $result = [];\n        $sLength = strlen($s);\n        $pLength = strlen($p);\n\n        if ($sLength < $pLength) {\n            return $result; // No anagrams possible\n        }\n\n        // Count frequency of characters in p\n        $pCount = array_fill(0, 26, 0);\n        for ($i = 0; $i < $pLength; $i++) {\n            $pCount[ord($p[$i]) - ord('a')]++;\n        }\n\n        // Sliding window to count frequency of characters in s\n        $sCount = array_fill(0, 26, 0);\n        for ($i = 0; $i < $pLength; $i++) {\n            $sCount[ord($s[$i]) - ord('a')]++;\n        }\n\n        // Check for anagram at the first window\n        if ($this->isAnagram($sCount, $pCount)) {\n            $result[] = 0;\n        }\n\n        // Slide the window across s\n        for ($i = $pLength; $i < $sLength; $i++) {\n            // Add new character to the window\n            $sCount[ord($s[$i]) - ord('a')]++;\n            // Remove the character that is no longer in the window\n            $sCount[ord($s[$i - $pLength]) - ord('a')]--;\n\n            // Check if current window is an anagram\n            if ($this->isAnagram($sCount, $pCount)) {\n                $result[] = $i - $pLength + 1;\n            }\n        }\n\n        return $result;\n        \n    }\n\n    /**\n     * Helper function to check if two character frequency arrays are equal\n     * @param Integer[] $sCount\n     * @param Integer[] $pCount\n     * @return Boolean\n     */\n    private function isAnagram($sCount, $pCount) {\n        for ($i = 0; $i < 26; $i++) {\n            if ($sCount[$i] !== $pCount[$i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n    ",
      "compare_result": "11111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "find-all-anagrams-in-a-string",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 834,
      "statusCode": 10,
      "totalTestcases": 65,
      "question": {
        "title": "Find All Anagrams in a String",
        "titleSlug": "find-all-anagrams-in-a-string",
        "questionId": "438"
      },
      "status_code": 10,
      "passedTestCaseCnt": 65,
      "totalTestCaseCnt": 65
    },
    {
      "id": 1850154574,
      "question_id": 101,
      "lang": "php",
      "lang_name": "PHP",
      "time": "1hour, 16minutes",
      "timestamp": 1765199257,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "0 ms",
      "url": "/submissions/detail/1850154574/",
      "is_pending": "Not Pending",
      "title": "Symmetric Tree",
      "memory": "20.7 MB",
      "code": "class Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Boolean\n     */\n    function isSymmetric($root) {\n        if ($root === null) {\n            return true; // An empty tree is symmetric\n        }\n        return $this->isMirror($root->left, $root->right);\n    }\n\n    /**\n     * Helper function to check if two subtrees are mirrors\n     * @param TreeNode $left\n     * @param TreeNode $right\n     * @return Boolean\n     */\n    private function isMirror($left, $right) {\n        if ($left === null && $right === null) {\n            return true; // Both nodes are null, symmetric\n        }\n        if ($left === null || $right === null) {\n            return false; // One node is null, not symmetric\n        }\n        return ($left->val === $right->val) &&\n               $this->isMirror($left->left, $right->right) &&\n               $this->isMirror($left->right, $right->left);\n    }\n}\n    ",
      "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "symmetric-tree",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 833,
      "statusCode": 10,
      "totalTestcases": 200,
      "question": {
        "title": "Symmetric Tree",
        "titleSlug": "symmetric-tree",
        "questionId": "101"
      },
      "status_code": 10,
      "passedTestCaseCnt": 200,
      "totalTestCaseCnt": 200
    }
  ]
}