{
  "submissions_dump": [
    {
      "id": 1771229071,
      "question_id": 460,
      "lang": "python",
      "lang_name": "Python",
      "time": "0minutes",
      "timestamp": 1757915854,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "347 ms",
      "url": "/submissions/detail/1771229071/",
      "is_pending": "Not Pending",
      "title": "LFU Cache",
      "memory": "82.7 MB",
      "code": "\nclass Node:\n    def __init__(self, key, val):\n        self.key = key\n        self.val = val\n        self.freq = 1\n        self.prev = None\n        self.next = None\n\nclass DLL:\n    def __init__(self):\n        self.head = Node(0, 0)\n        self.tail = Node(0, 0)\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.size = 0\n    \n    def add(self, node):\n        node.next = self.head.next\n        node.prev = self.head\n        self.head.next.prev = node\n        self.head.next = node\n        self.size += 1\n    \n    def remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        self.size -= 1\n    \n    def remove_last(self):\n        last = self.tail.prev\n        self.remove(last)\n        return last\n\nclass LFUCache(object):\n\n    def __init__(self, capacity):\n        \"\"\"\n        :type capacity: int\n        \"\"\"\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_to_node = {}\n        self.freq_to_list = {}\n\n    def get(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: int\n        \"\"\"\n        if key not in self.key_to_node:\n            return -1\n        node = self.key_to_node[key]\n        self.update_freq(node)\n        return node.val\n\n    def put(self, key, value):\n        \"\"\"\n        :type key: int\n        :type value: int\n        :rtype: None\n        \"\"\"\n        if self.capacity == 0:\n            return\n        \n        if key in self.key_to_node:\n            node = self.key_to_node[key]\n            node.val = value\n            self.update_freq(node)\n        else:\n            if len(self.key_to_node) >= self.capacity:\n                min_freq_list = self.freq_to_list[self.min_freq]\n                to_remove = min_freq_list.remove_last()\n                del self.key_to_node[to_remove.key]\n            \n            new_node = Node(key, value)\n            self.key_to_node[key] = new_node\n            if 1 not in self.freq_to_list:\n                self.freq_to_list[1] = DLL()\n            self.freq_to_list[1].add(new_node)\n            self.min_freq = 1\n    \n    def update_freq(self, node):\n        old_freq = node.freq\n        old_list = self.freq_to_list[old_freq]\n        old_list.remove(node)\n        \n        if old_freq == self.min_freq and old_list.size == 0:\n            self.min_freq += 1\n        \n        node.freq += 1\n        if node.freq not in self.freq_to_list:\n            self.freq_to_list[node.freq] = DLL()\n        self.freq_to_list[node.freq].add(node)\n# Your LFUCache object will be instantiated and called as such:\n# obj = LFUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)                                                                 \n    ",
      "compare_result": "1111111111111111111111111",
      "title_slug": "lfu-cache",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 420,
      "statusCode": 10,
      "totalTestcases": 25,
      "question": {
        "title": "LFU Cache",
        "titleSlug": "lfu-cache",
        "questionId": "460"
      },
      "status_code": 10,
      "passedTestCaseCnt": 25,
      "totalTestCaseCnt": 25
    },
    {
      "id": 1771228714,
      "question_id": 460,
      "lang": "php",
      "lang_name": "PHP",
      "time": "0minutes",
      "timestamp": 1757915833,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "80 ms",
      "url": "/submissions/detail/1771228714/",
      "is_pending": "Not Pending",
      "title": "LFU Cache",
      "memory": "103 MB",
      "code": "\nclass Node {\n    public $key;\n    public $val;\n    public $freq;\n    public $prev;\n    public $next;\n    \n    function __construct($key, $val) {\n        $this->key = $key;\n        $this->val = $val;\n        $this->freq = 1;\n        $this->prev = null;\n        $this->next = null;\n    }\n}\n\nclass DLL {\n    public $head;\n    public $tail;\n    public $size;\n    \n    function __construct() {\n        $this->head = new Node(0, 0);\n        $this->tail = new Node(0, 0);\n        $this->head->next = $this->tail;\n        $this->tail->prev = $this->head;\n        $this->size = 0;\n    }\n    \n    function add($node) {\n        $node->next = $this->head->next;\n        $node->prev = $this->head;\n        $this->head->next->prev = $node;\n        $this->head->next = $node;\n        $this->size++;\n    }\n    \n    function remove($node) {\n        $node->prev->next = $node->next;\n        $node->next->prev = $node->prev;\n        $this->size--;\n    }\n    \n    function removeLast() {\n        $last = $this->tail->prev;\n        $this->remove($last);\n        return $last;\n    }\n}\n\nclass LFUCache {\n    private $capacity;\n    private $minFreq;\n    private $keyToNode;\n    private $freqToList;\n    \n    /**\n     * @param Integer $capacity\n     */\n    function __construct($capacity) {\n        $this->capacity = $capacity;\n        $this->minFreq = 0;\n        $this->keyToNode = [];\n        $this->freqToList = [];\n    }\n  \n    /**\n     * @param Integer $key\n     * @return Integer\n     */\n    function get($key) {\n        if (!isset($this->keyToNode[$key])) return -1;\n        $node = $this->keyToNode[$key];\n        $this->updateFreq($node);\n        return $node->val;\n    }\n  \n    /**\n     * @param Integer $key\n     * @param Integer $value\n     * @return NULL\n     */\n    function put($key, $value) {\n        if ($this->capacity == 0) return;\n        \n        if (isset($this->keyToNode[$key])) {\n            $node = $this->keyToNode[$key];\n            $node->val = $value;\n            $this->updateFreq($node);\n        } else {\n            if (count($this->keyToNode) >= $this->capacity) {\n                $minFreqList = $this->freqToList[$this->minFreq];\n                $toRemove = $minFreqList->removeLast();\n                unset($this->keyToNode[$toRemove->key]);\n            }\n            \n            $newNode = new Node($key, $value);\n            $this->keyToNode[$key] = $newNode;\n            if (!isset($this->freqToList[1])) {\n                $this->freqToList[1] = new DLL();\n            }\n            $this->freqToList[1]->add($newNode);\n            $this->minFreq = 1;\n        }\n    }\n    \n    private function updateFreq($node) {\n        $oldFreq = $node->freq;\n        $oldList = $this->freqToList[$oldFreq];\n        $oldList->remove($node);\n        \n        if ($oldFreq == $this->minFreq && $oldList->size == 0) {\n            $this->minFreq++;\n        }\n        \n        $node->freq++;\n        if (!isset($this->freqToList[$node->freq])) {\n            $this->freqToList[$node->freq] = new DLL();\n        }\n        $this->freqToList[$node->freq]->add($node);\n    }\n}\n\n/**\n * Your LFUCache object will be instantiated and called as such:\n * $obj = LFUCache($capacity);\n * $ret_1 = $obj->get($key);\n * $obj->put($key, $value);\n */\n    ",
      "compare_result": "1111111111111111111111111",
      "title_slug": "lfu-cache",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 419,
      "statusCode": 10,
      "totalTestcases": 25,
      "question": {
        "title": "LFU Cache",
        "titleSlug": "lfu-cache",
        "questionId": "460"
      },
      "status_code": 10,
      "passedTestCaseCnt": 25,
      "totalTestCaseCnt": 25
    },
    {
      "id": 1771228323,
      "question_id": 460,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "1minute",
      "timestamp": 1757915808,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "99 ms",
      "url": "/submissions/detail/1771228323/",
      "is_pending": "Not Pending",
      "title": "LFU Cache",
      "memory": "112.6 MB",
      "code": "\nclass Node {\n    constructor(key, val) {\n        this.key = key;\n        this.val = val;\n        this.freq = 1;\n        this.prev = null;\n        this.next = null;\n    }\n}\n\nclass DLL {\n    constructor() {\n        this.head = new Node(0, 0);\n        this.tail = new Node(0, 0);\n        this.head.next = this.tail;\n        this.tail.prev = this.head;\n        this.size = 0;\n    }\n    \n    add(node) {\n        node.next = this.head.next;\n        node.prev = this.head;\n        this.head.next.prev = node;\n        this.head.next = node;\n        this.size++;\n    }\n    \n    remove(node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n        this.size--;\n    }\n    \n    removeLast() {\n        const last = this.tail.prev;\n        this.remove(last);\n        return last;\n    }\n}\n\n/**\n * @param {number} capacity\n */\nvar LFUCache = function(capacity) {\n    this.capacity = capacity;\n    this.minFreq = 0;\n    this.keyToNode = new Map();\n    this.freqToList = new Map();\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLFUCache.prototype.get = function(key) {\n    const node = this.keyToNode.get(key);\n    if (!node) return -1;\n    this.updateFreq(node);\n    return node.val;\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLFUCache.prototype.put = function(key, value) {\n    if (this.capacity === 0) return;\n    \n    const node = this.keyToNode.get(key);\n    if (node) {\n        node.val = value;\n        this.updateFreq(node);\n    } else {\n        if (this.keyToNode.size >= this.capacity) {\n            const minFreqList = this.freqToList.get(this.minFreq);\n            const toRemove = minFreqList.removeLast();\n            this.keyToNode.delete(toRemove.key);\n        }\n        \n        const newNode = new Node(key, value);\n        this.keyToNode.set(key, newNode);\n        if (!this.freqToList.has(1)) {\n            this.freqToList.set(1, new DLL());\n        }\n        this.freqToList.get(1).add(newNode);\n        this.minFreq = 1;\n    }\n};\n\nLFUCache.prototype.updateFreq = function(node) {\n    const oldFreq = node.freq;\n    const oldList = this.freqToList.get(oldFreq);\n    oldList.remove(node);\n    \n    if (oldFreq === this.minFreq && oldList.size === 0) {\n        this.minFreq++;\n    }\n    \n    node.freq++;\n    if (!this.freqToList.has(node.freq)) {\n        this.freqToList.set(node.freq, new DLL());\n    }\n    this.freqToList.get(node.freq).add(node);\n};\n\n/** \n * Your LFUCache object will be instantiated and called as such:\n * var obj = new LFUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n    ",
      "compare_result": "1111111111111111111111111",
      "title_slug": "lfu-cache",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 418,
      "statusCode": 10,
      "totalTestcases": 25,
      "question": {
        "title": "LFU Cache",
        "titleSlug": "lfu-cache",
        "questionId": "460"
      },
      "status_code": 10,
      "passedTestCaseCnt": 25,
      "totalTestCaseCnt": 25
    },
    {
      "id": 1771227856,
      "question_id": 460,
      "lang": "java",
      "lang_name": "Java",
      "time": "1minute",
      "timestamp": 1757915781,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "60 ms",
      "url": "/submissions/detail/1771227856/",
      "is_pending": "Not Pending",
      "title": "LFU Cache",
      "memory": "125.1 MB",
      "code": "\nclass LFUCache {\n    class Node {\n        int key, val, freq;\n        Node prev, next;\n        Node(int key, int val) {\n            this.key = key;\n            this.val = val;\n            this.freq = 1;\n        }\n    }\n    \n    class DLL {\n        Node head, tail;\n        int size;\n        DLL() {\n            head = new Node(0, 0);\n            tail = new Node(0, 0);\n            head.next = tail;\n            tail.prev = head;\n        }\n        \n        void add(Node node) {\n            node.next = head.next;\n            node.prev = head;\n            head.next.prev = node;\n            head.next = node;\n            size++;\n        }\n        \n        void remove(Node node) {\n            node.prev.next = node.next;\n            node.next.prev = node.prev;\n            size--;\n        }\n        \n        Node removeLast() {\n            Node last = tail.prev;\n            remove(last);\n            return last;\n        }\n    }\n    \n    int capacity, minFreq;\n    Map<Integer, Node> keyToNode;\n    Map<Integer, DLL> freqToList;\n\n    public LFUCache(int capacity) {\n        this.capacity = capacity;\n        this.minFreq = 0;\n        this.keyToNode = new HashMap<>();\n        this.freqToList = new HashMap<>();\n    }\n    \n    public int get(int key) {\n        Node node = keyToNode.get(key);\n        if (node == null) return -1;\n        updateFreq(node);\n        return node.val;\n    }\n    \n    public void put(int key, int value) {\n        if (capacity == 0) return;\n        \n        Node node = keyToNode.get(key);\n        if (node != null) {\n            node.val = value;\n            updateFreq(node);\n        } else {\n            if (keyToNode.size() >= capacity) {\n                DLL minFreqList = freqToList.get(minFreq);\n                Node toRemove = minFreqList.removeLast();\n                keyToNode.remove(toRemove.key);\n            }\n            \n            Node newNode = new Node(key, value);\n            keyToNode.put(key, newNode);\n            freqToList.computeIfAbsent(1, k -> new DLL()).add(newNode);\n            minFreq = 1;\n        }\n    }\n    \n    private void updateFreq(Node node) {\n        int oldFreq = node.freq;\n        DLL oldList = freqToList.get(oldFreq);\n        oldList.remove(node);\n        \n        if (oldFreq == minFreq && oldList.size == 0) {\n            minFreq++;\n        }\n        \n        node.freq++;\n        freqToList.computeIfAbsent(node.freq, k -> new DLL()).add(node);\n    }\n}\n\n/**\n * Your LFUCache object will be instantiated and called as such:\n * LFUCache obj = new LFUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n    ",
      "compare_result": "1111111111111111111111111",
      "title_slug": "lfu-cache",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 417,
      "statusCode": 10,
      "totalTestcases": 25,
      "question": {
        "title": "LFU Cache",
        "titleSlug": "lfu-cache",
        "questionId": "460"
      },
      "status_code": 10,
      "passedTestCaseCnt": 25,
      "totalTestCaseCnt": 25
    },
    {
      "id": 1771226289,
      "question_id": 312,
      "lang": "python",
      "lang_name": "Python",
      "time": "3minutes",
      "timestamp": 1757915684,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "2932 ms",
      "url": "/submissions/detail/1771226289/",
      "is_pending": "Not Pending",
      "title": "Burst Balloons",
      "memory": "14.6 MB",
      "code": "\nclass Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n\n        for left in range(n - 2, -1, -1):\n            for right in range(left + 2, n):\n                for i in range(left + 1, right):\n                    dp[left][right] = max(dp[left][right], nums[left] * nums[i] * nums[right] + dp[left][i] + dp[i][right])\n\n        return dp[0][n - 1]                                                                 \n",
      "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "burst-balloons",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 416,
      "statusCode": 10,
      "totalTestcases": 73,
      "question": {
        "title": "Burst Balloons",
        "titleSlug": "burst-balloons",
        "questionId": "312"
      },
      "status_code": 10,
      "passedTestCaseCnt": 73,
      "totalTestCaseCnt": 73
    },
    {
      "id": 1771226009,
      "question_id": 312,
      "lang": "php",
      "lang_name": "PHP",
      "time": "3minutes",
      "timestamp": 1757915668,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "1237 ms",
      "url": "/submissions/detail/1771226009/",
      "is_pending": "Not Pending",
      "title": "Burst Balloons",
      "memory": "23.8 MB",
      "code": "\nclass Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function maxCoins($nums) {\n        $nums = array_merge([1], $nums, [1]);\n        $n = count($nums);\n        $dp = array_fill(0, $n, array_fill(0, $n, 0));\n\n        for ($len = 2; $len < $n; $len++) {\n            for ($i = 0; $i < $n - $len; $i++) {\n                $j = $i + $len;\n                for ($k = $i + 1; $k < $j; $k++) {\n                    $dp[$i][$j] = max($dp[$i][$j], $dp[$i][$k] + $dp[$k][$j] + $nums[$i] * $nums[$k] * $nums[$j]);\n                }\n            }\n        }\n\n        return $dp[0][$n - 1];\n    }\n}\n    ",
      "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "burst-balloons",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 415,
      "statusCode": 10,
      "totalTestcases": 73,
      "question": {
        "title": "Burst Balloons",
        "titleSlug": "burst-balloons",
        "questionId": "312"
      },
      "status_code": 10,
      "passedTestCaseCnt": 73,
      "totalTestCaseCnt": 73
    },
    {
      "id": 1771225735,
      "question_id": 312,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "3minutes",
      "timestamp": 1757915652,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "121 ms",
      "url": "/submissions/detail/1771225735/",
      "is_pending": "Not Pending",
      "title": "Burst Balloons",
      "memory": "60.5 MB",
      "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxCoins = function(nums) {\n    const n = nums.length;\n    const arr = [1, ...nums, 1];\n    const dp = Array(n + 2).fill().map(() => Array(n + 2).fill(0));\n    \n    for (let len = 2; len < n + 2; len++) {\n        for (let left = 0; left < n + 2 - len; left++) {\n            const right = left + len;\n            for (let k = left + 1; k < right; k++) {\n                dp[left][right] = Math.max(\n                    dp[left][right],\n                    dp[left][k] + dp[k][right] + arr[left] * arr[k] * arr[right]\n                );\n            }\n        }\n    }\n    \n    return dp[0][n + 1];\n};\n    ",
      "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "burst-balloons",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 414,
      "statusCode": 10,
      "totalTestcases": 73,
      "question": {
        "title": "Burst Balloons",
        "titleSlug": "burst-balloons",
        "questionId": "312"
      },
      "status_code": 10,
      "passedTestCaseCnt": 73,
      "totalTestCaseCnt": 73
    },
    {
      "id": 1771225359,
      "question_id": 312,
      "lang": "java",
      "lang_name": "Java",
      "time": "4minutes",
      "timestamp": 1757915630,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "32 ms",
      "url": "/submissions/detail/1771225359/",
      "is_pending": "Not Pending",
      "title": "Burst Balloons",
      "memory": "42.1 MB",
      "code": "class Solution {\n    public int maxCoins(int[] nums) {\n        int n = nums.length;\n        int[] arr = new int[n + 2];\n        arr[0] = 1;\n        arr[n + 1] = 1;\n        for (int i = 0; i < n; i++) {\n            arr[i + 1] = nums[i];\n        }\n        int[][] dp = new int[n + 2][n + 2];\n        for (int i = n; i >= 0; i--) {\n            for (int j = i + 1; j < n + 2; j++) {\n                for (int k = i + 1; k < j; k++) {\n                    dp[i][j] = Math.max(dp[i][j], dp[i][k] + dp[k][j] + arr[i] * arr[k] * arr[j]);\n                }\n            }\n        }\n        return dp[0][n + 1];\n    }\n}\n    ",
      "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "burst-balloons",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 413,
      "statusCode": 10,
      "totalTestcases": 73,
      "question": {
        "title": "Burst Balloons",
        "titleSlug": "burst-balloons",
        "questionId": "312"
      },
      "status_code": 10,
      "passedTestCaseCnt": 73,
      "totalTestCaseCnt": 73
    },
    {
      "id": 1771224620,
      "question_id": 124,
      "lang": "python",
      "lang_name": "Python",
      "time": "5minutes",
      "timestamp": 1757915583,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "23 ms",
      "url": "/submissions/detail/1771224620/",
      "is_pending": "Not Pending",
      "title": "Binary Tree Maximum Path Sum",
      "memory": "25.5 MB",
      "code": "class Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int\n        \"\"\"\n        self.max_sum = float('-inf')\n\n        def maxPathSumHelper(node):\n            if not node:\n                return 0\n            left = max(maxPathSumHelper(node.left), 0)\n            right = max(maxPathSumHelper(node.right), 0)\n            self.max_sum = max(self.max_sum, node.val + left + right)\n            return node.val + max(left, right)\n\n        maxPathSumHelper(root)\n        return self.max_sum                                                            \n    ",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "binary-tree-maximum-path-sum",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 412,
      "statusCode": 10,
      "totalTestcases": 96,
      "question": {
        "title": "Binary Tree Maximum Path Sum",
        "titleSlug": "binary-tree-maximum-path-sum",
        "questionId": "124"
      },
      "status_code": 10,
      "passedTestCaseCnt": 96,
      "totalTestCaseCnt": 96
    },
    {
      "id": 1771224258,
      "question_id": 124,
      "lang": "php",
      "lang_name": "PHP",
      "time": "5minutes",
      "timestamp": 1757915561,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "5 ms",
      "url": "/submissions/detail/1771224258/",
      "is_pending": "Not Pending",
      "title": "Binary Tree Maximum Path Sum",
      "memory": "26.1 MB",
      "code": "\nclass Solution {\n    private $maxSum;\n\n    /**\n     * @param TreeNode $root\n     * @return Integer\n     */\n    function maxPathSum($root) {\n        $this->maxSum = PHP_INT_MIN;\n        $this->maxGain($root);\n        return $this->maxSum;\n    }\n    \n    private function maxGain($node) {\n        if ($node === null) return 0;\n        \n        $leftGain = max($this->maxGain($node->left), 0);\n        $rightGain = max($this->maxGain($node->right), 0);\n        \n        $pathSum = $node->val + $leftGain + $rightGain;\n        $this->maxSum = max($this->maxSum, $pathSum);\n        \n        return $node->val + max($leftGain, $rightGain);\n    }\n}\n    ",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "binary-tree-maximum-path-sum",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 411,
      "statusCode": 10,
      "totalTestcases": 96,
      "question": {
        "title": "Binary Tree Maximum Path Sum",
        "titleSlug": "binary-tree-maximum-path-sum",
        "questionId": "124"
      },
      "status_code": 10,
      "passedTestCaseCnt": 96,
      "totalTestCaseCnt": 96
    },
    {
      "id": 1771223885,
      "question_id": 124,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "5minutes",
      "timestamp": 1757915539,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "3 ms",
      "url": "/submissions/detail/1771223885/",
      "is_pending": "Not Pending",
      "title": "Binary Tree Maximum Path Sum",
      "memory": "66.3 MB",
      "code": "/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxPathSum = function(root) {\n    let max = -Infinity;\n    \n    function dfs(node) {\n        if (!node) return 0;\n        \n        const left = Math.max(0, dfs(node.left));\n        const right = Math.max(0, dfs(node.right));\n        \n        max = Math.max(max, left + right + node.val);\n        \n        return Math.max(left, right) + node.val;\n    }\n    \n    dfs(root);\n    \n    return max;\n};\n    ",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "binary-tree-maximum-path-sum",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 410,
      "statusCode": 10,
      "totalTestcases": 96,
      "question": {
        "title": "Binary Tree Maximum Path Sum",
        "titleSlug": "binary-tree-maximum-path-sum",
        "questionId": "124"
      },
      "status_code": 10,
      "passedTestCaseCnt": 96,
      "totalTestCaseCnt": 96
    },
    {
      "id": 1771223522,
      "question_id": 124,
      "lang": "java",
      "lang_name": "Java",
      "time": "6minutes",
      "timestamp": 1757915516,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "0 ms",
      "url": "/submissions/detail/1771223522/",
      "is_pending": "Not Pending",
      "title": "Binary Tree Maximum Path Sum",
      "memory": "44.3 MB",
      "code": "\nclass Solution {\n    private int maxSum = Integer.MIN_VALUE;\n    \n    public int maxPathSum(TreeNode root) {\n        maxGain(root);\n        return maxSum;\n    }\n    \n    private int maxGain(TreeNode node) {\n        if (node == null) return 0;\n        \n        int leftGain = Math.max(maxGain(node.left), 0);\n        int rightGain = Math.max(maxGain(node.right), 0);\n        \n        int pathSum = node.val + leftGain + rightGain;\n        maxSum = Math.max(maxSum, pathSum);\n        \n        return node.val + Math.max(leftGain, rightGain);\n    }\n}\n    ",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "binary-tree-maximum-path-sum",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 409,
      "statusCode": 10,
      "totalTestcases": 96,
      "question": {
        "title": "Binary Tree Maximum Path Sum",
        "titleSlug": "binary-tree-maximum-path-sum",
        "questionId": "124"
      },
      "status_code": 10,
      "passedTestCaseCnt": 96,
      "totalTestCaseCnt": 96
    },
    {
      "id": 1771222790,
      "question_id": 1414,
      "lang": "python",
      "lang_name": "Python",
      "time": "6minutes",
      "timestamp": 1757915474,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "512 ms",
      "url": "/submissions/detail/1771222790/",
      "is_pending": "Not Pending",
      "title": "Shortest Path in a Grid with Obstacles Elimination",
      "memory": "21.6 MB",
      "code": "\nclass Solution(object):\n    def shortestPath(self, grid, k):\n        \"\"\"\n        :type grid: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        m, n = len(grid), len(grid[0])\n        queue = [(0, 0, k)]\n        visited = {(0, 0, k)}\n        steps = 0\n\n        while queue:\n            next_queue = []\n            for x, y, remaining_k in queue:\n                if x == m - 1 and y == n - 1:\n                    return steps\n                for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < m and 0 <= ny < n:\n                        if grid[nx][ny] == 0 and (nx, ny, remaining_k) not in visited:\n                            next_queue.append((nx, ny, remaining_k))\n                            visited.add((nx, ny, remaining_k))\n                        elif grid[nx][ny] == 1 and remaining_k > 0 and (nx, ny, remaining_k - 1) not in visited:\n                            next_queue.append((nx, ny, remaining_k - 1))\n                            visited.add((nx, ny, remaining_k - 1))\n            queue = next_queue\n            steps += 1\n\n        return -1                                                          \n    ",
      "compare_result": "1111111111111111111111111111111111111111111111111111111",
      "title_slug": "shortest-path-in-a-grid-with-obstacles-elimination",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 408,
      "statusCode": 10,
      "totalTestcases": 55,
      "question": {
        "title": "Shortest Path in a Grid with Obstacles Elimination",
        "titleSlug": "shortest-path-in-a-grid-with-obstacles-elimination",
        "questionId": "1414"
      },
      "status_code": 10,
      "passedTestCaseCnt": 55,
      "totalTestCaseCnt": 55
    },
    {
      "id": 1771222180,
      "question_id": 1414,
      "lang": "php",
      "lang_name": "PHP",
      "time": "7minutes",
      "timestamp": 1757915437,
      "status": 11,
      "status_display": "Wrong Answer",
      "runtime": "N/A",
      "url": "/submissions/detail/1771222180/",
      "is_pending": "Not Pending",
      "title": "Shortest Path in a Grid with Obstacles Elimination",
      "memory": "N/A",
      "code": "class Solution {\n\n    /**\n     * @param Integer[][] $grid\n     * @param Integer $k\n     * @return Integer\n     */\n    function shortestPath($grid, $k) {\n        $m = count($grid);\n        $n = count($grid[0]);\n        $queue = new SplQueue();\n        $queue->enqueue([0, 0, $k, 0]);\n        $visited = [];\n        $visited[0][0][$k] = true;\n        $directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n        while (!$queue->isEmpty()) {\n            [$x, $y, $remainingEliminations, $steps] = $queue->dequeue();\n            if ($x == $m - 1 && $y == $n - 1) {\n                return $steps;\n            }\n            foreach ($directions as [$dx, $dy]) {\n                $nx = $x + $dx;\n                $ny = $y + $dy;\n                if ($nx >= 0 && $nx < $m && $ny >= 0 && $ny < $n) {\n                    if ($grid[$nx][$ny] == 0 && !isset($visited[$nx][$ny][$remainingEliminations])) {\n                        $visited[$nx][$ny][$remainingEliminations] = true;\n                        $queue->enqueue([$nx, $ny, $remainingEliminations, $steps + 1]);\n                    } else if ($grid[$nx][$ny] == 1 && $remainingEliminations > 0 && !isset($visited[$nx][$ny][$remainingEliminations - 1])) {\n                        $visited[$nx][$ny][$remainingEliminations - 1] = true;\n                        $queue->enqueue([$nx, $ny, $remainingEliminations - 1, $steps + 1]);\n                    }\n                }\n            }\n        }\n    }\n}\n    ",
      "compare_result": "1011111111111111111110111111111111011111111111111111111",
      "title_slug": "shortest-path-in-a-grid-with-obstacles-elimination",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 407,
      "statusCode": 11,
      "totalTestcases": 55,
      "question": {
        "title": "Shortest Path in a Grid with Obstacles Elimination",
        "titleSlug": "shortest-path-in-a-grid-with-obstacles-elimination",
        "questionId": "1414"
      },
      "status_code": 11,
      "passedTestCaseCnt": 52,
      "totalTestCaseCnt": 55
    },
    {
      "id": 1771221829,
      "question_id": 1414,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "7minutes",
      "timestamp": 1757915413,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "294 ms",
      "url": "/submissions/detail/1771221829/",
      "is_pending": "Not Pending",
      "title": "Shortest Path in a Grid with Obstacles Elimination",
      "memory": "79.7 MB",
      "code": "/**\n * @param {number[][]} grid\n * @param {number} k\n * @return {number}\n */\nvar shortestPath = function(grid, k) {\n    const m = grid.length;\n    const n = grid[0].length;\n    const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n    const queue = [[0, 0, k, 0]]; // [row, col, remaining_k, steps]\n    const visited = new Set();\n\n    while (queue.length > 0) {\n        const [row, col, remaining_k, steps] = queue.shift();\n\n        if (row === m - 1 && col === n - 1) {\n            return steps;\n        }\n\n        for (const [dx, dy] of directions) {\n            const newRow = row + dx;\n            const newCol = col + dy;\n\n            if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n) {\n                const newRemainingK = remaining_k - grid[newRow][newCol];\n\n                if (newRemainingK >= 0) {\n                    const key = `${newRow},${newCol},${newRemainingK}`;\n                    if (!visited.has(key)) {\n                        visited.add(key);\n                        queue.push([newRow, newCol, newRemainingK, steps + 1]);\n                    }\n                }\n            }\n        }\n    }\n\n    return -1;\n};\n    ",
      "compare_result": "1111111111111111111111111111111111111111111111111111111",
      "title_slug": "shortest-path-in-a-grid-with-obstacles-elimination",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 406,
      "statusCode": 10,
      "totalTestcases": 55,
      "question": {
        "title": "Shortest Path in a Grid with Obstacles Elimination",
        "titleSlug": "shortest-path-in-a-grid-with-obstacles-elimination",
        "questionId": "1414"
      },
      "status_code": 10,
      "passedTestCaseCnt": 55,
      "totalTestCaseCnt": 55
    },
    {
      "id": 1771220651,
      "question_id": 1414,
      "lang": "java",
      "lang_name": "Java",
      "time": "9minutes",
      "timestamp": 1757915339,
      "status": 11,
      "status_display": "Wrong Answer",
      "runtime": "N/A",
      "url": "/submissions/detail/1771220651/",
      "is_pending": "Not Pending",
      "title": "Shortest Path in a Grid with Obstacles Elimination",
      "memory": "N/A",
      "code": "\nimport java.util.Queue;\nimport java.util.LinkedList;\nimport java.util.Arrays;\nclass Solution {\n    public int shortestPath(int[][] grid, int k) {\n        int m = grid.length, n = grid[0].length;\n        int[][] dirs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        int[][] visited = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            Arrays.fill(visited[i], Integer.MAX_VALUE);\n        }\n        Queue<int[]> q = new LinkedList<>();\n        q.offer(new int[]{0, 0, 0, k});\n        while (!q.isEmpty()) {\n            int[] cur = q.poll();\n            int x = cur[0], y = cur[1];\n            if (x == m - 1 && y == n - 1) {\n                return cur[2];\n            }\n            for (int[] dir : dirs) {\n                int nx = x + dir[0], ny = y + dir[1];\n                if (nx < 0 || nx >= m || ny < 0 || ny >= n) {\n                    continue;\n                }\n                int o = cur[3] - grid[nx][ny];\n                if (o >= 0 && cur[2] + 1 < visited[nx][ny]) {\n                    visited[nx][ny] = cur[2] + 1;\n                    q.offer(new int[]{nx, ny, cur[2] + 1, o});\n                }\n            }\n        }\n        return -1;\n\n    }\n}\n    ",
      "compare_result": "1111111111111111111111011011111111111111111111101011111",
      "title_slug": "shortest-path-in-a-grid-with-obstacles-elimination",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 405,
      "statusCode": 11,
      "totalTestcases": 55,
      "question": {
        "title": "Shortest Path in a Grid with Obstacles Elimination",
        "titleSlug": "shortest-path-in-a-grid-with-obstacles-elimination",
        "questionId": "1414"
      },
      "status_code": 11,
      "passedTestCaseCnt": 51,
      "totalTestCaseCnt": 55
    },
    {
      "id": 1771219619,
      "question_id": 297,
      "lang": "python",
      "lang_name": "Python",
      "time": "10minutes",
      "timestamp": 1757915273,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "86 ms",
      "url": "/submissions/detail/1771219619/",
      "is_pending": "Not Pending",
      "title": "Serialize and Deserialize Binary Tree",
      "memory": "23.2 MB",
      "code": "\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        def preorder(node):\n            if not node:\n                vals.append('null')\n            else:\n                vals.append(str(node.val))\n                preorder(node.left)\n                preorder(node.right)\n        \n        vals = []\n        preorder(root)\n        return ','.join(vals)\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        def build():\n            val = next(vals)\n            if val == 'null':\n                return None\n            node = TreeNode(int(val))\n            node.left = build()\n            node.right = build()\n            return node\n        \n        vals = iter(data.split(','))\n        return build()\n\n# Your Codec object will be instantiated and called as such:\n# ser = Codec()\n# deser = Codec()\n# ans = deser.deserialize(ser.serialize(root))                                                         \n    ",
      "compare_result": "11111111111111111111111111111111111111111111111111111",
      "title_slug": "serialize-and-deserialize-binary-tree",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 404,
      "statusCode": 10,
      "totalTestcases": 53,
      "question": {
        "title": "Serialize and Deserialize Binary Tree",
        "titleSlug": "serialize-and-deserialize-binary-tree",
        "questionId": "297"
      },
      "status_code": 10,
      "passedTestCaseCnt": 53,
      "totalTestCaseCnt": 53
    },
    {
      "id": 1771219145,
      "question_id": 297,
      "lang": "php",
      "lang_name": "PHP",
      "time": "10minutes",
      "timestamp": 1757915245,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "20 ms",
      "url": "/submissions/detail/1771219145/",
      "is_pending": "Not Pending",
      "title": "Serialize and Deserialize Binary Tree",
      "memory": "25.1 MB",
      "code": "\nclass Codec {\n    private $index;\n    \n    function __construct() {\n        \n    }\n  \n    /**\n     * @param TreeNode $root\n     * @return String\n     */\n    function serialize($root) {\n        $result = [];\n        $this->preorder($root, $result);\n        return implode(',', $result);\n    }\n    \n    private function preorder($node, &$result) {\n        if ($node === null) {\n            $result[] = 'null';\n            return;\n        }\n        $result[] = $node->val;\n        $this->preorder($node->left, $result);\n        $this->preorder($node->right, $result);\n    }\n  \n    /**\n     * @param String $data\n     * @return TreeNode\n     */\n    function deserialize($data) {\n        $values = explode(',', $data);\n        $this->index = 0;\n        return $this->buildTree($values);\n    }\n    \n    private function buildTree($values) {\n        if ($values[$this->index] === 'null') {\n            $this->index++;\n            return null;\n        }\n        \n        $node = new TreeNode(intval($values[$this->index]));\n        $this->index++;\n        $node->left = $this->buildTree($values);\n        $node->right = $this->buildTree($values);\n        return $node;\n    }\n}\n\n/**\n * Your Codec object will be instantiated and called as such:\n * $ser = Codec();\n * $deser = Codec();\n * $data = $ser->serialize($root);\n * $ans = $deser->deserialize($data);\n */\n    ",
      "compare_result": "11111111111111111111111111111111111111111111111111111",
      "title_slug": "serialize-and-deserialize-binary-tree",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 403,
      "statusCode": 10,
      "totalTestcases": 53,
      "question": {
        "title": "Serialize and Deserialize Binary Tree",
        "titleSlug": "serialize-and-deserialize-binary-tree",
        "questionId": "297"
      },
      "status_code": 10,
      "passedTestCaseCnt": 53,
      "totalTestCaseCnt": 53
    },
    {
      "id": 1771218760,
      "question_id": 297,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "11minutes",
      "timestamp": 1757915221,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "71 ms",
      "url": "/submissions/detail/1771218760/",
      "is_pending": "Not Pending",
      "title": "Serialize and Deserialize Binary Tree",
      "memory": "67.8 MB",
      "code": "\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function(root) {\n    const result = [];\n    \n    function preorder(node) {\n        if (!node) {\n            result.push('null');\n            return;\n        }\n        result.push(node.val.toString());\n        preorder(node.left);\n        preorder(node.right);\n    }\n    \n    preorder(root);\n    return result.join(',');\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n    const values = data.split(',');\n    let index = 0;\n    \n    function buildTree() {\n        if (values[index] === 'null') {\n            index++;\n            return null;\n        }\n        \n        const node = new TreeNode(parseInt(values[index]));\n        index++;\n        node.left = buildTree();\n        node.right = buildTree();\n        return node;\n    }\n    \n    return buildTree();\n};\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */\n    ",
      "compare_result": "11111111111111111111111111111111111111111111111111111",
      "title_slug": "serialize-and-deserialize-binary-tree",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 402,
      "statusCode": 10,
      "totalTestcases": 53,
      "question": {
        "title": "Serialize and Deserialize Binary Tree",
        "titleSlug": "serialize-and-deserialize-binary-tree",
        "questionId": "297"
      },
      "status_code": 10,
      "passedTestCaseCnt": 53,
      "totalTestCaseCnt": 53
    },
    {
      "id": 1771218412,
      "question_id": 297,
      "lang": "java",
      "lang_name": "Java",
      "time": "11minutes",
      "timestamp": 1757915201,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "9 ms",
      "url": "/submissions/detail/1771218412/",
      "is_pending": "Not Pending",
      "title": "Serialize and Deserialize Binary Tree",
      "memory": "45.7 MB",
      "code": "\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        StringBuilder sb = new StringBuilder();\n        serialize(root, sb);\n        return sb.toString();\n    }\n    \n    private void serialize(TreeNode node, StringBuilder sb) {\n        if (node == null) {\n            sb.append(\"null,\");\n        } else {\n            sb.append(node.val).append(\",\");\n            serialize(node.left, sb);\n            serialize(node.right, sb);\n        }\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        Queue<String> queue = new LinkedList<>(Arrays.asList(data.split(\",\")));\n        return deserialize(queue);\n    }\n    \n    private TreeNode deserialize(Queue<String> queue) {\n        String val = queue.poll();\n        if (\"null\".equals(val)) {\n            return null;\n        }\n        TreeNode node = new TreeNode(Integer.valueOf(val));\n        node.left = deserialize(queue);\n        node.right = deserialize(queue);\n        return node;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser = new Codec();\n// Codec deser = new Codec();\n// TreeNode ans = deser.deserialize(ser.serialize(root));\n    ",
      "compare_result": "11111111111111111111111111111111111111111111111111111",
      "title_slug": "serialize-and-deserialize-binary-tree",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 401,
      "statusCode": 10,
      "totalTestcases": 53,
      "question": {
        "title": "Serialize and Deserialize Binary Tree",
        "titleSlug": "serialize-and-deserialize-binary-tree",
        "questionId": "297"
      },
      "status_code": 10,
      "passedTestCaseCnt": 53,
      "totalTestCaseCnt": 53
    }
  ]
}