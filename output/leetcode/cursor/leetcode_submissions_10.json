{
  "submissions_dump": [
    {
      "id": 1776882157,
      "question_id": 460,
      "lang": "python",
      "lang_name": "Python",
      "time": "2minutes",
      "timestamp": 1758362110,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "424 ms",
      "url": "/submissions/detail/1776882157/",
      "is_pending": "Not Pending",
      "title": "LFU Cache",
      "memory": "82.7 MB",
      "code": "\nclass Node:\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.value = value\n        self.freq = 1\n        self.prev = None\n        self.next = None\n\nclass DoublyLinkedList:\n    def __init__(self):\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.size = 0\n    \n    def add_to_head(self, node):\n        node.next = self.head.next\n        node.prev = self.head\n        self.head.next.prev = node\n        self.head.next = node\n        self.size += 1\n    \n    def remove_node(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        self.size -= 1\n    \n    def remove_tail(self):\n        if self.size > 0:\n            last_node = self.tail.prev\n            self.remove_node(last_node)\n            return last_node\n        return None\n\nclass LFUCache(object):\n\n    def __init__(self, capacity):\n        \"\"\"\n        :type capacity: int\n        \"\"\"\n        self.capacity = capacity\n        self.cache = {}  # key -> node\n        self.freq_map = {}  # freq -> DoublyLinkedList\n        self.min_freq = 0\n\n    def get(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: int\n        \"\"\"\n        if key not in self.cache:\n            return -1\n        \n        node = self.cache[key]\n        self.update_frequency(node)\n        return node.value\n\n    def put(self, key, value):\n        \"\"\"\n        :type key: int\n        :type value: int\n        :rtype: None\n        \"\"\"\n        if self.capacity == 0:\n            return\n        \n        if key in self.cache:\n            node = self.cache[key]\n            node.value = value\n            self.update_frequency(node)\n        else:\n            if len(self.cache) >= self.capacity:\n                self.evict_least_frequent()\n            \n            new_node = Node(key, value)\n            self.cache[key] = new_node\n            self.add_to_freq_list(new_node)\n            self.min_freq = 1\n    \n    def update_frequency(self, node):\n        # Remove from current frequency list\n        self.remove_from_freq_list(node)\n        \n        # Update frequency\n        node.freq += 1\n        \n        # Add to new frequency list\n        self.add_to_freq_list(node)\n    \n    def add_to_freq_list(self, node):\n        freq = node.freq\n        if freq not in self.freq_map:\n            self.freq_map[freq] = DoublyLinkedList()\n        self.freq_map[freq].add_to_head(node)\n    \n    def remove_from_freq_list(self, node):\n        freq = node.freq\n        if freq in self.freq_map:\n            self.freq_map[freq].remove_node(node)\n            if self.freq_map[freq].size == 0:\n                del self.freq_map[freq]\n                if freq == self.min_freq:\n                    self.min_freq += 1\n    \n    def evict_least_frequent(self):\n        if self.min_freq in self.freq_map:\n            freq_list = self.freq_map[self.min_freq]\n            node_to_remove = freq_list.remove_tail()\n            if node_to_remove:\n                del self.cache[node_to_remove.key]\n                if freq_list.size == 0:\n                    del self.freq_map[self.min_freq]\n# Your LFUCache object will be instantiated and called as such:\n# obj = LFUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)                                                                 \n    ",
      "compare_result": "1111111111111111111111111",
      "title_slug": "lfu-cache",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 820,
      "statusCode": 10,
      "totalTestcases": 25,
      "question": {
        "title": "LFU Cache",
        "titleSlug": "lfu-cache",
        "questionId": "460"
      },
      "status_code": 10,
      "passedTestCaseCnt": 25,
      "totalTestCaseCnt": 25
    },
    {
      "id": 1776881863,
      "question_id": 460,
      "lang": "php",
      "lang_name": "PHP",
      "time": "2minutes",
      "timestamp": 1758362086,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "87 ms",
      "url": "/submissions/detail/1776881863/",
      "is_pending": "Not Pending",
      "title": "LFU Cache",
      "memory": "103.2 MB",
      "code": "\nclass LFUCache {\n    private $capacity;\n    private $keyToNode;\n    private $freqToNodes;\n    private $minFreq;\n    \n    /**\n     * @param Integer $capacity\n     */\n    function __construct($capacity) {\n        $this->capacity = $capacity;\n        $this->keyToNode = [];\n        $this->freqToNodes = [];\n        $this->minFreq = 0;\n    }\n  \n    /**\n     * @param Integer $key\n     * @return Integer\n     */\n    function get($key) {\n        if (!isset($this->keyToNode[$key])) {\n            return -1;\n        }\n        \n        $node = $this->keyToNode[$key];\n        $this->updateFrequency($node);\n        return $node->value;\n    }\n  \n    /**\n     * @param Integer $key\n     * @param Integer $value\n     * @return NULL\n     */\n    function put($key, $value) {\n        if ($this->capacity <= 0) {\n            return;\n        }\n        \n        if (isset($this->keyToNode[$key])) {\n            // Update existing key\n            $node = $this->keyToNode[$key];\n            $node->value = $value;\n            $this->updateFrequency($node);\n        } else {\n            // Add new key\n            if (count($this->keyToNode) >= $this->capacity) {\n                $this->evict();\n            }\n            \n            $node = new Node($key, $value, 1);\n            $this->keyToNode[$key] = $node;\n            $this->addToFrequencyList($node, 1);\n            $this->minFreq = 1;\n        }\n    }\n    \n    private function updateFrequency($node) {\n        $oldFreq = $node->freq;\n        $node->freq++;\n        \n        $this->removeFromFrequencyList($node, $oldFreq);\n        $this->addToFrequencyList($node, $node->freq);\n        \n        if ($oldFreq === $this->minFreq && !isset($this->freqToNodes[$oldFreq])) {\n            $this->minFreq = $node->freq;\n        }\n    }\n    \n    private function addToFrequencyList($node, $freq) {\n        if (!isset($this->freqToNodes[$freq])) {\n            $this->freqToNodes[$freq] = new DoublyLinkedList();\n        }\n        $this->freqToNodes[$freq]->addToHead($node);\n    }\n    \n    private function removeFromFrequencyList($node, $freq) {\n        if (isset($this->freqToNodes[$freq])) {\n            $this->freqToNodes[$freq]->remove($node);\n            if ($this->freqToNodes[$freq]->isEmpty()) {\n                unset($this->freqToNodes[$freq]);\n            }\n        }\n    }\n    \n    private function evict() {\n        if (!isset($this->freqToNodes[$this->minFreq])) {\n            return;\n        }\n        \n        $lruList = $this->freqToNodes[$this->minFreq];\n        $nodeToRemove = $lruList->removeTail();\n        \n        if ($nodeToRemove) {\n            unset($this->keyToNode[$nodeToRemove->key]);\n        }\n    }\n}\n\nclass Node {\n    public $key;\n    public $value;\n    public $freq;\n    public $prev;\n    public $next;\n    \n    public function __construct($key, $value, $freq) {\n        $this->key = $key;\n        $this->value = $value;\n        $this->freq = $freq;\n        $this->prev = null;\n        $this->next = null;\n    }\n}\n\nclass DoublyLinkedList {\n    public $head;\n    public $tail;\n    \n    public function __construct() {\n        $this->head = new Node(0, 0, 0);\n        $this->tail = new Node(0, 0, 0);\n        $this->head->next = $this->tail;\n        $this->tail->prev = $this->head;\n    }\n    \n    public function addToHead($node) {\n        $node->prev = $this->head;\n        $node->next = $this->head->next;\n        $this->head->next->prev = $node;\n        $this->head->next = $node;\n    }\n    \n    public function remove($node) {\n        $node->prev->next = $node->next;\n        $node->next->prev = $node->prev;\n    }\n    \n    public function removeTail() {\n        if ($this->isEmpty()) {\n            return null;\n        }\n        \n        $lastNode = $this->tail->prev;\n        $this->remove($lastNode);\n        return $lastNode;\n    }\n    \n    public function isEmpty() {\n        return $this->head->next === $this->tail;\n    }\n}\n\n/**\n * Your LFUCache object will be instantiated and called as such:\n * $obj = LFUCache($capacity);\n * $ret_1 = $obj->get($key);\n * $obj->put($key, $value);\n */\n    ",
      "compare_result": "1111111111111111111111111",
      "title_slug": "lfu-cache",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 819,
      "statusCode": 10,
      "totalTestcases": 25,
      "question": {
        "title": "LFU Cache",
        "titleSlug": "lfu-cache",
        "questionId": "460"
      },
      "status_code": 10,
      "passedTestCaseCnt": 25,
      "totalTestCaseCnt": 25
    },
    {
      "id": 1776881557,
      "question_id": 460,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "3minutes",
      "timestamp": 1758362063,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "639 ms",
      "url": "/submissions/detail/1776881557/",
      "is_pending": "Not Pending",
      "title": "LFU Cache",
      "memory": "112.3 MB",
      "code": "\n/**\n * @param {number} capacity\n */\nvar LFUCache = function(capacity) {\n    this.capacity = capacity;\n    this.minFreq = 0;\n    this.keyToValue = new Map();\n    this.keyToFreq = new Map();\n    this.freqToKeys = new Map();\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLFUCache.prototype.get = function(key) {\n    if (!this.keyToValue.has(key)) {\n        return -1;\n    }\n    \n    // Update frequency\n    this.updateFrequency(key);\n    return this.keyToValue.get(key);\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLFUCache.prototype.put = function(key, value) {\n    if (this.capacity <= 0) {\n        return;\n    }\n    \n    if (this.keyToValue.has(key)) {\n        // Update existing key\n        this.keyToValue.set(key, value);\n        this.updateFrequency(key);\n    } else {\n        // Insert new key\n        if (this.keyToValue.size >= this.capacity) {\n            this.evictLFU();\n        }\n        \n        this.keyToValue.set(key, value);\n        this.keyToFreq.set(key, 1);\n        \n        if (!this.freqToKeys.has(1)) {\n            this.freqToKeys.set(1, new Set());\n        }\n        this.freqToKeys.get(1).add(key);\n        this.minFreq = 1;\n    }\n};\n\nLFUCache.prototype.updateFrequency = function(key) {\n    const freq = this.keyToFreq.get(key);\n    \n    // Remove from current frequency list\n    this.freqToKeys.get(freq).delete(key);\n    if (this.freqToKeys.get(freq).size === 0) {\n        this.freqToKeys.delete(freq);\n        if (this.minFreq === freq) {\n            this.minFreq++;\n        }\n    }\n    \n    // Add to new frequency list\n    const newFreq = freq + 1;\n    this.keyToFreq.set(key, newFreq);\n    \n    if (!this.freqToKeys.has(newFreq)) {\n        this.freqToKeys.set(newFreq, new Set());\n    }\n    this.freqToKeys.get(newFreq).add(key);\n};\n\nLFUCache.prototype.evictLFU = function() {\n    const minFreqKeys = this.freqToKeys.get(this.minFreq);\n    const keyToEvict = minFreqKeys.values().next().value;\n    \n    minFreqKeys.delete(keyToEvict);\n    if (minFreqKeys.size === 0) {\n        this.freqToKeys.delete(this.minFreq);\n    }\n    \n    this.keyToValue.delete(keyToEvict);\n    this.keyToFreq.delete(keyToEvict);\n};\n\n/** \n * Your LFUCache object will be instantiated and called as such:\n * var obj = new LFUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n    ",
      "compare_result": "1111111111111111111111111",
      "title_slug": "lfu-cache",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 818,
      "statusCode": 10,
      "totalTestcases": 25,
      "question": {
        "title": "LFU Cache",
        "titleSlug": "lfu-cache",
        "questionId": "460"
      },
      "status_code": 10,
      "passedTestCaseCnt": 25,
      "totalTestCaseCnt": 25
    },
    {
      "id": 1776881217,
      "question_id": 460,
      "lang": "java",
      "lang_name": "Java",
      "time": "3minutes",
      "timestamp": 1758362036,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "74 ms",
      "url": "/submissions/detail/1776881217/",
      "is_pending": "Not Pending",
      "title": "LFU Cache",
      "memory": "137.8 MB",
      "code": "import java.util.*;\n\nclass LFUCache {\n    private int capacity;\n    private int minFreq;\n    private Map<Integer, Integer> keyToValue;\n    private Map<Integer, Integer> keyToFreq;\n    private Map<Integer, LinkedHashSet<Integer>> freqToKeys;\n    \n    public LFUCache(int capacity) {\n        this.capacity = capacity;\n        this.minFreq = 0;\n        this.keyToValue = new HashMap<>();\n        this.keyToFreq = new HashMap<>();\n        this.freqToKeys = new HashMap<>();\n    }\n    \n    public int get(int key) {\n        if (!keyToValue.containsKey(key)) {\n            return -1;\n        }\n        \n        // Update frequency\n        updateFrequency(key);\n        return keyToValue.get(key);\n    }\n    \n    public void put(int key, int value) {\n        if (capacity <= 0) {\n            return;\n        }\n        \n        if (keyToValue.containsKey(key)) {\n            // Update existing key\n            keyToValue.put(key, value);\n            updateFrequency(key);\n        } else {\n            // Insert new key\n            if (keyToValue.size() >= capacity) {\n                evictLFU();\n            }\n            \n            keyToValue.put(key, value);\n            keyToFreq.put(key, 1);\n            freqToKeys.computeIfAbsent(1, k -> new LinkedHashSet<>()).add(key);\n            minFreq = 1;\n        }\n    }\n    \n    private void updateFrequency(int key) {\n        int freq = keyToFreq.get(key);\n        \n        // Remove from current frequency list\n        freqToKeys.get(freq).remove(key);\n        if (freqToKeys.get(freq).isEmpty()) {\n            freqToKeys.remove(freq);\n            if (minFreq == freq) {\n                minFreq++;\n            }\n        }\n        \n        // Add to new frequency list\n        freq++;\n        keyToFreq.put(key, freq);\n        freqToKeys.computeIfAbsent(freq, k -> new LinkedHashSet<>()).add(key);\n    }\n    \n    private void evictLFU() {\n        LinkedHashSet<Integer> minFreqKeys = freqToKeys.get(minFreq);\n        int keyToEvict = minFreqKeys.iterator().next();\n        \n        minFreqKeys.remove(keyToEvict);\n        if (minFreqKeys.isEmpty()) {\n            freqToKeys.remove(minFreq);\n        }\n        \n        keyToValue.remove(keyToEvict);\n        keyToFreq.remove(keyToEvict);\n    }\n}\n\n/**\n * Your LFUCache object will be instantiated and called as such:\n * LFUCache obj = new LFUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n    ",
      "compare_result": "1111111111111111111111111",
      "title_slug": "lfu-cache",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 817,
      "statusCode": 10,
      "totalTestcases": 25,
      "question": {
        "title": "LFU Cache",
        "titleSlug": "lfu-cache",
        "questionId": "460"
      },
      "status_code": 10,
      "passedTestCaseCnt": 25,
      "totalTestCaseCnt": 25
    },
    {
      "id": 1776879461,
      "question_id": 312,
      "lang": "python",
      "lang_name": "Python",
      "time": "5minutes",
      "timestamp": 1758361896,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "3154 ms",
      "url": "/submissions/detail/1776879461/",
      "is_pending": "Not Pending",
      "title": "Burst Balloons",
      "memory": "14.3 MB",
      "code": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # Add boundary balloons with value 1\n        balloons = [1] + nums + [1]\n        n = len(balloons)\n        \n        # dp[i][j] = maximum coins from bursting balloons between i and j (exclusive)\n        dp = [[0] * n for _ in range(n)]\n        \n        # Fill dp table for different lengths\n        for length in range(2, n):  # length of subarray\n            for left in range(n - length):\n                right = left + length\n                \n                # Try each balloon between left and right as the last one to burst\n                for k in range(left + 1, right):\n                    # Coins from bursting balloon k last\n                    coins = balloons[left] * balloons[k] * balloons[right]\n                    # Add coins from left and right subproblems\n                    total = coins + dp[left][k] + dp[k][right]\n                    dp[left][right] = max(dp[left][right], total)\n        \n        return dp[0][n - 1]\n    ",
      "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "burst-balloons",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 816,
      "statusCode": 10,
      "totalTestcases": 73,
      "question": {
        "title": "Burst Balloons",
        "titleSlug": "burst-balloons",
        "questionId": "312"
      },
      "status_code": 10,
      "passedTestCaseCnt": 73,
      "totalTestCaseCnt": 73
    },
    {
      "id": 1776879219,
      "question_id": 312,
      "lang": "php",
      "lang_name": "PHP",
      "time": "6minutes",
      "timestamp": 1758361879,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "1228 ms",
      "url": "/submissions/detail/1776879219/",
      "is_pending": "Not Pending",
      "title": "Burst Balloons",
      "memory": "23 MB",
      "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function maxCoins($nums) {\n        $n = count($nums);\n        \n        // Add boundary balloons with value 1\n        $balloons = [1];\n        foreach ($nums as $num) {\n            $balloons[] = $num;\n        }\n        $balloons[] = 1;\n        $m = count($balloons);\n        \n        // dp[i][j] = maximum coins from bursting balloons between i and j (exclusive)\n        $dp = array_fill(0, $m, array_fill(0, $m, 0));\n        \n        // Fill dp for different lengths\n        for ($len = 2; $len < $m; $len++) {\n            for ($left = 0; $left < $m - $len; $left++) {\n                $right = $left + $len;\n                \n                // Try each balloon as the last one to burst in this range\n                for ($k = $left + 1; $k < $right; $k++) {\n                    $coins = $balloons[$left] * $balloons[$k] * $balloons[$right];\n                    $coins += $dp[$left][$k] + $dp[$k][$right];\n                    $dp[$left][$right] = max($dp[$left][$right], $coins);\n                }\n            }\n        }\n        \n        return $dp[0][$m - 1];\n    }\n}\n    ",
      "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "burst-balloons",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 815,
      "statusCode": 10,
      "totalTestcases": 73,
      "question": {
        "title": "Burst Balloons",
        "titleSlug": "burst-balloons",
        "questionId": "312"
      },
      "status_code": 10,
      "passedTestCaseCnt": 73,
      "totalTestCaseCnt": 73
    },
    {
      "id": 1776878988,
      "question_id": 312,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "6minutes",
      "timestamp": 1758361859,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "232 ms",
      "url": "/submissions/detail/1776878988/",
      "is_pending": "Not Pending",
      "title": "Burst Balloons",
      "memory": "55.7 MB",
      "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxCoins = function(nums) {\n    const n = nums.length;\n    const balloons = [1, ...nums, 1];\n    const memo = Array(n + 2).fill().map(() => Array(n + 2).fill(0));\n    \n    return burst(balloons, 1, n, memo);\n};\n\nfunction burst(balloons, left, right, memo) {\n    if (left > right) {\n        return 0;\n    }\n    \n    if (memo[left][right] !== 0) {\n        return memo[left][right];\n    }\n    \n    let maxCoins = 0;\n    \n    // Try bursting each balloon in the range [left, right] as the last one\n    for (let k = left; k <= right; k++) {\n        const coins = balloons[left - 1] * balloons[k] * balloons[right + 1];\n        const leftCoins = burst(balloons, left, k - 1, memo);\n        const rightCoins = burst(balloons, k + 1, right, memo);\n        maxCoins = Math.max(maxCoins, coins + leftCoins + rightCoins);\n    }\n    \n    memo[left][right] = maxCoins;\n    return maxCoins;\n}\n    ",
      "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "burst-balloons",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 814,
      "statusCode": 10,
      "totalTestcases": 73,
      "question": {
        "title": "Burst Balloons",
        "titleSlug": "burst-balloons",
        "questionId": "312"
      },
      "status_code": 10,
      "passedTestCaseCnt": 73,
      "totalTestCaseCnt": 73
    },
    {
      "id": 1776878575,
      "question_id": 312,
      "lang": "java",
      "lang_name": "Java",
      "time": "6minutes",
      "timestamp": 1758361828,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "108 ms",
      "url": "/submissions/detail/1776878575/",
      "is_pending": "Not Pending",
      "title": "Burst Balloons",
      "memory": "42.8 MB",
      "code": "class Solution {\n    public int maxCoins(int[] nums) {\n        int n = nums.length;\n        int[] balloons = new int[n + 2];\n        balloons[0] = 1;\n        balloons[n + 1] = 1;\n        \n        for (int i = 0; i < n; i++) {\n            balloons[i + 1] = nums[i];\n        }\n        \n        int[][] memo = new int[n + 2][n + 2];\n        return burst(balloons, 1, n, memo);\n    }\n    \n    private int burst(int[] balloons, int left, int right, int[][] memo) {\n        if (left > right) {\n            return 0;\n        }\n        \n        if (memo[left][right] != 0) {\n            return memo[left][right];\n        }\n        \n        int maxCoins = 0;\n        \n        // Try bursting each balloon in the range [left, right] as the last one\n        for (int k = left; k <= right; k++) {\n            int coins = balloons[left - 1] * balloons[k] * balloons[right + 1];\n            coins += burst(balloons, left, k - 1, memo);\n            coins += burst(balloons, k + 1, right, memo);\n            maxCoins = Math.max(maxCoins, coins);\n        }\n        \n        memo[left][right] = maxCoins;\n        return maxCoins;\n    }\n}\n    ",
      "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "burst-balloons",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 813,
      "statusCode": 10,
      "totalTestcases": 73,
      "question": {
        "title": "Burst Balloons",
        "titleSlug": "burst-balloons",
        "questionId": "312"
      },
      "status_code": 10,
      "passedTestCaseCnt": 73,
      "totalTestCaseCnt": 73
    },
    {
      "id": 1776877403,
      "question_id": 124,
      "lang": "python",
      "lang_name": "Python",
      "time": "8minutes",
      "timestamp": 1758361738,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "30 ms",
      "url": "/submissions/detail/1776877403/",
      "is_pending": "Not Pending",
      "title": "Binary Tree Maximum Path Sum",
      "memory": "25.6 MB",
      "code": "class Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int\n        \"\"\"\n        self.max_sum = float('-inf')\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            # Recursively get the max gain from left and right subtrees\n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            # The price to start a new path where 'node' is the highest node\n            price_newpath = node.val + left_gain + right_gain\n            \n            # Update the global maximum\n            self.max_sum = max(self.max_sum, price_newpath)\n            \n            # Return the maximum gain if we continue the same path\n            return node.val + max(left_gain, right_gain)\n        \n        max_gain(root)\n        return self.max_sum\n    ",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "binary-tree-maximum-path-sum",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 812,
      "statusCode": 10,
      "totalTestcases": 96,
      "question": {
        "title": "Binary Tree Maximum Path Sum",
        "titleSlug": "binary-tree-maximum-path-sum",
        "questionId": "124"
      },
      "status_code": 10,
      "passedTestCaseCnt": 96,
      "totalTestCaseCnt": 96
    },
    {
      "id": 1776877087,
      "question_id": 124,
      "lang": "php",
      "lang_name": "PHP",
      "time": "8minutes",
      "timestamp": 1758361714,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "5 ms",
      "url": "/submissions/detail/1776877087/",
      "is_pending": "Not Pending",
      "title": "Binary Tree Maximum Path Sum",
      "memory": "25.8 MB",
      "code": "class Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer\n     */\n    function maxPathSum($root) {\n        $maxSum = PHP_INT_MIN;\n        $this->maxPathSumHelper($root, $maxSum);\n        return $maxSum;\n    }\n    \n    private function maxPathSumHelper($node, &$maxSum) {\n        if ($node === null) {\n            return 0;\n        }\n        \n        // Get maximum path sum from left and right subtrees\n        $leftSum = max(0, $this->maxPathSumHelper($node->left, $maxSum));\n        $rightSum = max(0, $this->maxPathSumHelper($node->right, $maxSum));\n        \n        // Current path sum through this node\n        $currentSum = $node->val + $leftSum + $rightSum;\n        \n        // Update global maximum\n        $maxSum = max($maxSum, $currentSum);\n        \n        // Return maximum path sum that can be extended upward\n        return $node->val + max($leftSum, $rightSum);\n    }\n}\n    ",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "binary-tree-maximum-path-sum",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 811,
      "statusCode": 10,
      "totalTestcases": 96,
      "question": {
        "title": "Binary Tree Maximum Path Sum",
        "titleSlug": "binary-tree-maximum-path-sum",
        "questionId": "124"
      },
      "status_code": 10,
      "passedTestCaseCnt": 96,
      "totalTestCaseCnt": 96
    },
    {
      "id": 1776876800,
      "question_id": 124,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "9minutes",
      "timestamp": 1758361692,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "3 ms",
      "url": "/submissions/detail/1776876800/",
      "is_pending": "Not Pending",
      "title": "Binary Tree Maximum Path Sum",
      "memory": "65.7 MB",
      "code": "/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxPathSum = function(root) {\n    let maxSum = -Infinity;\n    \n    function maxGain(node) {\n        if (node === null) {\n            return 0;\n        }\n        \n        // Recursively get the maximum gain from left and right subtrees\n        const leftGain = Math.max(maxGain(node.left), 0);\n        const rightGain = Math.max(maxGain(node.right), 0);\n        \n        // Calculate the maximum path sum that includes current node\n        const currentMaxPath = node.val + leftGain + rightGain;\n        \n        // Update the global maximum\n        maxSum = Math.max(maxSum, currentMaxPath);\n        \n        // Return the maximum gain that can be extended upward\n        return node.val + Math.max(leftGain, rightGain);\n    }\n    \n    maxGain(root);\n    return maxSum;\n};\n    ",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "binary-tree-maximum-path-sum",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 810,
      "statusCode": 10,
      "totalTestcases": 96,
      "question": {
        "title": "Binary Tree Maximum Path Sum",
        "titleSlug": "binary-tree-maximum-path-sum",
        "questionId": "124"
      },
      "status_code": 10,
      "passedTestCaseCnt": 96,
      "totalTestCaseCnt": 96
    },
    {
      "id": 1776876507,
      "question_id": 124,
      "lang": "java",
      "lang_name": "Java",
      "time": "9minutes",
      "timestamp": 1758361668,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "0 ms",
      "url": "/submissions/detail/1776876507/",
      "is_pending": "Not Pending",
      "title": "Binary Tree Maximum Path Sum",
      "memory": "44.2 MB",
      "code": "class Solution {\n    private int maxSum = Integer.MIN_VALUE;\n    \n    public int maxPathSum(TreeNode root) {\n        maxGain(root);\n        return maxSum;\n    }\n    \n    private int maxGain(TreeNode node) {\n        if (node == null) {\n            return 0;\n        }\n        \n        // Recursively get the maximum gain from left and right subtrees\n        int leftGain = Math.max(maxGain(node.left), 0);\n        int rightGain = Math.max(maxGain(node.right), 0);\n        \n        // Calculate the maximum path sum that includes current node\n        int currentMaxPath = node.val + leftGain + rightGain;\n        \n        // Update the global maximum\n        maxSum = Math.max(maxSum, currentMaxPath);\n        \n        // Return the maximum gain that can be extended upward\n        return node.val + Math.max(leftGain, rightGain);\n    }\n}",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "binary-tree-maximum-path-sum",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 809,
      "statusCode": 10,
      "totalTestcases": 96,
      "question": {
        "title": "Binary Tree Maximum Path Sum",
        "titleSlug": "binary-tree-maximum-path-sum",
        "questionId": "124"
      },
      "status_code": 10,
      "passedTestCaseCnt": 96,
      "totalTestCaseCnt": 96
    },
    {
      "id": 1776875704,
      "question_id": 1414,
      "lang": "python",
      "lang_name": "Python",
      "time": "10minutes",
      "timestamp": 1758361603,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "538 ms",
      "url": "/submissions/detail/1776875704/",
      "is_pending": "Not Pending",
      "title": "Shortest Path in a Grid with Obstacles Elimination",
      "memory": "20.6 MB",
      "code": "class Solution(object):\n    def shortestPath(self, grid, k):\n        \"\"\"\n        :type grid: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        m, n = len(grid), len(grid[0])\n        \n        # BFS with state: (row, col, obstacles_eliminated)\n        queue = [(0, 0, 0, 0)]  # (row, col, obstacles_eliminated, steps)\n        visited = set()\n        visited.add((0, 0, 0))\n        \n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        \n        while queue:\n            row, col, obstacles, steps = queue.pop(0)\n            \n            # Check if we reached the destination\n            if row == m - 1 and col == n - 1:\n                return steps\n            \n            # Try all four directions\n            for dr, dc in directions:\n                new_row, new_col = row + dr, col + dc\n                \n                # Check bounds\n                if 0 <= new_row < m and 0 <= new_col < n:\n                    new_obstacles = obstacles\n                    \n                    # If the new cell is an obstacle\n                    if grid[new_row][new_col] == 1:\n                        new_obstacles += 1\n                    \n                    # Check if we can eliminate this obstacle\n                    if new_obstacles <= k:\n                        state = (new_row, new_col, new_obstacles)\n                        if state not in visited:\n                            visited.add(state)\n                            queue.append((new_row, new_col, new_obstacles, steps + 1))\n        \n        return -1\n    ",
      "compare_result": "1111111111111111111111111111111111111111111111111111111",
      "title_slug": "shortest-path-in-a-grid-with-obstacles-elimination",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 808,
      "statusCode": 10,
      "totalTestcases": 55,
      "question": {
        "title": "Shortest Path in a Grid with Obstacles Elimination",
        "titleSlug": "shortest-path-in-a-grid-with-obstacles-elimination",
        "questionId": "1414"
      },
      "status_code": 10,
      "passedTestCaseCnt": 55,
      "totalTestCaseCnt": 55
    },
    {
      "id": 1776875426,
      "question_id": 1414,
      "lang": "php",
      "lang_name": "PHP",
      "time": "11minutes",
      "timestamp": 1758361581,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "706 ms",
      "url": "/submissions/detail/1776875426/",
      "is_pending": "Not Pending",
      "title": "Shortest Path in a Grid with Obstacles Elimination",
      "memory": "25.1 MB",
      "code": "class Solution {\n\n    /**\n     * @param Integer[][] $grid\n     * @param Integer $k\n     * @return Integer\n     */\n    function shortestPath($grid, $k) {\n        $m = count($grid);\n        $n = count($grid[0]);\n        \n        // State: [row, col, obstacles_eliminated]\n        $queue = [[0, 0, 0]];\n        $visited = [];\n        $visited[0][0][0] = true;\n        \n        $directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n        $steps = 0;\n        \n        while (!empty($queue)) {\n            $size = count($queue);\n            \n            for ($i = 0; $i < $size; $i++) {\n                [$row, $col, $obstacles] = array_shift($queue);\n                \n                // Check if we reached the destination\n                if ($row === $m - 1 && $col === $n - 1) {\n                    return $steps;\n                }\n                \n                // Try all four directions\n                foreach ($directions as [$dr, $dc]) {\n                    $newRow = $row + $dr;\n                    $newCol = $col + $dc;\n                    \n                    // Check bounds\n                    if ($newRow < 0 || $newRow >= $m || $newCol < 0 || $newCol >= $n) {\n                        continue;\n                    }\n                    \n                    $newObstacles = $obstacles;\n                    \n                    // If the new cell is an obstacle\n                    if ($grid[$newRow][$newCol] === 1) {\n                        $newObstacles++;\n                    }\n                    \n                    // Check if we can eliminate this obstacle\n                    if ($newObstacles > $k) {\n                        continue;\n                    }\n                    \n                    // Check if we've visited this state before\n                    if (isset($visited[$newRow][$newCol][$newObstacles])) {\n                        continue;\n                    }\n                    \n                    $visited[$newRow][$newCol][$newObstacles] = true;\n                    $queue[] = [$newRow, $newCol, $newObstacles];\n                }\n            }\n            \n            $steps++;\n        }\n        \n        return -1;\n    }\n}\n    ",
      "compare_result": "1111111111111111111111111111111111111111111111111111111",
      "title_slug": "shortest-path-in-a-grid-with-obstacles-elimination",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 807,
      "statusCode": 10,
      "totalTestcases": 55,
      "question": {
        "title": "Shortest Path in a Grid with Obstacles Elimination",
        "titleSlug": "shortest-path-in-a-grid-with-obstacles-elimination",
        "questionId": "1414"
      },
      "status_code": 10,
      "passedTestCaseCnt": 55,
      "totalTestCaseCnt": 55
    },
    {
      "id": 1776875084,
      "question_id": 1414,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "11minutes",
      "timestamp": 1758361553,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "186 ms",
      "url": "/submissions/detail/1776875084/",
      "is_pending": "Not Pending",
      "title": "Shortest Path in a Grid with Obstacles Elimination",
      "memory": "77.3 MB",
      "code": "/**\n * @param {number[][]} grid\n * @param {number} k\n * @return {number}\n */\nvar shortestPath = function(grid, k) {\n    const m = grid.length;\n    const n = grid[0].length;\n    \n    // State: [row, col, obstacles_eliminated]\n    const queue = [[0, 0, 0]];\n    const visited = Array(m).fill().map(() => \n        Array(n).fill().map(() => Array(k + 1).fill(false))\n    );\n    \n    visited[0][0][0] = true;\n    let steps = 0;\n    const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n    \n    while (queue.length > 0) {\n        const size = queue.length;\n        \n        for (let i = 0; i < size; i++) {\n            const [row, col, obstacles] = queue.shift();\n            \n            // Check if reached destination\n            if (row === m - 1 && col === n - 1) {\n                return steps;\n            }\n            \n            // Explore all four directions\n            for (const [dr, dc] of directions) {\n                const newRow = row + dr;\n                const newCol = col + dc;\n                \n                // Check bounds\n                if (newRow < 0 || newRow >= m || newCol < 0 || newCol >= n) {\n                    continue;\n                }\n                \n                let newObstacles = obstacles;\n                \n                // If new cell is obstacle, increment obstacle count\n                if (grid[newRow][newCol] === 1) {\n                    newObstacles++;\n                }\n                \n                // Check if we can eliminate this obstacle and haven't visited this state\n                if (newObstacles <= k && !visited[newRow][newCol][newObstacles]) {\n                    visited[newRow][newCol][newObstacles] = true;\n                    queue.push([newRow, newCol, newObstacles]);\n                }\n            }\n        }\n        \n        steps++;\n    }\n    \n    return -1; // No path found\n};\n    ",
      "compare_result": "1111111111111111111111111111111111111111111111111111111",
      "title_slug": "shortest-path-in-a-grid-with-obstacles-elimination",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 806,
      "statusCode": 10,
      "totalTestcases": 55,
      "question": {
        "title": "Shortest Path in a Grid with Obstacles Elimination",
        "titleSlug": "shortest-path-in-a-grid-with-obstacles-elimination",
        "questionId": "1414"
      },
      "status_code": 10,
      "passedTestCaseCnt": 55,
      "totalTestCaseCnt": 55
    },
    {
      "id": 1776874735,
      "question_id": 1414,
      "lang": "java",
      "lang_name": "Java",
      "time": "11minutes",
      "timestamp": 1758361528,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "26 ms",
      "url": "/submissions/detail/1776874735/",
      "is_pending": "Not Pending",
      "title": "Shortest Path in a Grid with Obstacles Elimination",
      "memory": "46.3 MB",
      "code": "import java.util.*;\n\nclass Solution {\n    public int shortestPath(int[][] grid, int k) {\n        int m = grid.length;\n        int n = grid[0].length;\n        \n        // State: [row, col, obstacles_eliminated]\n        Queue<int[]> queue = new LinkedList<>();\n        boolean[][][] visited = new boolean[m][n][k + 1];\n        \n        queue.offer(new int[]{0, 0, 0});\n        visited[0][0][0] = true;\n        \n        int steps = 0;\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n        \n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            \n            for (int i = 0; i < size; i++) {\n                int[] current = queue.poll();\n                int row = current[0];\n                int col = current[1];\n                int obstacles = current[2];\n                \n                // Check if reached destination\n                if (row == m - 1 && col == n - 1) {\n                    return steps;\n                }\n                \n                // Explore all four directions\n                for (int[] dir : directions) {\n                    int newRow = row + dir[0];\n                    int newCol = col + dir[1];\n                    \n                    // Check bounds\n                    if (newRow < 0 || newRow >= m || newCol < 0 || newCol >= n) {\n                        continue;\n                    }\n                    \n                    int newObstacles = obstacles;\n                    \n                    // If new cell is obstacle, increment obstacle count\n                    if (grid[newRow][newCol] == 1) {\n                        newObstacles++;\n                    }\n                    \n                    // Check if we can eliminate this obstacle and haven't visited this state\n                    if (newObstacles <= k && !visited[newRow][newCol][newObstacles]) {\n                        visited[newRow][newCol][newObstacles] = true;\n                        queue.offer(new int[]{newRow, newCol, newObstacles});\n                    }\n                }\n            }\n            \n            steps++;\n        }\n        \n        return -1; // No path found\n    }\n}\n    ",
      "compare_result": "1111111111111111111111111111111111111111111111111111111",
      "title_slug": "shortest-path-in-a-grid-with-obstacles-elimination",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 805,
      "statusCode": 10,
      "totalTestcases": 55,
      "question": {
        "title": "Shortest Path in a Grid with Obstacles Elimination",
        "titleSlug": "shortest-path-in-a-grid-with-obstacles-elimination",
        "questionId": "1414"
      },
      "status_code": 10,
      "passedTestCaseCnt": 55,
      "totalTestCaseCnt": 55
    },
    {
      "id": 1776873758,
      "question_id": 297,
      "lang": "python",
      "lang_name": "Python",
      "time": "13minutes",
      "timestamp": 1758361448,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "82 ms",
      "url": "/submissions/detail/1776873758/",
      "is_pending": "Not Pending",
      "title": "Serialize and Deserialize Binary Tree",
      "memory": "23.2 MB",
      "code": "class Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        def preorder(node):\n            if not node:\n                return \"null\"\n            return str(node.val) + \",\" + preorder(node.left) + \",\" + preorder(node.right)\n        \n        return preorder(root)\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        def build_tree():\n            val = next(vals)\n            if val == \"null\":\n                return None\n            node = TreeNode(int(val))\n            node.left = build_tree()\n            node.right = build_tree()\n            return node\n        \n        vals = iter(data.split(\",\"))\n        return build_tree()\n\n# Your Codec object will be instantiated and called as such:\n# ser = Codec()\n# deser = Codec()\n# ans = deser.deserialize(ser.serialize(root))                                                         \n    ",
      "compare_result": "11111111111111111111111111111111111111111111111111111",
      "title_slug": "serialize-and-deserialize-binary-tree",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 804,
      "statusCode": 10,
      "totalTestcases": 53,
      "question": {
        "title": "Serialize and Deserialize Binary Tree",
        "titleSlug": "serialize-and-deserialize-binary-tree",
        "questionId": "297"
      },
      "status_code": 10,
      "passedTestCaseCnt": 53,
      "totalTestCaseCnt": 53
    },
    {
      "id": 1776873450,
      "question_id": 297,
      "lang": "php",
      "lang_name": "PHP",
      "time": "13minutes",
      "timestamp": 1758361424,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "10 ms",
      "url": "/submissions/detail/1776873450/",
      "is_pending": "Not Pending",
      "title": "Serialize and Deserialize Binary Tree",
      "memory": "25.3 MB",
      "code": "class Codec {\n    function __construct() {\n        \n    }\n  \n    /**\n     * @param TreeNode $root\n     * @return String\n     */\n    function serialize($root) {\n        $result = [];\n        $this->serializeHelper($root, $result);\n        return implode(',', $result);\n    }\n    \n    private function serializeHelper($node, &$result) {\n        if ($node === null) {\n            $result[] = 'null';\n            return;\n        }\n        \n        $result[] = (string)$node->val;\n        $this->serializeHelper($node->left, $result);\n        $this->serializeHelper($node->right, $result);\n    }\n  \n    /**\n     * @param String $data\n     * @return TreeNode\n     */\n    function deserialize($data) {\n        $values = explode(',', $data);\n        $index = 0;\n        return $this->deserializeHelper($values, $index);\n    }\n    \n    private function deserializeHelper($values, &$index) {\n        if ($index >= count($values) || $values[$index] === 'null') {\n            $index++;\n            return null;\n        }\n        \n        $node = new TreeNode((int)$values[$index]);\n        $index++;\n        $node->left = $this->deserializeHelper($values, $index);\n        $node->right = $this->deserializeHelper($values, $index);\n        \n        return $node;\n    }\n}\n\n/**\n * Your Codec object will be instantiated and called as such:\n * $ser = Codec();\n * $deser = Codec();\n * $data = $ser->serialize($root);\n * $ans = $deser->deserialize($data);\n */\n    ",
      "compare_result": "11111111111111111111111111111111111111111111111111111",
      "title_slug": "serialize-and-deserialize-binary-tree",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 803,
      "statusCode": 10,
      "totalTestcases": 53,
      "question": {
        "title": "Serialize and Deserialize Binary Tree",
        "titleSlug": "serialize-and-deserialize-binary-tree",
        "questionId": "297"
      },
      "status_code": 10,
      "passedTestCaseCnt": 53,
      "totalTestCaseCnt": 53
    },
    {
      "id": 1776873206,
      "question_id": 297,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "13minutes",
      "timestamp": 1758361405,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "82 ms",
      "url": "/submissions/detail/1776873206/",
      "is_pending": "Not Pending",
      "title": "Serialize and Deserialize Binary Tree",
      "memory": "68.1 MB",
      "code": "/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function(root) {\n    const result = [];\n    serializeHelper(root, result);\n    return result.join(',');\n};\n\nfunction serializeHelper(node, result) {\n    if (node === null) {\n        result.push('null');\n        return;\n    }\n    \n    result.push(node.val.toString());\n    serializeHelper(node.left, result);\n    serializeHelper(node.right, result);\n}\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n    const values = data.split(',');\n    let index = 0;\n    \n    return deserializeHelper(values);\n    \n    function deserializeHelper(values) {\n        if (index >= values.length || values[index] === 'null') {\n            index++;\n            return null;\n        }\n        \n        const node = new TreeNode(parseInt(values[index]));\n        index++;\n        node.left = deserializeHelper(values);\n        node.right = deserializeHelper(values);\n        \n        return node;\n    }\n};\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */\n    ",
      "compare_result": "11111111111111111111111111111111111111111111111111111",
      "title_slug": "serialize-and-deserialize-binary-tree",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 802,
      "statusCode": 10,
      "totalTestcases": 53,
      "question": {
        "title": "Serialize and Deserialize Binary Tree",
        "titleSlug": "serialize-and-deserialize-binary-tree",
        "questionId": "297"
      },
      "status_code": 10,
      "passedTestCaseCnt": 53,
      "totalTestCaseCnt": 53
    },
    {
      "id": 1776872918,
      "question_id": 297,
      "lang": "java",
      "lang_name": "Java",
      "time": "14minutes",
      "timestamp": 1758361383,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "9 ms",
      "url": "/submissions/detail/1776872918/",
      "is_pending": "Not Pending",
      "title": "Serialize and Deserialize Binary Tree",
      "memory": "46.5 MB",
      "code": "import java.util.*;\n\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        StringBuilder sb = new StringBuilder();\n        serializeHelper(root, sb);\n        return sb.toString();\n    }\n    \n    private void serializeHelper(TreeNode node, StringBuilder sb) {\n        if (node == null) {\n            sb.append(\"null,\");\n            return;\n        }\n        \n        sb.append(node.val).append(\",\");\n        serializeHelper(node.left, sb);\n        serializeHelper(node.right, sb);\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        String[] values = data.split(\",\");\n        Queue<String> queue = new LinkedList<>(Arrays.asList(values));\n        return deserializeHelper(queue);\n    }\n    \n    private TreeNode deserializeHelper(Queue<String> queue) {\n        String value = queue.poll();\n        \n        if (value.equals(\"null\")) {\n            return null;\n        }\n        \n        TreeNode node = new TreeNode(Integer.parseInt(value));\n        node.left = deserializeHelper(queue);\n        node.right = deserializeHelper(queue);\n        \n        return node;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser = new Codec();\n// Codec deser = new Codec();\n// TreeNode ans = deser.deserialize(ser.serialize(root));\n    ",
      "compare_result": "11111111111111111111111111111111111111111111111111111",
      "title_slug": "serialize-and-deserialize-binary-tree",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 801,
      "statusCode": 10,
      "totalTestcases": 53,
      "question": {
        "title": "Serialize and Deserialize Binary Tree",
        "titleSlug": "serialize-and-deserialize-binary-tree",
        "questionId": "297"
      },
      "status_code": 10,
      "passedTestCaseCnt": 53,
      "totalTestCaseCnt": 53
    }
  ]
}