{
  "submissions_dump": [
    {
      "id": 1776233629,
      "question_id": 1343,
      "lang": "python",
      "lang_name": "Python",
      "time": "0minutes",
      "timestamp": 1758298674,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "860 ms",
      "url": "/submissions/detail/1776233629/",
      "is_pending": "Not Pending",
      "title": "Dice Roll Simulation",
      "memory": "20.4 MB",
      "code": "class Solution(object):\n    def dieSimulator(self, n, rollMax):\n        \"\"\"\n        :type n: int\n        :type rollMax: List[int]\n        :rtype: int\n        \"\"\"\n        MOD = 10**9 + 7\n        \n        # dp[i][j][k] = number of sequences of length i ending with j consecutive rolls of face k\n        dp = [[[0] * 16 for _ in range(6)] for _ in range(n + 1)]\n        \n        # Initialize: sequences of length 1\n        for face in range(6):\n            dp[1][face][1] = 1\n        \n        for length in range(2, n + 1):\n            for face in range(6):\n                for consecutive in range(1, rollMax[face] + 1):\n                    if consecutive == 1:\n                        # Can end with 1 consecutive roll of this face\n                        for prev_face in range(6):\n                            if prev_face != face:\n                                for prev_consecutive in range(1, rollMax[prev_face] + 1):\n                                    dp[length][face][1] = (dp[length][face][1] + dp[length - 1][prev_face][prev_consecutive]) % MOD\n                    else:\n                        # Can extend previous consecutive rolls of the same face\n                        dp[length][face][consecutive] = dp[length - 1][face][consecutive - 1]\n        \n        # Sum all valid sequences of length n\n        result = 0\n        for face in range(6):\n            for consecutive in range(1, rollMax[face] + 1):\n                result = (result + dp[n][face][consecutive]) % MOD\n        \n        return result\n    ",
      "compare_result": "11111111111111111111111111111111",
      "title_slug": "dice-roll-simulation",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 800,
      "statusCode": 10,
      "totalTestcases": 32,
      "question": {
        "title": "Dice Roll Simulation",
        "titleSlug": "dice-roll-simulation",
        "questionId": "1343"
      },
      "status_code": 10,
      "passedTestCaseCnt": 32,
      "totalTestCaseCnt": 32
    },
    {
      "id": 1776233177,
      "question_id": 1343,
      "lang": "php",
      "lang_name": "PHP",
      "time": "1minute",
      "timestamp": 1758298647,
      "status": 11,
      "status_display": "Wrong Answer",
      "runtime": "N/A",
      "url": "/submissions/detail/1776233177/",
      "is_pending": "Not Pending",
      "title": "Dice Roll Simulation",
      "memory": "N/A",
      "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[] $rollMax\n     * @return Integer\n     */\n    function dieSimulator($n, $rollMax) {\n        $mod = 1000000007;\n        \n        // dp[i][j][k] = number of sequences of length i ending with j consecutive k's\n        $dp = array_fill(0, $n + 1, array_fill(0, 7, array_fill(0, 16, 0)));\n        \n        // Base case: empty sequence\n        for ($j = 0; $j < 6; $j++) {\n            $dp[0][$j][0] = 1;\n        }\n        \n        for ($i = 1; $i <= $n; $i++) {\n            for ($j = 0; $j < 6; $j++) {\n                for ($k = 1; $k <= $rollMax[$j]; $k++) {\n                    // Continue the same number\n                    $dp[$i][$j][$k] = $dp[$i - 1][$j][$k - 1];\n                }\n                \n                // Start with a different number\n                for ($prev = 0; $prev < 6; $prev++) {\n                    if ($prev !== $j) {\n                        for ($prevK = 0; $prevK <= $rollMax[$prev]; $prevK++) {\n                            $dp[$i][$j][1] = ($dp[$i][$j][1] + $dp[$i - 1][$prev][$prevK]) % $mod;\n                        }\n                    }\n                }\n            }\n        }\n        \n        $result = 0;\n        for ($j = 0; $j < 6; $j++) {\n            for ($k = 1; $k <= $rollMax[$j]; $k++) {\n                $result = ($result + $dp[$n][$j][$k]) % $mod;\n            }\n        }\n        \n        return $result;\n    }\n}\n    ",
      "compare_result": "00000000000000000000000000000000",
      "title_slug": "dice-roll-simulation",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 799,
      "statusCode": 11,
      "totalTestcases": 32,
      "question": {
        "title": "Dice Roll Simulation",
        "titleSlug": "dice-roll-simulation",
        "questionId": "1343"
      },
      "status_code": 11,
      "passedTestCaseCnt": 0,
      "totalTestCaseCnt": 32
    },
    {
      "id": 1776232362,
      "question_id": 1343,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "2minutes",
      "timestamp": 1758298598,
      "status": 11,
      "status_display": "Wrong Answer",
      "runtime": "N/A",
      "url": "/submissions/detail/1776232362/",
      "is_pending": "Not Pending",
      "title": "Dice Roll Simulation",
      "memory": "N/A",
      "code": "\n/**\n * @param {number} n\n * @param {number[]} rollMax\n * @return {number}\n */\nvar dieSimulator = function(n, rollMax) {\n    const MOD = 1000000007;\n    \n    // dp[i][j][k] = number of sequences of length i ending with j consecutive k's\n    const dp = Array(n + 1).fill().map(() => \n        Array(7).fill().map(() => Array(16).fill(0))\n    );\n    \n    // Base case: empty sequence\n    for (let j = 1; j <= 6; j++) {\n        dp[0][j][0] = 1;\n    }\n    \n    for (let i = 1; i <= n; i++) {\n        for (let j = 1; j <= 6; j++) {\n            for (let k = 1; k <= rollMax[j - 1]; k++) {\n                // Add sequences ending with k consecutive j's\n                dp[i][j][k] = dp[i - 1][j][k - 1];\n            }\n            \n            // Add sequences ending with 1 consecutive j (from different previous numbers)\n            for (let prev = 1; prev <= 6; prev++) {\n                if (prev !== j) {\n                    for (let k = 0; k <= rollMax[prev - 1]; k++) {\n                        dp[i][j][1] = (dp[i][j][1] + dp[i - 1][prev][k]) % MOD;\n                    }\n                }\n            }\n        }\n    }\n    \n    let result = 0;\n    for (let j = 1; j <= 6; j++) {\n        for (let k = 1; k <= rollMax[j - 1]; k++) {\n            result = (result + dp[n][j][k]) % MOD;\n        }\n    }\n    \n    return result;\n};\n    ",
      "compare_result": "00000000000000000000000000000000",
      "title_slug": "dice-roll-simulation",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 798,
      "statusCode": 11,
      "totalTestcases": 32,
      "question": {
        "title": "Dice Roll Simulation",
        "titleSlug": "dice-roll-simulation",
        "questionId": "1343"
      },
      "status_code": 11,
      "passedTestCaseCnt": 0,
      "totalTestCaseCnt": 32
    },
    {
      "id": 1776231087,
      "question_id": 1343,
      "lang": "java",
      "lang_name": "Java",
      "time": "3minutes",
      "timestamp": 1758298518,
      "status": 11,
      "status_display": "Wrong Answer",
      "runtime": "N/A",
      "url": "/submissions/detail/1776231087/",
      "is_pending": "Not Pending",
      "title": "Dice Roll Simulation",
      "memory": "N/A",
      "code": "\nclass Solution {\n    private static final int MOD = 1000000007;\n    \n    public int dieSimulator(int n, int[] rollMax) {\n        // dp[i][j][k] = number of sequences of length i ending with j consecutive k's\n        int[][][] dp = new int[n + 1][7][16];\n        \n        // Base case: empty sequence\n        for (int j = 1; j <= 6; j++) {\n            dp[0][j][0] = 1;\n        }\n        \n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= 6; j++) {\n                for (int k = 1; k <= rollMax[j - 1]; k++) {\n                    // Add sequences ending with k consecutive j's\n                    dp[i][j][k] = dp[i - 1][j][k - 1];\n                }\n                \n                // Add sequences ending with 1 consecutive j (from different previous numbers)\n                for (int prev = 1; prev <= 6; prev++) {\n                    if (prev != j) {\n                        for (int k = 0; k <= rollMax[prev - 1]; k++) {\n                            dp[i][j][1] = (dp[i][j][1] + dp[i - 1][prev][k]) % MOD;\n                        }\n                    }\n                }\n            }\n        }\n        \n        int result = 0;\n        for (int j = 1; j <= 6; j++) {\n            for (int k = 1; k <= rollMax[j - 1]; k++) {\n                result = (result + dp[n][j][k]) % MOD;\n            }\n        }\n        \n        return result;\n    }\n}\n    ",
      "compare_result": "00000000000000000000000000000000",
      "title_slug": "dice-roll-simulation",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 797,
      "statusCode": 11,
      "totalTestcases": 32,
      "question": {
        "title": "Dice Roll Simulation",
        "titleSlug": "dice-roll-simulation",
        "questionId": "1343"
      },
      "status_code": 11,
      "passedTestCaseCnt": 0,
      "totalTestCaseCnt": 32
    },
    {
      "id": 1776230431,
      "question_id": 1740,
      "lang": "python",
      "lang_name": "Python",
      "time": "4minutes",
      "timestamp": 1758298476,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "2104 ms",
      "url": "/submissions/detail/1776230431/",
      "is_pending": "Not Pending",
      "title": "Count Subtrees With Max Distance Between Cities",
      "memory": "13.8 MB",
      "code": "\nclass Solution(object):\n    def countSubgraphsForEachDiameter(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        # Build adjacency list\n        graph = [[] for _ in range(n + 1)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        result = [0] * (n - 1)\n        \n        # Try all possible subsets of cities\n        for mask in range(1, 1 << n):\n            cities = []\n            for i in range(n):\n                if mask & (1 << i):\n                    cities.append(i + 1)\n            \n            if len(cities) < 2:\n                continue\n            \n            # Check if this subset forms a connected subtree\n            if self.isConnectedSubtree(cities, graph):\n                diameter = self.getDiameter(cities, graph)\n                if diameter > 0:\n                    result[diameter - 1] += 1\n        \n        return result\n    \n    def isConnectedSubtree(self, cities, graph):\n        \"\"\"\n        Check if the given cities form a connected subtree\n        \"\"\"\n        if not cities:\n            return False\n        \n        # BFS to check connectivity\n        visited = set()\n        queue = [cities[0]]\n        visited.add(cities[0])\n        \n        while queue:\n            node = queue.pop(0)\n            for neighbor in graph[node]:\n                if neighbor in cities and neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n        \n        return len(visited) == len(cities)\n    \n    def getDiameter(self, cities, graph):\n        \"\"\"\n        Get the diameter of the subtree formed by the given cities\n        \"\"\"\n        if len(cities) < 2:\n            return 0\n        \n        max_diameter = 0\n        \n        # Try all pairs of cities as endpoints\n        for i in range(len(cities)):\n            for j in range(i + 1, len(cities)):\n                start, end = cities[i], cities[j]\n                distance = self.bfsDistance(start, end, cities, graph)\n                max_diameter = max(max_diameter, distance)\n        \n        return max_diameter\n    \n    def bfsDistance(self, start, end, cities, graph):\n        \"\"\"\n        Find shortest distance between start and end in the subtree\n        \"\"\"\n        if start == end:\n            return 0\n        \n        visited = set()\n        queue = [(start, 0)]\n        visited.add(start)\n        \n        while queue:\n            node, dist = queue.pop(0)\n            for neighbor in graph[node]:\n                if neighbor in cities and neighbor not in visited:\n                    if neighbor == end:\n                        return dist + 1\n                    visited.add(neighbor)\n                    queue.append((neighbor, dist + 1))\n        \n        return 0\n    ",
      "compare_result": "1111111111111111111111111111111",
      "title_slug": "count-subtrees-with-max-distance-between-cities",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 796,
      "statusCode": 10,
      "totalTestcases": 31,
      "question": {
        "title": "Count Subtrees With Max Distance Between Cities",
        "titleSlug": "count-subtrees-with-max-distance-between-cities",
        "questionId": "1740"
      },
      "status_code": 10,
      "passedTestCaseCnt": 31,
      "totalTestCaseCnt": 31
    },
    {
      "id": 1776230182,
      "question_id": 1740,
      "lang": "php",
      "lang_name": "PHP",
      "time": "4minutes",
      "timestamp": 1758298461,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "504 ms",
      "url": "/submissions/detail/1776230182/",
      "is_pending": "Not Pending",
      "title": "Count Subtrees With Max Distance Between Cities",
      "memory": "20.7 MB",
      "code": "\nclass Solution {\n\n    /**\n     * @param Integer $n\n     * @param Integer[][] $edges\n     * @return Integer[]\n     */\n    function countSubgraphsForEachDiameter($n, $edges) {\n        // Build adjacency list\n        $graph = array_fill(0, $n, []);\n        foreach ($edges as $edge) {\n            $u = $edge[0] - 1; // Convert to 0-indexed\n            $v = $edge[1] - 1;\n            $graph[$u][] = $v;\n            $graph[$v][] = $u;\n        }\n        \n        $result = array_fill(0, $n - 1, 0);\n        \n        // Try all possible subtrees using bitmask\n        for ($mask = 1; $mask < (1 << $n); $mask++) {\n            $nodes = [];\n            for ($i = 0; $i < $n; $i++) {\n                if ($mask & (1 << $i)) {\n                    $nodes[] = $i;\n                }\n            }\n            \n            if (count($nodes) < 2) {\n                continue;\n            }\n            \n            // Check if this is a valid connected subtree\n            if ($this->isConnectedSubtree($graph, $nodes)) {\n                $diameter = $this->getDiameter($graph, $nodes);\n                if ($diameter > 0 && $diameter <= $n - 1) {\n                    $result[$diameter - 1]++;\n                }\n            }\n        }\n        \n        return $result;\n    }\n    \n    private function isConnectedSubtree($graph, $nodes) {\n        if (empty($nodes)) {\n            return false;\n        }\n        \n        $visited = array_fill(0, count($graph), false);\n        $start = $nodes[0];\n        $queue = [$start];\n        $visited[$start] = true;\n        $count = 1;\n        \n        while (!empty($queue)) {\n            $current = array_shift($queue);\n            \n            foreach ($graph[$current] as $neighbor) {\n                if (in_array($neighbor, $nodes) && !$visited[$neighbor]) {\n                    $visited[$neighbor] = true;\n                    $queue[] = $neighbor;\n                    $count++;\n                }\n            }\n        }\n        \n        return $count === count($nodes);\n    }\n    \n    private function getDiameter($graph, $nodes) {\n        if (count($nodes) < 2) {\n            return 0;\n        }\n        \n        $maxDist = 0;\n        \n        // Try BFS from each node to find the maximum distance\n        foreach ($nodes as $start) {\n            $distances = $this->bfs($graph, $start, $nodes);\n            $maxDist = max($maxDist, max($distances));\n        }\n        \n        return $maxDist;\n    }\n    \n    private function bfs($graph, $start, $nodes) {\n        $distances = array_fill(0, count($graph), -1);\n        $queue = [$start];\n        $distances[$start] = 0;\n        \n        while (!empty($queue)) {\n            $current = array_shift($queue);\n            \n            foreach ($graph[$current] as $neighbor) {\n                if (in_array($neighbor, $nodes) && $distances[$neighbor] === -1) {\n                    $distances[$neighbor] = $distances[$current] + 1;\n                    $queue[] = $neighbor;\n                }\n            }\n        }\n        \n        return $distances;\n    }\n}\n    ",
      "compare_result": "1111111111111111111111111111111",
      "title_slug": "count-subtrees-with-max-distance-between-cities",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 795,
      "statusCode": 10,
      "totalTestcases": 31,
      "question": {
        "title": "Count Subtrees With Max Distance Between Cities",
        "titleSlug": "count-subtrees-with-max-distance-between-cities",
        "questionId": "1740"
      },
      "status_code": 10,
      "passedTestCaseCnt": 31,
      "totalTestCaseCnt": 31
    },
    {
      "id": 1776229799,
      "question_id": 1740,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "4minutes",
      "timestamp": 1758298438,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "388 ms",
      "url": "/submissions/detail/1776229799/",
      "is_pending": "Not Pending",
      "title": "Count Subtrees With Max Distance Between Cities",
      "memory": "69.9 MB",
      "code": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @return {number[]}\n */\nvar countSubgraphsForEachDiameter = function(n, edges) {\n    // Build adjacency list\n    const graph = Array(n + 1).fill().map(() => []);\n    \n    for (const [u, v] of edges) {\n        graph[u].push(v);\n        graph[v].push(u);\n    }\n    \n    const result = Array(n - 1).fill(0);\n    \n    // Try all possible subsets of cities (2^n possibilities)\n    for (let mask = 1; mask < (1 << n); mask++) {\n        const cities = [];\n        for (let i = 1; i <= n; i++) {\n            if (mask & (1 << (i - 1))) {\n                cities.push(i);\n            }\n        }\n        \n        if (cities.length < 2) continue;\n        \n        // Check if this subset forms a valid subtree\n        if (isValidSubtree(cities, graph)) {\n            const maxDistance = getMaxDistance(cities, graph);\n            if (maxDistance > 0 && maxDistance <= n - 1) {\n                result[maxDistance - 1]++;\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValidSubtree(cities, graph) {\n    // Check if all cities in the subset are connected\n    const citySet = new Set(cities);\n    const visited = new Set();\n    const queue = [cities[0]];\n    \n    visited.add(cities[0]);\n    \n    while (queue.length > 0) {\n        const current = queue.shift();\n        for (const neighbor of graph[current]) {\n            if (citySet.has(neighbor) && !visited.has(neighbor)) {\n                visited.add(neighbor);\n                queue.push(neighbor);\n            }\n        }\n    }\n    \n    return visited.size === cities.length;\n}\n\nfunction getMaxDistance(cities, graph) {\n    let maxDistance = 0;\n    const citySet = new Set(cities);\n    \n    // For each city, find the maximum distance to any other city in the subset\n    for (const start of cities) {\n        const distance = bfs(start, citySet, graph);\n        maxDistance = Math.max(maxDistance, distance);\n    }\n    \n    return maxDistance;\n}\n\nfunction bfs(start, citySet, graph) {\n    const queue = [start];\n    const distance = { [start]: 0 };\n    \n    let maxDist = 0;\n    \n    while (queue.length > 0) {\n        const current = queue.shift();\n        const currentDist = distance[current];\n        \n        for (const neighbor of graph[current]) {\n            if (citySet.has(neighbor) && !(neighbor in distance)) {\n                distance[neighbor] = currentDist + 1;\n                queue.push(neighbor);\n                maxDist = Math.max(maxDist, currentDist + 1);\n            }\n        }\n    }\n    \n    return maxDist;\n}\n    ",
      "compare_result": "1111111111111111111111111111111",
      "title_slug": "count-subtrees-with-max-distance-between-cities",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 794,
      "statusCode": 10,
      "totalTestcases": 31,
      "question": {
        "title": "Count Subtrees With Max Distance Between Cities",
        "titleSlug": "count-subtrees-with-max-distance-between-cities",
        "questionId": "1740"
      },
      "status_code": 10,
      "passedTestCaseCnt": 31,
      "totalTestCaseCnt": 31
    },
    {
      "id": 1776229477,
      "question_id": 1740,
      "lang": "java",
      "lang_name": "Java",
      "time": "5minutes",
      "timestamp": 1758298420,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "291 ms",
      "url": "/submissions/detail/1776229477/",
      "is_pending": "Not Pending",
      "title": "Count Subtrees With Max Distance Between Cities",
      "memory": "45.2 MB",
      "code": "import java.util.*;\n\nclass Solution {\n    public int[] countSubgraphsForEachDiameter(int n, int[][] edges) {\n        // Build adjacency list\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int[] edge : edges) {\n            graph.get(edge[0]).add(edge[1]);\n            graph.get(edge[1]).add(edge[0]);\n        }\n        \n        int[] result = new int[n - 1];\n        \n        // Try all possible subsets of cities (2^n possibilities)\n        for (int mask = 1; mask < (1 << n); mask++) {\n            List<Integer> cities = new ArrayList<>();\n            for (int i = 1; i <= n; i++) {\n                if ((mask & (1 << (i - 1))) != 0) {\n                    cities.add(i);\n                }\n            }\n            \n            if (cities.size() < 2) continue;\n            \n            // Check if this subset forms a valid subtree\n            if (isValidSubtree(cities, graph)) {\n                int maxDistance = getMaxDistance(cities, graph);\n                if (maxDistance > 0 && maxDistance <= n - 1) {\n                    result[maxDistance - 1]++;\n                }\n            }\n        }\n        \n        return result;\n    }\n    \n    private boolean isValidSubtree(List<Integer> cities, List<List<Integer>> graph) {\n        // Check if all cities in the subset are connected\n        Set<Integer> citySet = new HashSet<>(cities);\n        Set<Integer> visited = new HashSet<>();\n        Queue<Integer> queue = new LinkedList<>();\n        \n        queue.offer(cities.get(0));\n        visited.add(cities.get(0));\n        \n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            for (int neighbor : graph.get(current)) {\n                if (citySet.contains(neighbor) && !visited.contains(neighbor)) {\n                    visited.add(neighbor);\n                    queue.offer(neighbor);\n                }\n            }\n        }\n        \n        return visited.size() == cities.size();\n    }\n    \n    private int getMaxDistance(List<Integer> cities, List<List<Integer>> graph) {\n        int maxDistance = 0;\n        Set<Integer> citySet = new HashSet<>(cities);\n        \n        // For each city, find the maximum distance to any other city in the subset\n        for (int start : cities) {\n            int distance = bfs(start, citySet, graph);\n            maxDistance = Math.max(maxDistance, distance);\n        }\n        \n        return maxDistance;\n    }\n    \n    private int bfs(int start, Set<Integer> citySet, List<List<Integer>> graph) {\n        Queue<Integer> queue = new LinkedList<>();\n        Map<Integer, Integer> distance = new HashMap<>();\n        \n        queue.offer(start);\n        distance.put(start, 0);\n        \n        int maxDist = 0;\n        \n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            int currentDist = distance.get(current);\n            \n            for (int neighbor : graph.get(current)) {\n                if (citySet.contains(neighbor) && !distance.containsKey(neighbor)) {\n                    distance.put(neighbor, currentDist + 1);\n                    queue.offer(neighbor);\n                    maxDist = Math.max(maxDist, currentDist + 1);\n                }\n            }\n        }\n        \n        return maxDist;\n    }\n}\n    ",
      "compare_result": "1111111111111111111111111111111",
      "title_slug": "count-subtrees-with-max-distance-between-cities",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 793,
      "statusCode": 10,
      "totalTestcases": 31,
      "question": {
        "title": "Count Subtrees With Max Distance Between Cities",
        "titleSlug": "count-subtrees-with-max-distance-between-cities",
        "questionId": "1740"
      },
      "status_code": 10,
      "passedTestCaseCnt": 31,
      "totalTestCaseCnt": 31
    },
    {
      "id": 1776228520,
      "question_id": 76,
      "lang": "python",
      "lang_name": "Python",
      "time": "6minutes",
      "timestamp": 1758298359,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "90 ms",
      "url": "/submissions/detail/1776228520/",
      "is_pending": "Not Pending",
      "title": "Minimum Window Substring",
      "memory": "12.7 MB",
      "code": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        if not s or not t:\n            return \"\"\n        \n        # Count characters in t\n        dict_t = {}\n        for char in t:\n            dict_t[char] = dict_t.get(char, 0) + 1\n        \n        required = len(dict_t)\n        left = right = 0\n        formed = 0\n        \n        # Dictionary to keep track of characters in current window\n        window_counts = {}\n        \n        # Result variables\n        ans = float('inf'), None, None\n        \n        while right < len(s):\n            # Add character from right to window\n            char = s[right]\n            window_counts[char] = window_counts.get(char, 0) + 1\n            \n            # If frequency of current character matches desired count\n            if char in dict_t and window_counts[char] == dict_t[char]:\n                formed += 1\n            \n            # Try to contract window from left\n            while left <= right and formed == required:\n                char = s[left]\n                \n                # Save the smallest window until now\n                if right - left + 1 < ans[0]:\n                    ans = (right - left + 1, left, right)\n                \n                # Remove character from left of window\n                window_counts[char] -= 1\n                if char in dict_t and window_counts[char] < dict_t[char]:\n                    formed -= 1\n                \n                left += 1\n            \n            right += 1\n        \n        return \"\" if ans[0] == float('inf') else s[ans[1]:ans[2] + 1]\n    ",
      "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "minimum-window-substring",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 792,
      "statusCode": 10,
      "totalTestcases": 268,
      "question": {
        "title": "Minimum Window Substring",
        "titleSlug": "minimum-window-substring",
        "questionId": "76"
      },
      "status_code": 10,
      "passedTestCaseCnt": 268,
      "totalTestCaseCnt": 268
    },
    {
      "id": 1776228178,
      "question_id": 76,
      "lang": "php",
      "lang_name": "PHP",
      "time": "6minutes",
      "timestamp": 1758298337,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "28 ms",
      "url": "/submissions/detail/1776228178/",
      "is_pending": "Not Pending",
      "title": "Minimum Window Substring",
      "memory": "20.9 MB",
      "code": "\nclass Solution {\n\n    /**\n     * @param String $s\n     * @param String $t\n     * @return String\n     */\n    function minWindow($s, $t) {\n        $sLen = strlen($s);\n        $tLen = strlen($t);\n        \n        if ($sLen < $tLen) {\n            return \"\";\n        }\n        \n        // Count characters in t\n        $tCount = [];\n        for ($i = 0; $i < $tLen; $i++) {\n            $char = $t[$i];\n            $tCount[$char] = ($tCount[$char] ?? 0) + 1;\n        }\n        \n        $left = 0;\n        $right = 0;\n        $windowCount = [];\n        $formed = 0;\n        $required = count($tCount);\n        $minLen = PHP_INT_MAX;\n        $minLeft = 0;\n        \n        while ($right < $sLen) {\n            // Add character from right\n            $char = $s[$right];\n            $windowCount[$char] = ($windowCount[$char] ?? 0) + 1;\n            \n            // Check if this character completes a requirement\n            if (isset($tCount[$char]) && $windowCount[$char] === $tCount[$char]) {\n                $formed++;\n            }\n            \n            // Try to contract window from left\n            while ($left <= $right && $formed === $required) {\n                $char = $s[$left];\n                \n                // Update minimum window\n                if ($right - $left + 1 < $minLen) {\n                    $minLen = $right - $left + 1;\n                    $minLeft = $left;\n                }\n                \n                // Remove character from left\n                $windowCount[$char]--;\n                if (isset($tCount[$char]) && $windowCount[$char] < $tCount[$char]) {\n                    $formed--;\n                }\n                \n                $left++;\n            }\n            \n            $right++;\n        }\n        \n        return $minLen === PHP_INT_MAX ? \"\" : substr($s, $minLeft, $minLen);\n    }\n}\n    ",
      "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "minimum-window-substring",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 791,
      "statusCode": 10,
      "totalTestcases": 268,
      "question": {
        "title": "Minimum Window Substring",
        "titleSlug": "minimum-window-substring",
        "questionId": "76"
      },
      "status_code": 10,
      "passedTestCaseCnt": 268,
      "totalTestCaseCnt": 268
    },
    {
      "id": 1776227800,
      "question_id": 76,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "6minutes",
      "timestamp": 1758298314,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "26 ms",
      "url": "/submissions/detail/1776227800/",
      "is_pending": "Not Pending",
      "title": "Minimum Window Substring",
      "memory": "56.4 MB",
      "code": "/**\n * @param {string} s\n * @param {string} t\n * @return {string}\n */\nvar minWindow = function(s, t) {\n    if (!s || !t || s.length < t.length) {\n        return \"\";\n    }\n    \n    const targetCount = {};\n    const windowCount = {};\n    \n    // Count characters in target string t\n    for (const char of t) {\n        targetCount[char] = (targetCount[char] || 0) + 1;\n    }\n    \n    let left = 0, right = 0;\n    let minLen = Infinity;\n    let minStart = 0;\n    const required = Object.keys(targetCount).length;\n    let formed = 0;\n    \n    while (right < s.length) {\n        const rightChar = s[right];\n        windowCount[rightChar] = (windowCount[rightChar] || 0) + 1;\n        \n        // Check if current character satisfies the requirement\n        if (targetCount[rightChar] && \n            windowCount[rightChar] === targetCount[rightChar]) {\n            formed++;\n        }\n        \n        // Try to contract the window from the left\n        while (left <= right && formed === required) {\n            const leftChar = s[left];\n            \n            // Update minimum window if current window is smaller\n            if (right - left + 1 < minLen) {\n                minLen = right - left + 1;\n                minStart = left;\n            }\n            \n            // Remove character from left side of window\n            windowCount[leftChar]--;\n            if (targetCount[leftChar] && \n                windowCount[leftChar] < targetCount[leftChar]) {\n                formed--;\n            }\n            \n            left++;\n        }\n        \n        right++;\n    }\n    \n    return minLen === Infinity ? \"\" : s.substring(minStart, minStart + minLen);\n};\n    ",
      "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "minimum-window-substring",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 790,
      "statusCode": 10,
      "totalTestcases": 268,
      "question": {
        "title": "Minimum Window Substring",
        "titleSlug": "minimum-window-substring",
        "questionId": "76"
      },
      "status_code": 10,
      "passedTestCaseCnt": 268,
      "totalTestCaseCnt": 268
    },
    {
      "id": 1776227410,
      "question_id": 76,
      "lang": "java",
      "lang_name": "Java",
      "time": "7minutes",
      "timestamp": 1758298289,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "20 ms",
      "url": "/submissions/detail/1776227410/",
      "is_pending": "Not Pending",
      "title": "Minimum Window Substring",
      "memory": "45.2 MB",
      "code": "import java.util.*;\n\nclass Solution {\n    public String minWindow(String s, String t) {\n        if (s == null || t == null || s.length() < t.length()) {\n            return \"\";\n        }\n        \n        Map<Character, Integer> targetCount = new HashMap<>();\n        Map<Character, Integer> windowCount = new HashMap<>();\n        \n        // Count characters in target string t\n        for (char c : t.toCharArray()) {\n            targetCount.put(c, targetCount.getOrDefault(c, 0) + 1);\n        }\n        \n        int left = 0, right = 0;\n        int minLen = Integer.MAX_VALUE;\n        int minStart = 0;\n        int required = targetCount.size();\n        int formed = 0;\n        \n        while (right < s.length()) {\n            char rightChar = s.charAt(right);\n            windowCount.put(rightChar, windowCount.getOrDefault(rightChar, 0) + 1);\n            \n            // Check if current character satisfies the requirement\n            if (targetCount.containsKey(rightChar) && \n                windowCount.get(rightChar).intValue() == targetCount.get(rightChar).intValue()) {\n                formed++;\n            }\n            \n            // Try to contract the window from the left\n            while (left <= right && formed == required) {\n                char leftChar = s.charAt(left);\n                \n                // Update minimum window if current window is smaller\n                if (right - left + 1 < minLen) {\n                    minLen = right - left + 1;\n                    minStart = left;\n                }\n                \n                // Remove character from left side of window\n                windowCount.put(leftChar, windowCount.get(leftChar) - 1);\n                if (targetCount.containsKey(leftChar) && \n                    windowCount.get(leftChar) < targetCount.get(leftChar)) {\n                    formed--;\n                }\n                \n                left++;\n            }\n            \n            right++;\n        }\n        \n        return minLen == Integer.MAX_VALUE ? \"\" : s.substring(minStart, minStart + minLen);\n    }\n}\n    ",
      "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "minimum-window-substring",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 789,
      "statusCode": 10,
      "totalTestcases": 268,
      "question": {
        "title": "Minimum Window Substring",
        "titleSlug": "minimum-window-substring",
        "questionId": "76"
      },
      "status_code": 10,
      "passedTestCaseCnt": 268,
      "totalTestCaseCnt": 268
    },
    {
      "id": 1776226629,
      "question_id": 51,
      "lang": "python",
      "lang_name": "Python",
      "time": "8minutes",
      "timestamp": 1758298241,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "55 ms",
      "url": "/submissions/detail/1776226629/",
      "is_pending": "Not Pending",
      "title": "N-Queens",
      "memory": "12.6 MB",
      "code": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        result = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        self.backtrack(board, 0, result)\n        return result\n    \n    def backtrack(self, board, row, result):\n        \"\"\"\n        Backtrack to find all valid queen placements\n        \"\"\"\n        if row == len(board):\n            # Convert board to the required format\n            solution = [''.join(row) for row in board]\n            result.append(solution)\n            return\n        \n        for col in range(len(board)):\n            if self.isValid(board, row, col):\n                board[row][col] = 'Q'\n                self.backtrack(board, row + 1, result)\n                board[row][col] = '.'\n    \n    def isValid(self, board, row, col):\n        \"\"\"\n        Check if placing a queen at (row, col) is valid\n        \"\"\"\n        # Check column\n        for i in range(row):\n            if board[i][col] == 'Q':\n                return False\n        \n        # Check diagonal (top-left to bottom-right)\n        i, j = row - 1, col - 1\n        while i >= 0 and j >= 0:\n            if board[i][j] == 'Q':\n                return False\n            i -= 1\n            j -= 1\n        \n        # Check diagonal (top-right to bottom-left)\n        i, j = row - 1, col + 1\n        while i >= 0 and j < len(board):\n            if board[i][j] == 'Q':\n                return False\n            i -= 1\n            j += 1\n        \n        return True\n    ",
      "compare_result": "111111111",
      "title_slug": "n-queens",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 788,
      "statusCode": 10,
      "totalTestcases": 9,
      "question": {
        "title": "N-Queens",
        "titleSlug": "n-queens",
        "questionId": "51"
      },
      "status_code": 10,
      "passedTestCaseCnt": 9,
      "totalTestCaseCnt": 9
    },
    {
      "id": 1776226264,
      "question_id": 51,
      "lang": "php",
      "lang_name": "PHP",
      "time": "8minutes",
      "timestamp": 1758298219,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "18 ms",
      "url": "/submissions/detail/1776226264/",
      "is_pending": "Not Pending",
      "title": "N-Queens",
      "memory": "20.4 MB",
      "code": "class Solution {\n\n    /**\n     * @param Integer $n\n     * @return String[][]\n     */\n    function solveNQueens($n) {\n        $result = [];\n        $board = array_fill(0, $n, str_repeat('.', $n));\n        $this->backtrack($board, 0, $result);\n        return $result;\n    }\n    \n    private function backtrack(&$board, $row, &$result) {\n        $n = count($board);\n        \n        if ($row === $n) {\n            $result[] = $board;\n            return;\n        }\n        \n        for ($col = 0; $col < $n; $col++) {\n            if ($this->isValid($board, $row, $col)) {\n                $board[$row][$col] = 'Q';\n                $this->backtrack($board, $row + 1, $result);\n                $board[$row][$col] = '.';\n            }\n        }\n    }\n    \n    private function isValid($board, $row, $col) {\n        $n = count($board);\n        \n        // Check column\n        for ($i = 0; $i < $row; $i++) {\n            if ($board[$i][$col] === 'Q') {\n                return false;\n            }\n        }\n        \n        // Check diagonal (top-left to bottom-right)\n        for ($i = $row - 1, $j = $col - 1; $i >= 0 && $j >= 0; $i--, $j--) {\n            if ($board[$i][$j] === 'Q') {\n                return false;\n            }\n        }\n        \n        // Check diagonal (top-right to bottom-left)\n        for ($i = $row - 1, $j = $col + 1; $i >= 0 && $j < $n; $i--, $j++) {\n            if ($board[$i][$j] === 'Q') {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n}\n    ",
      "compare_result": "111111111",
      "title_slug": "n-queens",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 787,
      "statusCode": 10,
      "totalTestcases": 9,
      "question": {
        "title": "N-Queens",
        "titleSlug": "n-queens",
        "questionId": "51"
      },
      "status_code": 10,
      "passedTestCaseCnt": 9,
      "totalTestCaseCnt": 9
    },
    {
      "id": 1776225905,
      "question_id": 51,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "8minutes",
      "timestamp": 1758298198,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "12 ms",
      "url": "/submissions/detail/1776225905/",
      "is_pending": "Not Pending",
      "title": "N-Queens",
      "memory": "59.8 MB",
      "code": "/**\n * @param {number} n\n * @return {string[][]}\n */\nvar solveNQueens = function(n) {\n    const result = [];\n    const board = Array(n).fill().map(() => Array(n).fill('.'));\n    \n    solveNQueensHelper(board, 0, result);\n    return result;\n};\n\nfunction solveNQueensHelper(board, row, result) {\n    if (row === board.length) {\n        // All queens placed successfully\n        result.push(constructBoard(board));\n        return;\n    }\n    \n    for (let col = 0; col < board.length; col++) {\n        if (isValid(board, row, col)) {\n            board[row][col] = 'Q';\n            solveNQueensHelper(board, row + 1, result);\n            board[row][col] = '.'; // Backtrack\n        }\n    }\n}\n\nfunction isValid(board, row, col) {\n    // Check column\n    for (let i = 0; i < row; i++) {\n        if (board[i][col] === 'Q') {\n            return false;\n        }\n    }\n    \n    // Check diagonal (top-left to bottom-right)\n    for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n        if (board[i][j] === 'Q') {\n            return false;\n        }\n    }\n    \n    // Check diagonal (top-right to bottom-left)\n    for (let i = row - 1, j = col + 1; i >= 0 && j < board.length; i--, j++) {\n        if (board[i][j] === 'Q') {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nfunction constructBoard(board) {\n    return board.map(row => row.join(''));\n}\n    ",
      "compare_result": "111111111",
      "title_slug": "n-queens",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 786,
      "statusCode": 10,
      "totalTestcases": 9,
      "question": {
        "title": "N-Queens",
        "titleSlug": "n-queens",
        "questionId": "51"
      },
      "status_code": 10,
      "passedTestCaseCnt": 9,
      "totalTestCaseCnt": 9
    },
    {
      "id": 1776225519,
      "question_id": 51,
      "lang": "java",
      "lang_name": "Java",
      "time": "9minutes",
      "timestamp": 1758298173,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "2 ms",
      "url": "/submissions/detail/1776225519/",
      "is_pending": "Not Pending",
      "title": "N-Queens",
      "memory": "45 MB",
      "code": "import java.util.*;\n\nclass Solution {\n    public List<List<String>> solveNQueens(int n) {\n        List<List<String>> result = new ArrayList<>();\n        char[][] board = new char[n][n];\n        \n        // Initialize board with '.'\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(board[i], '.');\n        }\n        \n        solveNQueensHelper(board, 0, result);\n        return result;\n    }\n    \n    private void solveNQueensHelper(char[][] board, int row, List<List<String>> result) {\n        if (row == board.length) {\n            // All queens placed successfully\n            result.add(constructBoard(board));\n            return;\n        }\n        \n        for (int col = 0; col < board.length; col++) {\n            if (isValid(board, row, col)) {\n                board[row][col] = 'Q';\n                solveNQueensHelper(board, row + 1, result);\n                board[row][col] = '.'; // Backtrack\n            }\n        }\n    }\n    \n    private boolean isValid(char[][] board, int row, int col) {\n        // Check column\n        for (int i = 0; i < row; i++) {\n            if (board[i][col] == 'Q') {\n                return false;\n            }\n        }\n        \n        // Check diagonal (top-left to bottom-right)\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n            if (board[i][j] == 'Q') {\n                return false;\n            }\n        }\n        \n        // Check diagonal (top-right to bottom-left)\n        for (int i = row - 1, j = col + 1; i >= 0 && j < board.length; i--, j++) {\n            if (board[i][j] == 'Q') {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    private List<String> constructBoard(char[][] board) {\n        List<String> result = new ArrayList<>();\n        for (char[] row : board) {\n            result.add(new String(row));\n        }\n        return result;\n    }\n}\n    ",
      "compare_result": "111111111",
      "title_slug": "n-queens",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 785,
      "statusCode": 10,
      "totalTestcases": 9,
      "question": {
        "title": "N-Queens",
        "titleSlug": "n-queens",
        "questionId": "51"
      },
      "status_code": 10,
      "passedTestCaseCnt": 9,
      "totalTestCaseCnt": 9
    },
    {
      "id": 1776224308,
      "question_id": 10,
      "lang": "python",
      "lang_name": "Python",
      "time": "10minutes",
      "timestamp": 1758298101,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "19 ms",
      "url": "/submissions/detail/1776224308/",
      "is_pending": "Not Pending",
      "title": "Regular Expression Matching",
      "memory": "12.4 MB",
      "code": "\nclass Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        \n        # Empty string matches empty pattern\n        dp[0][0] = True\n        \n        # Handle patterns like a*, a*b*, a*b*c*\n        for j in range(2, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == '*':\n                    # Case 1: '*' matches zero characters\n                    dp[i][j] = dp[i][j - 2]\n                    # Case 2: '*' matches one or more characters\n                    if self.matches(s, p, i - 1, j - 2):\n                        dp[i][j] = dp[i][j] or dp[i - 1][j]\n                else:\n                    # Direct character match\n                    if self.matches(s, p, i - 1, j - 1):\n                        dp[i][j] = dp[i - 1][j - 1]\n        \n        return dp[m][n]\n    \n    def matches(self, s, p, i, j):\n        \"\"\"\n        Helper function to check if characters match\n        \"\"\"\n        if j < 0:\n            return False\n        return p[j] == '.' or s[i] == p[j]\n    ",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "regular-expression-matching",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 784,
      "statusCode": 10,
      "totalTestcases": 354,
      "question": {
        "title": "Regular Expression Matching",
        "titleSlug": "regular-expression-matching",
        "questionId": "10"
      },
      "status_code": 10,
      "passedTestCaseCnt": 354,
      "totalTestCaseCnt": 354
    },
    {
      "id": 1776223850,
      "question_id": 10,
      "lang": "php",
      "lang_name": "PHP",
      "time": "10minutes",
      "timestamp": 1758298072,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "6 ms",
      "url": "/submissions/detail/1776223850/",
      "is_pending": "Not Pending",
      "title": "Regular Expression Matching",
      "memory": "20.8 MB",
      "code": "\nclass Solution {\n\n    /**\n     * @param String $s\n     * @param String $p\n     * @return Boolean\n     */\n    function isMatch($s, $p) {\n        $m = strlen($s);\n        $n = strlen($p);\n        \n        // dp[i][j] represents if s[0...i-1] matches p[0...j-1]\n        $dp = array_fill(0, $m + 1, array_fill(0, $n + 1, false));\n        \n        // Empty string matches empty pattern\n        $dp[0][0] = true;\n        \n        // Handle patterns like a*, a*b*, a*b*c* etc.\n        for ($j = 2; $j <= $n; $j += 2) {\n            if ($p[$j - 1] === '*') {\n                $dp[0][$j] = $dp[0][$j - 2];\n            }\n        }\n        \n        for ($i = 1; $i <= $m; $i++) {\n            for ($j = 1; $j <= $n; $j++) {\n                if ($p[$j - 1] === '*') {\n                    // Case 1: * matches zero characters\n                    $dp[$i][$j] = $dp[$i][$j - 2];\n                    \n                    // Case 2: * matches one or more characters\n                    if ($this->matches($s, $p, $i - 1, $j - 2)) {\n                        $dp[$i][$j] = $dp[$i][$j] || $dp[$i - 1][$j];\n                    }\n                } else {\n                    // Direct character match\n                    if ($this->matches($s, $p, $i - 1, $j - 1)) {\n                        $dp[$i][$j] = $dp[$i - 1][$j - 1];\n                    }\n                }\n            }\n        }\n        \n        return $dp[$m][$n];\n    }\n    \n    private function matches($s, $p, $i, $j) {\n        if ($j < 0) {\n            return false;\n        }\n        \n        return $p[$j] === '.' || $s[$i] === $p[$j];\n    }\n}\n    ",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "regular-expression-matching",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 783,
      "statusCode": 10,
      "totalTestcases": 354,
      "question": {
        "title": "Regular Expression Matching",
        "titleSlug": "regular-expression-matching",
        "questionId": "10"
      },
      "status_code": 10,
      "passedTestCaseCnt": 354,
      "totalTestCaseCnt": 354
    },
    {
      "id": 1776223424,
      "question_id": 10,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "11minutes",
      "timestamp": 1758298046,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "10 ms",
      "url": "/submissions/detail/1776223424/",
      "is_pending": "Not Pending",
      "title": "Regular Expression Matching",
      "memory": "60.1 MB",
      "code": "/**\n * @param {string} s\n * @param {string} p\n * @return {boolean}\n */\nvar isMatch = function(s, p) {\n    const m = s.length;\n    const n = p.length;\n    \n    // dp[i][j] represents if s[0...i-1] matches p[0...j-1]\n    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(false));\n    \n    // Empty string matches empty pattern\n    dp[0][0] = true;\n    \n    // Handle patterns like a*, a*b*, a*b*c* that can match empty string\n    for (let j = 2; j <= n; j += 2) {\n        if (p[j - 1] === '*') {\n            dp[0][j] = dp[0][j - 2];\n        }\n    }\n    \n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            const sChar = s[i - 1];\n            const pChar = p[j - 1];\n            \n            if (pChar === '*') {\n                // Case 1: '*' matches zero characters\n                dp[i][j] = dp[i][j - 2];\n                \n                // Case 2: '*' matches one or more characters\n                if (matches(sChar, p[j - 2])) {\n                    dp[i][j] = dp[i][j] || dp[i - 1][j];\n                }\n            } else if (matches(sChar, pChar)) {\n                dp[i][j] = dp[i - 1][j - 1];\n            }\n        }\n    }\n    \n    return dp[m][n];\n};\n\nfunction matches(sChar, pChar) {\n    return pChar === '.' || sChar === pChar;\n}\n    ",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "regular-expression-matching",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 782,
      "statusCode": 10,
      "totalTestcases": 354,
      "question": {
        "title": "Regular Expression Matching",
        "titleSlug": "regular-expression-matching",
        "questionId": "10"
      },
      "status_code": 10,
      "passedTestCaseCnt": 354,
      "totalTestCaseCnt": 354
    },
    {
      "id": 1776223078,
      "question_id": 10,
      "lang": "java",
      "lang_name": "Java",
      "time": "11minutes",
      "timestamp": 1758298025,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "1 ms",
      "url": "/submissions/detail/1776223078/",
      "is_pending": "Not Pending",
      "title": "Regular Expression Matching",
      "memory": "42 MB",
      "code": "class Solution {\n    public boolean isMatch(String s, String p) {\n        int m = s.length();\n        int n = p.length();\n        \n        // dp[i][j] represents if s[0...i-1] matches p[0...j-1]\n        boolean[][] dp = new boolean[m + 1][n + 1];\n        \n        // Empty string matches empty pattern\n        dp[0][0] = true;\n        \n        // Handle patterns like a*, a*b*, a*b*c* that can match empty string\n        for (int j = 2; j <= n; j += 2) {\n            if (p.charAt(j - 1) == '*') {\n                dp[0][j] = dp[0][j - 2];\n            }\n        }\n        \n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                char sChar = s.charAt(i - 1);\n                char pChar = p.charAt(j - 1);\n                \n                if (pChar == '*') {\n                    // Case 1: '*' matches zero characters\n                    dp[i][j] = dp[i][j - 2];\n                    \n                    // Case 2: '*' matches one or more characters\n                    if (matches(sChar, p.charAt(j - 2))) {\n                        dp[i][j] = dp[i][j] || dp[i - 1][j];\n                    }\n                } else if (matches(sChar, pChar)) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                }\n            }\n        }\n        \n        return dp[m][n];\n    }\n    \n    private boolean matches(char sChar, char pChar) {\n        return pChar == '.' || sChar == pChar;\n    }\n}\n    ",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "regular-expression-matching",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 781,
      "statusCode": 10,
      "totalTestcases": 354,
      "question": {
        "title": "Regular Expression Matching",
        "titleSlug": "regular-expression-matching",
        "questionId": "10"
      },
      "status_code": 10,
      "passedTestCaseCnt": 354,
      "totalTestCaseCnt": 354
    }
  ]
}