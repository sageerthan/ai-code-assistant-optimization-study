{
  "submissions_dump": [
    {
      "id": 1766033425,
      "question_id": 146,
      "lang": "python",
      "lang_name": "Python",
      "time": "2minutes",
      "timestamp": 1757509214,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "1839 ms",
      "url": "/submissions/detail/1766033425/",
      "is_pending": "Not Pending",
      "title": "LRU Cache",
      "memory": "76.8 MB",
      "code": "class LRUCache(object):\n\n    def __init__(self, capacity):\n        \"\"\"\n        :type capacity: int\n        \"\"\"\n        self.capacity = capacity\n        self.cache = {}\n        self.order = []\n        \n\n    def get(self, key):\n        \"\"\"\n        :type key: int\n        \"\"\"\n        if key in self.cache:\n            # Move the accessed key to the end of the order list\n            self.order.remove(key)\n            self.order.append(key)\n            return self.cache[key]\n        return -1\n        \n\n    def put(self, key, value):\n        \"\"\"\n        :type key: int\n        :rtype: None\n        \"\"\"\n        if key in self.cache:\n            # Update the value\n            self.cache[key] = value\n            # Move the accessed key to the end of the order list\n            self.order.remove(key)\n            self.order.append(key)\n        else:\n            if len(self.cache) >= self.capacity:\n                # Evict the least recently used key\n                lru_key = self.order.pop(0)\n                del self.cache[lru_key]\n            # Add the new key-value pair\n            self.cache[key] = value\n            self.order.append(key)\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)                                                                                                  \n    ",
      "compare_result": "111111111111111111111111",
      "title_slug": "lru-cache",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 124,
      "statusCode": 10,
      "totalTestcases": 24,
      "question": {
        "title": "LRU Cache",
        "titleSlug": "lru-cache",
        "questionId": "146"
      },
      "status_code": 10,
      "passedTestCaseCnt": 24,
      "totalTestCaseCnt": 24
    },
    {
      "id": 1766032598,
      "question_id": 146,
      "lang": "php",
      "lang_name": "PHP",
      "time": "3minutes",
      "timestamp": 1757509159,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "86 ms",
      "url": "/submissions/detail/1766032598/",
      "is_pending": "Not Pending",
      "title": "LRU Cache",
      "memory": "102.2 MB",
      "code": "class LRUCache {\n    private $capacity;\n    private $cache; // associative array: key => [value, node]\n    private $head;  // dummy head of doubly linked list\n    private $tail;  // dummy tail of doubly linked list\n\n    /**\n     * Doubly linked list node for O(1) LRU operations.\n     */\n    private function createNode($key = null, $value = null) {\n        return ['key' => $key, 'value' => $value, 'prev' => null, 'next' => null];\n    }\n\n    /**\n     * @param Integer $capacity\n     */\n    function __construct($capacity) {\n        $this->capacity = $capacity;\n        $this->cache = [];\n        // Dummy head and tail nodes for easy removal/insertion\n        $this->head = $this->createNode();\n        $this->tail = $this->createNode();\n        $this->head['next'] = &$this->tail;\n        $this->tail['prev'] = &$this->head;\n    }\n\n    /**\n     * Remove a node from the doubly linked list.\n     */\n    private function removeNode(&$node) {\n        $prev = &$node['prev'];\n        $next = &$node['next'];\n        $prev['next'] = &$next;\n        $next['prev'] = &$prev;\n    }\n\n    /**\n     * Add a node right after head (most recently used).\n     */\n    private function addToHead(&$node) {\n        $node['next'] = &$this->head['next'];\n        $node['prev'] = &$this->head;\n        $this->head['next']['prev'] = &$node;\n        $this->head['next'] = &$node;\n    }\n\n    /**\n     * @param Integer $key\n     * @return Integer\n     */\n    function get($key) {\n        if (!isset($this->cache[$key])) {\n            return -1;\n        }\n        // Move node to head (most recently used)\n        $node = &$this->cache[$key];\n        $this->removeNode($node);\n        $this->addToHead($node);\n        return $node['value'];\n    }\n\n    /**\n     * @param Integer $key\n     * @param Integer $value\n     * @return NULL\n     */\n    function put($key, $value) {\n        if (isset($this->cache[$key])) {\n            // Update value and move to head\n            $node = &$this->cache[$key];\n            $node['value'] = $value;\n            $this->removeNode($node);\n            $this->addToHead($node);\n        } else {\n            // New node\n            $node = $this->createNode($key, $value);\n            $this->cache[$key] = &$node;\n            $this->addToHead($node);\n            if (count($this->cache) > $this->capacity) {\n                // Remove least recently used node (before tail)\n                $lru = &$this->tail['prev'];\n                $this->removeNode($lru);\n                unset($this->cache[$lru['key']]);\n            }\n        }\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * $obj = LRUCache($capacity);\n * $ret_1 = $obj->get($key);\n * $obj->put($key, $value);\n */\n \n \n",
      "compare_result": "111111111111111111111111",
      "title_slug": "lru-cache",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 123,
      "statusCode": 10,
      "totalTestcases": 24,
      "question": {
        "title": "LRU Cache",
        "titleSlug": "lru-cache",
        "questionId": "146"
      },
      "status_code": 10,
      "passedTestCaseCnt": 24,
      "totalTestCaseCnt": 24
    },
    {
      "id": 1766031761,
      "question_id": 146,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "4minutes",
      "timestamp": 1757509106,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "273 ms",
      "url": "/submissions/detail/1766031761/",
      "is_pending": "Not Pending",
      "title": "LRU Cache",
      "memory": "107.4 MB",
      "code": "/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.capacity = capacity; // Maximum number of items in the cache\n    this.cache = new Map(); // Map to store key-value pairs\n    this.order = []; // Array to maintain the order of keys for LRU\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    if (!this.cache.has(key)) {\n        return -1; // Key not found\n    }\n    // Move the key to the end to mark it as recently used\n    this.order.splice(this.order.indexOf(key), 1);\n    this.order.push(key);\n    return this.cache.get(key); // Return the value associated with the key\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    if (this.cache.has(key)) {\n        // If the key already exists, update the value and mark it as recently used\n        this.cache.set(key, value);\n        this.order.splice(this.order.indexOf(key), 1);\n    } else {\n        // If the cache is at capacity, remove the least recently used item\n        if (this.cache.size >= this.capacity) {\n            const lruKey = this.order.shift(); // Remove the first key in order\n            this.cache.delete(lruKey); // Remove it from the cache\n        }\n        this.cache.set(key, value); // Add the new key-value pair to the cache\n    }\n    this.order.push(key); // Mark the key as recently used\n};\n\n/** \n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */",
      "compare_result": "111111111111111111111111",
      "title_slug": "lru-cache",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 122,
      "statusCode": 10,
      "totalTestcases": 24,
      "question": {
        "title": "LRU Cache",
        "titleSlug": "lru-cache",
        "questionId": "146"
      },
      "status_code": 10,
      "passedTestCaseCnt": 24,
      "totalTestCaseCnt": 24
    },
    {
      "id": 1766030497,
      "question_id": 146,
      "lang": "java",
      "lang_name": "Java",
      "time": "5minutes",
      "timestamp": 1757509020,
      "status": 20,
      "status_display": "Compile Error",
      "runtime": "N/A",
      "url": "/submissions/detail/1766030497/",
      "is_pending": "Not Pending",
      "title": "LRU Cache",
      "memory": "N/A",
      "code": "class LRUCache {\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        this.cache = new HashMap<>();\n        this.lruList = new LinkedList<>();\n    }\n    \n    public int get(int key) {\n        if (cache.containsKey(key)) {\n            // Move the accessed key to the front of the LRU list\n            lruList.remove(key);\n            lruList.addFirst(key);\n            return cache.get(key);\n        }\n        return -1; // Key not found\n    }\n    \n    public void put(int key, int value) {\n        if (cache.containsKey(key)) {\n            // Update the value and move the key to the front of the LRU list\n            cache.put(key, value);\n            lruList.remove(key);\n            lruList.addFirst(key);\n        } else {\n            // Add a new key-value pair\n            if (cache.size() >= capacity) {\n                // Evict the least recently used key\n                int lruKey = lruList.removeLast();\n                cache.remove(lruKey);\n            }\n            cache.put(key, value);\n            lruList.addFirst(key);\n        }\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n    ",
      "compare_result": null,
      "title_slug": "lru-cache",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 121,
      "statusCode": 20,
      "totalTestcases": 0,
      "question": {
        "title": "LRU Cache",
        "titleSlug": "lru-cache",
        "questionId": "146"
      },
      "status_code": 20,
      "passedTestCaseCnt": 0,
      "totalTestCaseCnt": 0
    },
    {
      "id": 1766029478,
      "question_id": 133,
      "lang": "python",
      "lang_name": "Python",
      "time": "6minutes",
      "timestamp": 1757508953,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "36 ms",
      "url": "/submissions/detail/1766029478/",
      "is_pending": "Not Pending",
      "title": "Clone Graph",
      "memory": "12.8 MB",
      "code": "class Node(object):\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\nclass Solution(object):\n    def cloneGraph(self, node):\n        \"\"\"\n        :type node: Node\n        :rtype: Node\n        \"\"\"\n        if not node:\n            return None\n        \n        # Dictionary to hold the mapping from original nodes to cloned nodes\n        cloned_nodes = {}\n        \n        def clone(node):\n            if node in cloned_nodes:\n                return cloned_nodes[node]\n            \n            # Create a new node for the clone\n            clone_node = Node(node.val)\n            cloned_nodes[node] = clone_node\n            \n            # Recursively clone the neighbors\n            for neighbor in node.neighbors:\n                clone_node.neighbors.append(clone(neighbor))\n            \n            return clone_node\n        \n        return clone(node)                                                                                                     ",
      "compare_result": "1111111111111111111111",
      "title_slug": "clone-graph",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 120,
      "statusCode": 10,
      "totalTestcases": 22,
      "question": {
        "title": "Clone Graph",
        "titleSlug": "clone-graph",
        "questionId": "133"
      },
      "status_code": 10,
      "passedTestCaseCnt": 22,
      "totalTestCaseCnt": 22
    },
    {
      "id": 1766028948,
      "question_id": 133,
      "lang": "php",
      "lang_name": "PHP",
      "time": "7minutes",
      "timestamp": 1757508916,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "7 ms",
      "url": "/submissions/detail/1766028948/",
      "is_pending": "Not Pending",
      "title": "Clone Graph",
      "memory": "21.3 MB",
      "code": "class Solution {\n    /**\n     * @param Node $node\n     * @return Node\n     */\n    function cloneGraph($node) {\n        if ($node === null) {\n            return null; // Return null for an empty graph\n        }\n\n        $visited = []; // To keep track of visited nodes\n        return $this->cloneNode($node, $visited);  \n    }\n\n    private function cloneNode($node, &$visited) {\n        if (isset($visited[$node->val])) {\n            return $visited[$node->val]; // Return the cloned node if it already exists\n        }\n\n        // Create a new cloned node\n        $clonedNode = new Node($node->val);\n        $visited[$node->val] = $clonedNode;\n\n        // Recursively clone the neighbors\n        foreach ($node->neighbors as $neighbor) {\n            $clonedNode->neighbors[] = $this->cloneNode($neighbor, $visited);\n        }\n\n        return $clonedNode;\n    }\n}",
      "compare_result": "1111111111111111111111",
      "title_slug": "clone-graph",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 119,
      "statusCode": 10,
      "totalTestcases": 22,
      "question": {
        "title": "Clone Graph",
        "titleSlug": "clone-graph",
        "questionId": "133"
      },
      "status_code": 10,
      "passedTestCaseCnt": 22,
      "totalTestCaseCnt": 22
    },
    {
      "id": 1766028344,
      "question_id": 133,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "7minutes",
      "timestamp": 1757508873,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "66 ms",
      "url": "/submissions/detail/1766028344/",
      "is_pending": "Not Pending",
      "title": "Clone Graph",
      "memory": "57.3 MB",
      "code": "/**\n * @param {_Node} node\n * @return {_Node}\n */\nvar cloneGraph = function(node) {\n    if (!node) return null; // If the input node is null, return null\n\n    const visited = new Map(); // Map to keep track of visited nodes\n\n    const dfs = (currentNode) => {\n        if (visited.has(currentNode.val)) {\n            return visited.get(currentNode.val); // Return the cloned node if already visited\n        }\n\n        // Create a new node with the same value\n        const clonedNode = new _Node(currentNode.val);\n        visited.set(currentNode.val, clonedNode); // Store the cloned node in the map\n\n        // Recursively clone all neighbors\n        for (const neighbor of currentNode.neighbors) {\n            clonedNode.neighbors.push(dfs(neighbor));\n        }\n\n        return clonedNode; // Return the cloned node\n    };\n\n    return dfs(node); // Start DFS from the given node  \n};",
      "compare_result": "1111111111111111111111",
      "title_slug": "clone-graph",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 118,
      "statusCode": 10,
      "totalTestcases": 22,
      "question": {
        "title": "Clone Graph",
        "titleSlug": "clone-graph",
        "questionId": "133"
      },
      "status_code": 10,
      "passedTestCaseCnt": 22,
      "totalTestCaseCnt": 22
    },
    {
      "id": 1766027852,
      "question_id": 133,
      "lang": "java",
      "lang_name": "Java",
      "time": "8minutes",
      "timestamp": 1757508836,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "26 ms",
      "url": "/submissions/detail/1766027852/",
      "is_pending": "Not Pending",
      "title": "Clone Graph",
      "memory": "42.8 MB",
      "code": "class Solution {\n    public Node cloneGraph(Node node) {\n        if (node == null) {\n            return null; // If the input node is null, return null\n        }\n        \n        Map<Node, Node> visited = new HashMap<>(); // Map to keep track of visited nodes\n        \n        return clone(node, visited); // Start cloning from the given node\n        \n    }\n\n    private Node clone(Node node, Map<Node, Node> visited) {\n        if (visited.containsKey(node)) {\n            return visited.get(node); // Return the cloned node if it already exists\n        }\n\n        // Create a new cloned node\n        Node cloneNode = new Node(node.val);\n        visited.put(node, cloneNode); // Mark the original node as visited\n\n        // Recursively clone all neighbors\n        for (Node neighbor : node.neighbors) {\n            cloneNode.neighbors.add(clone(neighbor, visited));\n        }\n\n        return cloneNode;\n    }\n}",
      "compare_result": "1111111111111111111111",
      "title_slug": "clone-graph",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 117,
      "statusCode": 10,
      "totalTestcases": 22,
      "question": {
        "title": "Clone Graph",
        "titleSlug": "clone-graph",
        "questionId": "133"
      },
      "status_code": 10,
      "passedTestCaseCnt": 22,
      "totalTestCaseCnt": 22
    },
    {
      "id": 1766026694,
      "question_id": 200,
      "lang": "python",
      "lang_name": "Python",
      "time": "9minutes",
      "timestamp": 1757508750,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "224 ms",
      "url": "/submissions/detail/1766026694/",
      "is_pending": "Not Pending",
      "title": "Number of Islands",
      "memory": "29.8 MB",
      "code": "class Solution(object):\n    def numIslands(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: int\n        \"\"\"\n        if not grid:\n            return 0\n        \n        rows, cols = len(grid), len(grid[0])\n        visited = [[False] * cols for _ in range(rows)]\n        \n        def dfs(r, c):\n            if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == '0' or visited[r][c]:\n                return\n            visited[r][c] = True\n            # Explore all four directions\n            dfs(r + 1, c)\n            dfs(r - 1, c)\n            dfs(r, c + 1)\n            dfs(r, c - 1)\n        \n        island_count = 0\n        \n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] == '1' and not visited[i][j]:\n                    dfs(i, j)\n                    island_count += 1\n        \n        return island_count                                                                                                   \n    ",
      "compare_result": "1111111111111111111111111111111111111111111111111",
      "title_slug": "number-of-islands",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 116,
      "statusCode": 10,
      "totalTestcases": 49,
      "question": {
        "title": "Number of Islands",
        "titleSlug": "number-of-islands",
        "questionId": "200"
      },
      "status_code": 10,
      "passedTestCaseCnt": 49,
      "totalTestCaseCnt": 49
    },
    {
      "id": 1766025438,
      "question_id": 200,
      "lang": "php",
      "lang_name": "PHP",
      "time": "11minutes",
      "timestamp": 1757508661,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "87 ms",
      "url": "/submissions/detail/1766025438/",
      "is_pending": "Not Pending",
      "title": "Number of Islands",
      "memory": "35.7 MB",
      "code": "class Solution {\n\n    /**\n     * @param String[][] $grid\n     * @return Integer\n     */\n    function numIslands($grid) {\n        if (empty($grid)) {\n            return 0;\n        }\n\n        $rows = count($grid);\n        $cols = count($grid[0]);\n        $islandCount = 0;\n\n        for ($i = 0; $i < $rows; $i++) {\n            for ($j = 0; $j < $cols; $j++) {\n                if ($grid[$i][$j] === '1') {\n                    $this->dfs($grid, $i, $j, $rows, $cols);\n                    $islandCount++;\n                }\n            }\n        }\n\n        return $islandCount;  \n    }\n\n    private function dfs(&$grid, $i, $j, $rows, $cols) {\n        if ($i < 0 || $i >= $rows || $j < 0 || $j >= $cols || $grid[$i][$j] === '0') {\n            return;\n        }\n\n        // Mark the land as visited\n        $grid[$i][$j] = '0';\n\n        // Explore all four directions\n        $this->dfs($grid, $i + 1, $j, $rows, $cols); // Down\n        $this->dfs($grid, $i - 1, $j, $rows, $cols); // Up\n        $this->dfs($grid, $i, $j + 1, $rows, $cols); // Right\n        $this->dfs($grid, $i, $j - 1, $rows, $cols); // Left\n    }\n}\n    ",
      "compare_result": "1111111111111111111111111111111111111111111111111",
      "title_slug": "number-of-islands",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 115,
      "statusCode": 10,
      "totalTestcases": 49,
      "question": {
        "title": "Number of Islands",
        "titleSlug": "number-of-islands",
        "questionId": "200"
      },
      "status_code": 10,
      "passedTestCaseCnt": 49,
      "totalTestCaseCnt": 49
    },
    {
      "id": 1766024977,
      "question_id": 200,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "11minutes",
      "timestamp": 1757508629,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "61 ms",
      "url": "/submissions/detail/1766024977/",
      "is_pending": "Not Pending",
      "title": "Number of Islands",
      "memory": "58.4 MB",
      "code": "/**\n * @param {character[][]} grid\n * @return {number}\n */\nvar numIslands = function(grid) {\n    const rows = grid.length;\n    const cols = grid[0].length;\n    let islandCount = 0;\n\n    const dfs = (r, c) => {\n        if (r < 0 || c < 0 || r >= rows || c >= cols || grid[r][c] === '0') {\n            return;\n        }\n        grid[r][c] = '0'; // Mark the land as visited\n        dfs(r - 1, c); // Up\n        dfs(r + 1, c); // Down\n        dfs(r, c - 1); // Left\n        dfs(r, c + 1); // Right\n    };\n\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            if (grid[i][j] === '1') {\n                islandCount++;\n                dfs(i, j);\n            }\n        }\n    }\n\n    return islandCount;\n};\n    ",
      "compare_result": "1111111111111111111111111111111111111111111111111",
      "title_slug": "number-of-islands",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 114,
      "statusCode": 10,
      "totalTestcases": 49,
      "question": {
        "title": "Number of Islands",
        "titleSlug": "number-of-islands",
        "questionId": "200"
      },
      "status_code": 10,
      "passedTestCaseCnt": 49,
      "totalTestCaseCnt": 49
    },
    {
      "id": 1766024618,
      "question_id": 200,
      "lang": "java",
      "lang_name": "Java",
      "time": "12minutes",
      "timestamp": 1757508601,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "2 ms",
      "url": "/submissions/detail/1766024618/",
      "is_pending": "Not Pending",
      "title": "Number of Islands",
      "memory": "49.6 MB",
      "code": "class Solution {\n    public int numIslands(char[][] grid) {\n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\n            return 0;\n        }\n\n        int rows = grid.length;\n        int cols = grid[0].length;\n        int islandCount = 0;\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j] == '1') {\n                    islandCount++;\n                    markIsland(grid, i, j);\n                }\n            }\n        }\n\n        return islandCount;\n    }\n\n    private void markIsland(char[][] grid, int i, int j) {\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == '0') {\n            return;\n        }\n\n        // Mark the current cell as visited\n        grid[i][j] = '0';\n\n        // Recursively mark all adjacent land cells\n        markIsland(grid, i - 1, j); // Up\n        markIsland(grid, i + 1, j); // Down\n        markIsland(grid, i, j - 1); // Left\n        markIsland(grid, i, j + 1); // Right\n    }\n}\n    ",
      "compare_result": "1111111111111111111111111111111111111111111111111",
      "title_slug": "number-of-islands",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 113,
      "statusCode": 10,
      "totalTestcases": 49,
      "question": {
        "title": "Number of Islands",
        "titleSlug": "number-of-islands",
        "questionId": "200"
      },
      "status_code": 10,
      "passedTestCaseCnt": 49,
      "totalTestCaseCnt": 49
    },
    {
      "id": 1766023012,
      "question_id": 64,
      "lang": "python",
      "lang_name": "Python",
      "time": "14minutes",
      "timestamp": 1757508485,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "11 ms",
      "url": "/submissions/detail/1766023012/",
      "is_pending": "Not Pending",
      "title": "Minimum Path Sum",
      "memory": "13.9 MB",
      "code": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not grid or not grid[0]:\n            return 0\n        \n        rows, cols = len(grid), len(grid[0])\n        \n        # Initialize the first cell\n        for i in range(rows):\n            for j in range(cols):\n                if i == 0 and j == 0:\n                    continue\n                elif i == 0:\n                    grid[i][j] += grid[i][j - 1]\n                elif j == 0:\n                    grid[i][j] += grid[i - 1][j]\n                else:\n                    grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n        \n        return grid[-1][-1]\n    \n                                                                                              \n    ",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "minimum-path-sum",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 112,
      "statusCode": 10,
      "totalTestcases": 66,
      "question": {
        "title": "Minimum Path Sum",
        "titleSlug": "minimum-path-sum",
        "questionId": "64"
      },
      "status_code": 10,
      "passedTestCaseCnt": 66,
      "totalTestCaseCnt": 66
    },
    {
      "id": 1766022539,
      "question_id": 64,
      "lang": "php",
      "lang_name": "PHP",
      "time": "14minutes",
      "timestamp": 1757508454,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "5 ms",
      "url": "/submissions/detail/1766022539/",
      "is_pending": "Not Pending",
      "title": "Minimum Path Sum",
      "memory": "22.5 MB",
      "code": "class Solution {\n\n    /**\n     * @param Integer[][] $grid\n     * @return Integer\n     */\n    function minPathSum($grid) {\n        $rows = count($grid);\n        $cols = count($grid[0]);\n\n        // Create a DP array to store the minimum path sums\n        $dp = array_fill(0, $rows, array_fill(0, $cols, 0));\n\n        // Initialize the top-left corner\n        $dp[0][0] = $grid[0][0];\n\n        // Fill the first row\n        for ($j = 1; $j < $cols; $j++) {\n            $dp[0][$j] = $dp[0][$j - 1] + $grid[0][$j];\n        }\n\n        // Fill the first column\n        for ($i = 1; $i < $rows; $i++) {\n            $dp[$i][0] = $dp[$i - 1][0] + $grid[$i][0];\n        }\n\n        // Fill the rest of the DP array\n        for ($i = 1; $i < $rows; $i++) {\n            for ($j = 1; $j < $cols; $j++) {\n                $dp[$i][$j] = min($dp[$i - 1][$j], $dp[$i][$j - 1]) + $grid[$i][$j];\n            }\n        }\n\n        // The bottom-right corner contains the minimum path sum\n        return $dp[$rows - 1][$cols - 1];  \n    }\n}\n    ",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "minimum-path-sum",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 111,
      "statusCode": 10,
      "totalTestcases": 66,
      "question": {
        "title": "Minimum Path Sum",
        "titleSlug": "minimum-path-sum",
        "questionId": "64"
      },
      "status_code": 10,
      "passedTestCaseCnt": 66,
      "totalTestCaseCnt": 66
    },
    {
      "id": 1766022163,
      "question_id": 64,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "15minutes",
      "timestamp": 1757508428,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "7 ms",
      "url": "/submissions/detail/1766022163/",
      "is_pending": "Not Pending",
      "title": "Minimum Path Sum",
      "memory": "56.8 MB",
      "code": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar minPathSum = function(grid) {\n    const m = grid.length; // Number of rows\n    const n = grid[0].length; // Number of columns\n\n    // Create a 2D array to store the minimum path sums\n    const dp = Array.from({ length: m }, () => Array(n).fill(0));\n\n    // Initialize the top-left corner\n    dp[0][0] = grid[0][0];\n\n    // Fill the first row\n    for (let j = 1; j < n; j++) {\n        dp[0][j] = dp[0][j - 1] + grid[0][j];\n    }\n\n    // Fill the first column\n    for (let i = 1; i < m; i++) {\n        dp[i][0] = dp[i - 1][0] + grid[i][0];\n    }\n\n    // Fill the rest of the dp array\n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n        }\n    }\n\n    // The bottom-right corner contains the minimum path sum\n    return dp[m - 1][n - 1];    \n};\n    ",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "minimum-path-sum",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 110,
      "statusCode": 10,
      "totalTestcases": 66,
      "question": {
        "title": "Minimum Path Sum",
        "titleSlug": "minimum-path-sum",
        "questionId": "64"
      },
      "status_code": 10,
      "passedTestCaseCnt": 66,
      "totalTestCaseCnt": 66
    },
    {
      "id": 1766021735,
      "question_id": 64,
      "lang": "java",
      "lang_name": "Java",
      "time": "15minutes",
      "timestamp": 1757508397,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "4 ms",
      "url": "/submissions/detail/1766021735/",
      "is_pending": "Not Pending",
      "title": "Minimum Path Sum",
      "memory": "47.4 MB",
      "code": "class Solution {\n    public int minPathSum(int[][] grid) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n\n        // Dynamic programming table\n        int[][] dp = new int[rows][cols];\n\n        // Initialize the starting point\n        dp[0][0] = grid[0][0];\n\n        // Fill the first row\n        for (int j = 1; j < cols; j++) {\n            dp[0][j] = dp[0][j - 1] + grid[0][j];\n        }\n\n        // Fill the first column\n        for (int i = 1; i < rows; i++) {\n            dp[i][0] = dp[i - 1][0] + grid[i][0];\n        }\n\n        // Fill the rest of the dp table\n        for (int i = 1; i < rows; i++) {\n            for (int j = 1; j < cols; j++) {\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n            }\n        }\n\n        // The bottom-right corner contains the result\n        return dp[rows - 1][cols - 1];\n    }\n}\n    ",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "minimum-path-sum",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 109,
      "statusCode": 10,
      "totalTestcases": 66,
      "question": {
        "title": "Minimum Path Sum",
        "titleSlug": "minimum-path-sum",
        "questionId": "64"
      },
      "status_code": 10,
      "passedTestCaseCnt": 66,
      "totalTestCaseCnt": 66
    },
    {
      "id": 1766021113,
      "question_id": 139,
      "lang": "python",
      "lang_name": "Python",
      "time": "16minutes",
      "timestamp": 1757508351,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "7 ms",
      "url": "/submissions/detail/1766021113/",
      "is_pending": "Not Pending",
      "title": "Word Break",
      "memory": "12.5 MB",
      "code": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        word_set = set(wordDict)\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n\n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in word_set:\n                    dp[i] = True\n                    break\n\n        return dp[len(s)]",
      "compare_result": "11111111111111111111111111111111111111111111111",
      "title_slug": "word-break",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 108,
      "statusCode": 10,
      "totalTestcases": 47,
      "question": {
        "title": "Word Break",
        "titleSlug": "word-break",
        "questionId": "139"
      },
      "status_code": 10,
      "passedTestCaseCnt": 47,
      "totalTestCaseCnt": 47
    },
    {
      "id": 1766020698,
      "question_id": 139,
      "lang": "php",
      "lang_name": "PHP",
      "time": "17minutes",
      "timestamp": 1757508322,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "3 ms",
      "url": "/submissions/detail/1766020698/",
      "is_pending": "Not Pending",
      "title": "Word Break",
      "memory": "20.4 MB",
      "code": "class Solution {\n\n    /**\n     * @param String $s\n     * @param String[] $wordDict\n     * @return Boolean\n     */\n    function wordBreak($s, $wordDict) {\n        $wordSet = array_flip($wordDict); // Convert wordDict to a set for O(1) lookups\n        $n = strlen($s);\n        $dp = array_fill(0, $n + 1, false);\n        $dp[0] = true; // Base case: empty string can always be segmented\n\n        for ($i = 1; $i <= $n; $i++) {\n            for ($j = 0; $j < $i; $j++) {\n                if ($dp[$j] && isset($wordSet[substr($s, $j, $i - $j)])) {\n                    $dp[$i] = true;\n                    break; // No need to check further if we found a valid segmentation\n                }\n            }\n        }\n\n        return $dp[$n]; // Return whether the entire string can be segmented\n    }\n}",
      "compare_result": "11111111111111111111111111111111111111111111111",
      "title_slug": "word-break",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 107,
      "statusCode": 10,
      "totalTestcases": 47,
      "question": {
        "title": "Word Break",
        "titleSlug": "word-break",
        "questionId": "139"
      },
      "status_code": 10,
      "passedTestCaseCnt": 47,
      "totalTestCaseCnt": 47
    },
    {
      "id": 1766020240,
      "question_id": 139,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "17minutes",
      "timestamp": 1757508291,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "11 ms",
      "url": "/submissions/detail/1766020240/",
      "is_pending": "Not Pending",
      "title": "Word Break",
      "memory": "55 MB",
      "code": "/**\n * @param {string} s\n * @param {string[]} wordDict\n * @return {boolean}\n */\nvar wordBreak = function(s, wordDict) {\n    const wordSet = new Set(wordDict); // Convert wordDict to a set for O(1) lookups\n    const dp = Array(s.length + 1).fill(false); // Create a DP array initialized to false\n    dp[0] = true; // Base case: empty string can always be segmented\n\n    // Iterate through the string s\n    for (let i = 1; i <= s.length; i++) {\n        // Check all possible previous positions j\n        for (let j = 0; j < i; j++) {\n            if (dp[j] && wordSet.has(s.substring(j, i))) {\n                dp[i] = true; // If we can segment up to j and the substring from j to i is in the dictionary\n                break; // No need to check further, we found a valid segmentation\n            }\n        }\n    }\n    return dp[s.length]; // Return whether the entire string can be segmented   \n};",
      "compare_result": "11111111111111111111111111111111111111111111111",
      "title_slug": "word-break",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 106,
      "statusCode": 10,
      "totalTestcases": 47,
      "question": {
        "title": "Word Break",
        "titleSlug": "word-break",
        "questionId": "139"
      },
      "status_code": 10,
      "passedTestCaseCnt": 47,
      "totalTestCaseCnt": 47
    },
    {
      "id": 1766019241,
      "question_id": 139,
      "lang": "java",
      "lang_name": "Java",
      "time": "18minutes",
      "timestamp": 1757508219,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "8 ms",
      "url": "/submissions/detail/1766019241/",
      "is_pending": "Not Pending",
      "title": "Word Break",
      "memory": "44.5 MB",
      "code": "class Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        Set<String> wordSet = new HashSet<>(wordDict);\n        boolean[] dp = new boolean[s.length() + 1];\n        dp[0] = true; // Base case: empty string can be segmented\n\n        for (int i = 1; i <= s.length(); i++) {\n            for (int j = 0; j < i; j++) {\n                if (dp[j] && wordSet.contains(s.substring(j, i))) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[s.length()];\n    }\n}",
      "compare_result": "11111111111111111111111111111111111111111111111",
      "title_slug": "word-break",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 105,
      "statusCode": 10,
      "totalTestcases": 47,
      "question": {
        "title": "Word Break",
        "titleSlug": "word-break",
        "questionId": "139"
      },
      "status_code": 10,
      "passedTestCaseCnt": 47,
      "totalTestCaseCnt": 47
    }
  ]
}