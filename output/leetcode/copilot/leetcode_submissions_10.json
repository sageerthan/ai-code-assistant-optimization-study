{
  "submissions_dump": [
    {
      "id": 1766874831,
      "question_id": 460,
      "lang": "python",
      "lang_name": "Python",
      "time": "25minutes",
      "timestamp": 1757573777,
      "status": 11,
      "status_display": "Wrong Answer",
      "runtime": "N/A",
      "url": "/submissions/detail/1766874831/",
      "is_pending": "Not Pending",
      "title": "LFU Cache",
      "memory": "N/A",
      "code": "class LFUCache(object):\n\n    def __init__(self, capacity):\n        \"\"\"\n        :type capacity: int\n        \"\"\"\n        self.capacity = capacity\n        self.cache = {}\n        self.freq = {}\n        self.min_freq = 0\n\n    def get(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: int\n        \"\"\"\n        if key not in self.cache:\n            return -1\n        \n        # Increment the frequency of the key\n        self.freq[key] += 1\n        freq = self.freq[key]\n        \n        # Update the minimum frequency if necessary\n        if freq == 1:\n            self.min_freq = 1\n        elif freq > self.min_freq and all(f < freq for f in self.freq.values()):\n            self.min_freq = freq\n        \n        return self.cache[key]\n        \n\n    def put(self, key, value):\n        \"\"\"\n        :type key: int\n        :type value: int\n        :rtype: None\n        \"\"\"\n        if self.capacity <= 0:\n            return\n        \n        if key in self.cache:\n            # Update the value and increment frequency\n            self.cache[key] = value\n            self.freq[key] += 1\n        else:\n            if len(self.cache) >= self.capacity:\n                # Evict the least frequently used key\n                lfu_key = min(self.freq, key=lambda k: (self.freq[k], k))\n                del self.cache[lfu_key]\n                del self.freq[lfu_key]\n            \n            # Insert the new key\n            self.cache[key] = value\n            self.freq[key] = 1\n            self.min_freq = 1\n        \n# Your LFUCache object will be instantiated and called as such:\n# obj = LFUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)                                                                 \n    ",
      "compare_result": "1111111111111001000000000",
      "title_slug": "lfu-cache",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 204,
      "statusCode": 11,
      "totalTestcases": 25,
      "question": {
        "title": "LFU Cache",
        "titleSlug": "lfu-cache",
        "questionId": "460"
      },
      "status_code": 11,
      "passedTestCaseCnt": 14,
      "totalTestCaseCnt": 25
    },
    {
      "id": 1766873992,
      "question_id": 460,
      "lang": "php",
      "lang_name": "PHP",
      "time": "26minutes",
      "timestamp": 1757573725,
      "status": 15,
      "status_display": "Runtime Error",
      "runtime": "N/A",
      "url": "/submissions/detail/1766873992/",
      "is_pending": "Not Pending",
      "title": "LFU Cache",
      "memory": "N/A",
      "code": "class LFUCache(object):\n\n    def __init__(self, capacity):\n        \"\"\"\n        :type capacity: int\n        \"\"\"\n        self.capacity = capacity\n        self.cache = {}\n        self.freq = {}\n        self.min_freq = 0\n\n    def get(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: int\n        \"\"\"\n        if key not in self.cache:\n            return -1\n        \n        # Increment the frequency of the key\n        self.freq[key] += 1\n        freq = self.freq[key]\n        \n        # Update the minimum frequency if necessary\n        if freq == 1:\n            self.min_freq = 1\n        elif freq > self.min_freq and all(f < freq for f in self.freq.values()):\n            self.min_freq = freq\n        \n        return self.cache[key]\n        \n\n    def put(self, key, value):\n        \"\"\"\n        :type key: int\n        :type value: int\n        :rtype: None\n        \"\"\"\n        if self.capacity <= 0:\n            return\n        \n        if key in self.cache:\n            # Update the value and increment frequency\n            self.cache[key] = value\n            self.freq[key] += 1\n        else:\n            if len(self.cache) >= self.capacity:\n                # Evict the least frequently used key\n                lfu_key = min(self.freq, key=lambda k: (self.freq[k], k))\n                del self.cache[lfu_key]\n                del self.freq[lfu_key]\n            \n            # Insert the new key\n            self.cache[key] = value\n            self.freq[key] = 1\n            self.min_freq = 1\n        \n# Your LFUCache object will be instantiated and called as such:\n# obj = LFUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)                                                                 \n    ",
      "compare_result": "0000000000000000000000000",
      "title_slug": "lfu-cache",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 203,
      "statusCode": 15,
      "totalTestcases": 25,
      "question": {
        "title": "LFU Cache",
        "titleSlug": "lfu-cache",
        "questionId": "460"
      },
      "status_code": 15,
      "passedTestCaseCnt": 0,
      "totalTestCaseCnt": 25
    },
    {
      "id": 1766873156,
      "question_id": 460,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "27minutes",
      "timestamp": 1757573671,
      "status": 11,
      "status_display": "Wrong Answer",
      "runtime": "N/A",
      "url": "/submissions/detail/1766873156/",
      "is_pending": "Not Pending",
      "title": "LFU Cache",
      "memory": "N/A",
      "code": "/**\n * @param {number} capacity\n */\nvar LFUCache = function(capacity) {\n    this.capacity = capacity; // Set the capacity of the cache\n    this.cache = new Map(); // Map to store key-value pairs\n    this.freqMap = new Map(); // Map to store frequency of each key\n    this.minFreq = 0; // Track the minimum frequency of keys\n    \n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLFUCache.prototype.get = function(key) {\n    if (!this.cache.has(key)) {\n        return -1; // If the key does not exist, return -1\n    }\n    \n    // Get the current value and frequency of the key\n    const value = this.cache.get(key);\n    const freq = this.freqMap.get(key);\n    \n    // Update the frequency map\n    this.freqMap.set(key, freq + 1);\n    \n    // Remove the key from the current frequency list\n    this.cache.delete(key);\n    \n    // Add the key to the new frequency list\n    this.cache.set(key, value);\n    \n    // Update the minimum frequency if necessary\n    if (this.minFreq === freq && !this.cache.has(freq + 1)) {\n        this.minFreq++;\n    }\n    \n    return value; // Return the value associated with the key   \n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLFUCache.prototype.put = function(key, value) {\n    if (this.capacity <= 0) return; // If capacity is 0, do nothing\n    \n    if (this.cache.has(key)) {\n        // If the key already exists, update its value and frequency\n        this.cache.set(key, value);\n        const freq = this.freqMap.get(key);\n        this.freqMap.set(key, freq + 1);\n        \n        // Update the minimum frequency if necessary\n        if (this.minFreq === freq && !this.cache.has(freq + 1)) {\n            this.minFreq++;\n        }\n    } else {\n        // If the key does not exist, check if we need to evict a key\n        if (this.cache.size >= this.capacity) {\n            // Evict the least frequently used key\n            for (const [k, v] of this.cache.entries()) {\n                if (this.freqMap.get(k) === this.minFreq) {\n                    this.cache.delete(k);\n                    this.freqMap.delete(k);\n                    break;\n                }\n            }\n        }\n        \n        // Add the new key-value pair with frequency 1\n        this.cache.set(key, value);\n        this.freqMap.set(key, 1);\n        this.minFreq = 1; // Reset minimum frequency to 1\n    }  \n};\n\n/** \n * Your LFUCache object will be instantiated and called as such:\n * var obj = new LFUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n    ",
      "compare_result": "1111111011111001011100111",
      "title_slug": "lfu-cache",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 202,
      "statusCode": 11,
      "totalTestcases": 25,
      "question": {
        "title": "LFU Cache",
        "titleSlug": "lfu-cache",
        "questionId": "460"
      },
      "status_code": 11,
      "passedTestCaseCnt": 19,
      "totalTestCaseCnt": 25
    },
    {
      "id": 1766871827,
      "question_id": 460,
      "lang": "java",
      "lang_name": "Java",
      "time": "29minutes",
      "timestamp": 1757573587,
      "status": 20,
      "status_display": "Compile Error",
      "runtime": "N/A",
      "url": "/submissions/detail/1766871827/",
      "is_pending": "Not Pending",
      "title": "LFU Cache",
      "memory": "N/A",
      "code": "class LFUCache {\n\n    public LFUCache(int capacity) {\n        // Initialize the cache with the given capacity\n        // Use a HashMap to store key-value pairs and another HashMap to store frequency counts\n        // Use a priority queue or a linked list to maintain the order of least frequently used keys\n        // Implement methods for get and put operations\n        // Initialize data structures here\n        // Example:\n        this.capacity = capacity;\n        this.minFreq = 0;\n        this.keyMap = new HashMap<>();\n        this.freqMap = new HashMap<>();\n    }\n    \n    public int get(int key) {\n        if (!keyMap.containsKey(key)) {\n            return -1;\n        }\n        // Update the frequency of the key\n        int freq = keyMap.get(key).freq;\n        keyMap.get(key).freq++;\n        freqMap.get(freq).remove(key);\n        if (freqMap.get(freq).isEmpty()) {\n            freqMap.remove(freq);\n            if (minFreq == freq) {\n                minFreq++;\n            }\n        }\n        freqMap.putIfAbsent(freq + 1, new LinkedHashSet<>());\n        freqMap.get(freq + 1).add(key);\n        return keyMap.get(key).value;\n    }\n    \n    public void put(int key, int value) {\n        if (capacity == 0) return;\n\n        if (keyMap.containsKey(key)) {\n            // Update the value and frequency\n            keyMap.get(key).value = value;\n            get(key); // This will update the frequency\n        } else {\n            if (keyMap.size() >= capacity) {\n                // Evict the least frequently used key\n                evict();\n            }\n            // Insert the new key\n            keyMap.put(key, new Node(key, value));\n            freqMap.putIfAbsent(1, new LinkedHashSet<>());\n            freqMap.get(1).add(key);\n            minFreq = 1;\n        }\n    }\n\n    private void evict() {\n        // Find the least frequently used key\n        LinkedHashSet<Integer> minFreqKeys = freqMap.get(minFreq);\n        if (minFreqKeys != null && !minFreqKeys.isEmpty()) {\n            int lfuKey = minFreqKeys.iterator().next();\n            minFreqKeys.remove(lfuKey);\n            if (minFreqKeys.isEmpty()) {\n                freqMap.remove(minFreq);\n            }\n            keyMap.remove(lfuKey);\n        }\n    }\n}\n\n/**\n * Your LFUCache object will be instantiated and called as such:\n * LFUCache obj = new LFUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n    ",
      "compare_result": null,
      "title_slug": "lfu-cache",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 201,
      "statusCode": 20,
      "totalTestcases": 0,
      "question": {
        "title": "LFU Cache",
        "titleSlug": "lfu-cache",
        "questionId": "460"
      },
      "status_code": 20,
      "passedTestCaseCnt": 0,
      "totalTestCaseCnt": 0
    },
    {
      "id": 1766870890,
      "question_id": 312,
      "lang": "python",
      "lang_name": "Python",
      "time": "30minutes",
      "timestamp": 1757573529,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "3533 ms",
      "url": "/submissions/detail/1766870890/",
      "is_pending": "Not Pending",
      "title": "Burst Balloons",
      "memory": "14.4 MB",
      "code": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        # Add 1s at both ends\n        nums = [1] + nums + [1]\n        dp = [[0] * (n + 2) for _ in range(n + 2)]\n\n        for length in range(1, n + 1):\n            for left in range(1, n - length + 2):\n                right = left + length - 1\n                for i in range(left, right + 1):\n                    dp[left][right] = max(dp[left][right], \n                                          dp[left][i - 1] + dp[i + 1][right] + nums[left - 1] * nums[i] * nums[right + 1])\n        \n        return dp[1][n]                                                                 \n    ",
      "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "burst-balloons",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 200,
      "statusCode": 10,
      "totalTestcases": 73,
      "question": {
        "title": "Burst Balloons",
        "titleSlug": "burst-balloons",
        "questionId": "312"
      },
      "status_code": 10,
      "passedTestCaseCnt": 73,
      "totalTestCaseCnt": 73
    },
    {
      "id": 1766869645,
      "question_id": 312,
      "lang": "php",
      "lang_name": "PHP",
      "time": "31minutes",
      "timestamp": 1757573448,
      "status": 15,
      "status_display": "Runtime Error",
      "runtime": "N/A",
      "url": "/submissions/detail/1766869645/",
      "is_pending": "Not Pending",
      "title": "Burst Balloons",
      "memory": "N/A",
      "code": "class Solution {\n\n    /**\n     * Calculate the maximum coins you can collect by bursting the balloons wisely.\n     * Uses dynamic programming with memoization.\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function maxCoins($nums) {\n        // Add 1 to both ends to handle boundaries\n        $n = count($nums);\n        $arr = array_merge([1], $nums, [1]);\n        $dp = [];\n\n        // Helper function for DP\n        function burst(&$arr, &$dp, $left, $right) {\n            if ($left + 1 == $right) return 0;\n            if (isset($dp[$left][$right])) return $dp[$left][$right];\n            $maxCoins = 0;\n            for ($i = $left + 1; $i < $right; $i++) {\n                $coins = $arr[$left] * $arr[$i] * $arr[$right];\n                $coins += burst($arr, $dp, $left, $i);\n                $coins += burst($arr, $dp, $i, $right);\n                if ($coins > $maxCoins) $maxCoins = $coins;\n            }\n            $dp[$left][$right] = $maxCoins;\n            return $maxCoins;\n        }\n\n        return burst($arr, $dp, 0, $n + 1);\n    }\n}",
      "compare_result": "1000000000000000000000000000000000000000000000000000000000000000000000000",
      "title_slug": "burst-balloons",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 199,
      "statusCode": 15,
      "totalTestcases": 73,
      "question": {
        "title": "Burst Balloons",
        "titleSlug": "burst-balloons",
        "questionId": "312"
      },
      "status_code": 15,
      "passedTestCaseCnt": 1,
      "totalTestCaseCnt": 73
    },
    {
      "id": 1766869192,
      "question_id": 312,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "31minutes",
      "timestamp": 1757573420,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "90 ms",
      "url": "/submissions/detail/1766869192/",
      "is_pending": "Not Pending",
      "title": "Burst Balloons",
      "memory": "56.1 MB",
      "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxCoins = function(nums) {\n    const n = nums.length;\n    const dp = Array.from({ length: n + 2 }, () => Array(n + 2).fill(0));\n    \n    // Extend the nums array with 1s at both ends\n    const extendedNums = [1, ...nums, 1];\n    \n    // Fill the dp table\n    for (let length = 1; length <= n; length++) {\n        for (let left = 1; left <= n - length + 1; left++) {\n            const right = left + length - 1;\n            for (let i = left; i <= right; i++) {\n                dp[left][right] = Math.max(dp[left][right], \n                    dp[left][i - 1] + dp[i + 1][right] + extendedNums[left - 1] * extendedNums[i] * extendedNums[right + 1]);\n            }\n        }\n    }\n    \n    return dp[1][n]; // The result is stored in dp[1][n]    \n};\n    ",
      "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "burst-balloons",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 198,
      "statusCode": 10,
      "totalTestcases": 73,
      "question": {
        "title": "Burst Balloons",
        "titleSlug": "burst-balloons",
        "questionId": "312"
      },
      "status_code": 10,
      "passedTestCaseCnt": 73,
      "totalTestCaseCnt": 73
    },
    {
      "id": 1766868810,
      "question_id": 312,
      "lang": "java",
      "lang_name": "Java",
      "time": "32minutes",
      "timestamp": 1757573398,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "40 ms",
      "url": "/submissions/detail/1766868810/",
      "is_pending": "Not Pending",
      "title": "Burst Balloons",
      "memory": "42.9 MB",
      "code": "class Solution {\n    public int maxCoins(int[] nums) {\n        int n = nums.length;\n        // Create a new array with 1s at both ends\n        int[] balloons = new int[n + 2];\n        balloons[0] = 1;\n        balloons[n + 1] = 1;\n        for (int i = 0; i < n; i++) {\n            balloons[i + 1] = nums[i];\n        }\n\n        // dp[i][j] will store the maximum coins that can be collected by bursting balloons from index i to j\n        int[][] dp = new int[n + 2][n + 2];\n\n        // Iterate over the length of the subarray\n        for (int length = 1; length <= n; length++) {\n            for (int left = 0; left <= n - length; left++) {\n                int right = left + length + 1; // right is exclusive\n                for (int k = left + 1; k < right; k++) {\n                    // Calculate coins if we burst balloon k last in the range [left, right]\n                    int coins = balloons[left] * balloons[k] * balloons[right];\n                    dp[left][right] = Math.max(dp[left][right], dp[left][k] + dp[k][right] + coins);\n                }\n            }\n        }\n\n        return dp[0][n + 1]; // The result is stored in dp[0][n+1]\n    }\n}\n    ",
      "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "burst-balloons",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 197,
      "statusCode": 10,
      "totalTestcases": 73,
      "question": {
        "title": "Burst Balloons",
        "titleSlug": "burst-balloons",
        "questionId": "312"
      },
      "status_code": 10,
      "passedTestCaseCnt": 73,
      "totalTestCaseCnt": 73
    },
    {
      "id": 1766865427,
      "question_id": 124,
      "lang": "python",
      "lang_name": "Python",
      "time": "35minutes",
      "timestamp": 1757573180,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "27 ms",
      "url": "/submissions/detail/1766865427/",
      "is_pending": "Not Pending",
      "title": "Binary Tree Maximum Path Sum",
      "memory": "25.5 MB",
      "code": "class Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int\n        \"\"\"\n        self.max_sum = float('-inf')\n\n        def max_gain(node):\n            if not node:\n                return 0\n            \n            # Recursively get the maximum path sum of the left and right subtrees\n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n\n            # Update the maximum path sum\n            self.max_sum = max(self.max_sum, node.val + left_gain + right_gain)\n\n            # Return the maximum gain from the current node\n            return node.val + max(left_gain, right_gain)\n\n        max_gain(root)\n        return self.max_sum\n",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "binary-tree-maximum-path-sum",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 196,
      "statusCode": 10,
      "totalTestcases": 96,
      "question": {
        "title": "Binary Tree Maximum Path Sum",
        "titleSlug": "binary-tree-maximum-path-sum",
        "questionId": "124"
      },
      "status_code": 10,
      "passedTestCaseCnt": 96,
      "totalTestCaseCnt": 96
    },
    {
      "id": 1766865012,
      "question_id": 124,
      "lang": "php",
      "lang_name": "PHP",
      "time": "36minutes",
      "timestamp": 1757573154,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "16 ms",
      "url": "/submissions/detail/1766865012/",
      "is_pending": "Not Pending",
      "title": "Binary Tree Maximum Path Sum",
      "memory": "25.8 MB",
      "code": "class Solution {\n\n    /**\n     * @param TreeNode $root\n     * @return Integer\n     */\n    function maxPathSum($root) {\n        $maxSum = PHP_INT_MIN;\n        $this->maxGain($root, $maxSum);\n        return $maxSum;\n    }\n\n    private function maxGain($node, &$maxSum) {\n        if ($node === null) return 0;\n\n        // Calculate the maximum path sum \"starting\" from the left and right child\n        $leftGain = max($this->maxGain($node->left, $maxSum), 0);\n        $rightGain = max($this->maxGain($node->right, $maxSum), 0);\n\n        // Update the maximum path sum\n        $maxSum = max($maxSum, $node->val + $leftGain + $rightGain);\n\n        // Return the maximum gain if we continue the same path\n        return $node->val + max($leftGain, $rightGain);\n    }\n}\n    ",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "binary-tree-maximum-path-sum",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 195,
      "statusCode": 10,
      "totalTestcases": 96,
      "question": {
        "title": "Binary Tree Maximum Path Sum",
        "titleSlug": "binary-tree-maximum-path-sum",
        "questionId": "124"
      },
      "status_code": 10,
      "passedTestCaseCnt": 96,
      "totalTestCaseCnt": 96
    },
    {
      "id": 1766864522,
      "question_id": 124,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "36minutes",
      "timestamp": 1757573124,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "3 ms",
      "url": "/submissions/detail/1766864522/",
      "is_pending": "Not Pending",
      "title": "Binary Tree Maximum Path Sum",
      "memory": "65.9 MB",
      "code": "/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxPathSum = function(root) {\n    let maxSum = -Infinity;\n\n    const findMaxPath = (node) => {\n        if (!node) return 0;\n\n        // Calculate max path sum for left and right subtrees\n        const leftMax = Math.max(findMaxPath(node.left), 0);\n        const rightMax = Math.max(findMaxPath(node.right), 0);\n\n        // Update the global maxSum\n        maxSum = Math.max(maxSum, leftMax + rightMax + node.val);\n\n        // Return the maximum path sum extending from the current node\n        return Math.max(leftMax, rightMax) + node.val;\n    };\n\n    findMaxPath(root);\n    return maxSum;\n};\n    ",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "binary-tree-maximum-path-sum",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 194,
      "statusCode": 10,
      "totalTestcases": 96,
      "question": {
        "title": "Binary Tree Maximum Path Sum",
        "titleSlug": "binary-tree-maximum-path-sum",
        "questionId": "124"
      },
      "status_code": 10,
      "passedTestCaseCnt": 96,
      "totalTestCaseCnt": 96
    },
    {
      "id": 1766864141,
      "question_id": 124,
      "lang": "java",
      "lang_name": "Java",
      "time": "37minutes",
      "timestamp": 1757573100,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "0 ms",
      "url": "/submissions/detail/1766864141/",
      "is_pending": "Not Pending",
      "title": "Binary Tree Maximum Path Sum",
      "memory": "44.3 MB",
      "code": "class Solution {\n    public int maxPathSum(TreeNode root) {\n        if (root == null) {\n            return 0; // If the tree is empty, return 0\n        }\n        \n        int[] maxSum = new int[1]; // Use an array to keep track of the maximum path sum\n        maxSum[0] = Integer.MIN_VALUE; // Initialize to the smallest possible value\n        \n        maxPathSumHelper(root, maxSum);\n        \n        return maxSum[0]; // Return the maximum path sum found\n    }\n\n    private int maxPathSumHelper(TreeNode node, int[] maxSum) {\n        if (node == null) {\n            return 0;\n        }\n\n        // Calculate the maximum path sum for the left and right subtrees\n        int leftMax = Math.max(0, maxPathSumHelper(node.left, maxSum));\n        int rightMax = Math.max(0, maxPathSumHelper(node.right, maxSum));\n\n        // Update the maximum path sum found so far\n        maxSum[0] = Math.max(maxSum[0], leftMax + rightMax + node.val);\n\n        // Return the maximum path sum including the current node\n        return Math.max(leftMax, rightMax) + node.val;\n    }\n}\n    ",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "binary-tree-maximum-path-sum",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 193,
      "statusCode": 10,
      "totalTestcases": 96,
      "question": {
        "title": "Binary Tree Maximum Path Sum",
        "titleSlug": "binary-tree-maximum-path-sum",
        "questionId": "124"
      },
      "status_code": 10,
      "passedTestCaseCnt": 96,
      "totalTestCaseCnt": 96
    },
    {
      "id": 1766863197,
      "question_id": 1414,
      "lang": "python",
      "lang_name": "Python",
      "time": "38minutes",
      "timestamp": 1757573042,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "496 ms",
      "url": "/submissions/detail/1766863197/",
      "is_pending": "Not Pending",
      "title": "Shortest Path in a Grid with Obstacles Elimination",
      "memory": "21.7 MB",
      "code": "class Solution(object):\n    def shortestPath(self, grid, k):\n        \"\"\"\n        :type grid: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        from collections import deque\n        \n        m, n = len(grid), len(grid[0])\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        queue = deque([(0, 0, k, 0)])  # (x, y, remaining_k, steps)\n        visited = set((0, 0, k))\n        while queue:\n            x, y, remaining_k, steps = queue.popleft()\n            if x == m - 1 and y == n - 1:\n                return steps\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n:\n                    if grid[nx][ny] == 1 and remaining_k > 0:\n                        if (nx, ny, remaining_k - 1) not in visited:\n                            visited.add((nx, ny, remaining_k - 1))\n                            queue.append((nx, ny, remaining_k - 1, steps + 1))\n                    elif grid[nx][ny] == 0:\n                        if (nx, ny, remaining_k) not in visited:\n                            visited.add((nx, ny, remaining_k))\n                            queue.append((nx, ny, remaining_k, steps + 1))\n        return -1\n",
      "compare_result": "1111111111111111111111111111111111111111111111111111111",
      "title_slug": "shortest-path-in-a-grid-with-obstacles-elimination",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 192,
      "statusCode": 10,
      "totalTestcases": 55,
      "question": {
        "title": "Shortest Path in a Grid with Obstacles Elimination",
        "titleSlug": "shortest-path-in-a-grid-with-obstacles-elimination",
        "questionId": "1414"
      },
      "status_code": 10,
      "passedTestCaseCnt": 55,
      "totalTestCaseCnt": 55
    },
    {
      "id": 1766861625,
      "question_id": 1414,
      "lang": "php",
      "lang_name": "PHP",
      "time": "39minutes",
      "timestamp": 1757572940,
      "status": 11,
      "status_display": "Wrong Answer",
      "runtime": "N/A",
      "url": "/submissions/detail/1766861625/",
      "is_pending": "Not Pending",
      "title": "Shortest Path in a Grid with Obstacles Elimination",
      "memory": "N/A",
      "code": "class Solution {\n\n    /**\n     * @param Integer[][] $grid\n     * @param Integer $k\n     * @return Integer\n     */\n    function shortestPath($grid, $k) {\n        $m = count($grid);\n        $n = count($grid[0]);\n        $directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n        $queue = new SplQueue();\n        $queue->enqueue([0, 0, 0, $k]); // x, y, steps, remaining_k\n        $visited = [];\n        while (!$queue->isEmpty()) {\n            [$x, $y, $steps, $remaining_k] = $queue->dequeue();\n            if ($x === $m - 1 && $y === $n - 1) return $steps;\n            foreach ($directions as [$dx, $dy]) {\n                $nx = $x + $dx;\n                $ny = $y + $dy;\n                if ($nx < 0 || $ny < 0 || $nx >= $m || $ny >= $n) continue;\n                if ($grid[$nx][$ny] === 1 && $remaining_k > 0) {\n                    $remaining_k--;\n                } elseif ($grid[$nx][$ny] === 1) {\n                    continue;\n                }\n                $state = [$nx, $ny, $remaining_k];\n                if (!isset($visited[serialize($state)])) {\n                    $visited[serialize($state)] = true;\n                    $queue->enqueue([$nx, $ny, $steps + 1, $remaining_k]);\n                }\n            }\n        }\n        return -1;\n    }\n}\n    ",
      "compare_result": "1111111111111111111111011011111111111111111111101011111",
      "title_slug": "shortest-path-in-a-grid-with-obstacles-elimination",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 191,
      "statusCode": 11,
      "totalTestcases": 55,
      "question": {
        "title": "Shortest Path in a Grid with Obstacles Elimination",
        "titleSlug": "shortest-path-in-a-grid-with-obstacles-elimination",
        "questionId": "1414"
      },
      "status_code": 11,
      "passedTestCaseCnt": 51,
      "totalTestCaseCnt": 55
    },
    {
      "id": 1766861216,
      "question_id": 1414,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "40minutes",
      "timestamp": 1757572916,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "290 ms",
      "url": "/submissions/detail/1766861216/",
      "is_pending": "Not Pending",
      "title": "Shortest Path in a Grid with Obstacles Elimination",
      "memory": "78.1 MB",
      "code": "/**\n * @param {number[][]} grid\n * @param {number} k\n * @return {number}\n */\nvar shortestPath = function(grid, k) {\n    const m = grid.length;\n    const n = grid[0].length;\n    const directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];\n    const queue = [[0, 0, k, 0]]; // [x, y, remaining_k, steps]\n    const visited = new Set();\n    visited.add(`0,0,${k}`);\n\n    while (queue.length > 0) {\n        const [x, y, remaining_k, steps] = queue.shift();\n\n        if (x === m - 1 && y === n - 1) {\n            return steps; // Reached the bottom-right corner\n        }\n\n        for (const [dx, dy] of directions) {\n            const nx = x + dx;\n            const ny = y + dy;\n\n            if (nx >= 0 && nx < m && ny >= 0 && ny < n) {\n                const new_k = remaining_k - grid[nx][ny];\n\n                if (new_k >= 0 && !visited.has(`${nx},${ny},${new_k}`)) {\n                    visited.add(`${nx},${ny},${new_k}`);\n                    queue.push([nx, ny, new_k, steps + 1]);\n                }\n            }\n        }\n    }\n\n    return -1; // No valid path found  \n};\n    ",
      "compare_result": "1111111111111111111111111111111111111111111111111111111",
      "title_slug": "shortest-path-in-a-grid-with-obstacles-elimination",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 190,
      "statusCode": 10,
      "totalTestcases": 55,
      "question": {
        "title": "Shortest Path in a Grid with Obstacles Elimination",
        "titleSlug": "shortest-path-in-a-grid-with-obstacles-elimination",
        "questionId": "1414"
      },
      "status_code": 10,
      "passedTestCaseCnt": 55,
      "totalTestCaseCnt": 55
    },
    {
      "id": 1766860738,
      "question_id": 1414,
      "lang": "java",
      "lang_name": "Java",
      "time": "40minutes",
      "timestamp": 1757572887,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "23 ms",
      "url": "/submissions/detail/1766860738/",
      "is_pending": "Not Pending",
      "title": "Shortest Path in a Grid with Obstacles Elimination",
      "memory": "45.7 MB",
      "code": "class Solution {\n    public int shortestPath(int[][] grid, int k) {\n        int m = grid.length, n = grid[0].length;\n        if (m == 0 || n == 0) return -1;\n\n        // Directions for moving in the grid\n        int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n        \n        // Queue for BFS: stores (x, y, steps, obstacles eliminated)\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{0, 0, 0, 0}); // Start from (0, 0) with 0 steps and 0 obstacles eliminated\n        \n        // Visited array to track the minimum obstacles eliminated at each cell\n        boolean[][][] visited = new boolean[m][n][k + 1];\n        visited[0][0][0] = true;\n\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int x = current[0], y = current[1], steps = current[2], obstacles = current[3];\n\n            // If we reach the bottom-right corner\n            if (x == m - 1 && y == n - 1) {\n                return steps;\n            }\n\n            // Explore all possible directions\n            for (int[] dir : directions) {\n                int newX = x + dir[0], newY = y + dir[1];\n\n                // Check bounds\n                if (newX >= 0 && newX < m && newY >= 0 && newY < n) {\n                    int newObstacles = obstacles + grid[newX][newY];\n\n                    // If we can eliminate this obstacle and haven't visited this state yet\n                    if (newObstacles <= k && !visited[newX][newY][newObstacles]) {\n                        visited[newX][newY][newObstacles] = true;\n                        queue.offer(new int[]{newX, newY, steps + 1, newObstacles});\n                    }\n                }\n            }\n        }\n        return -1; // If we cannot reach the bottom-right corner \n    }\n}\n    ",
      "compare_result": "1111111111111111111111111111111111111111111111111111111",
      "title_slug": "shortest-path-in-a-grid-with-obstacles-elimination",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 189,
      "statusCode": 10,
      "totalTestcases": 55,
      "question": {
        "title": "Shortest Path in a Grid with Obstacles Elimination",
        "titleSlug": "shortest-path-in-a-grid-with-obstacles-elimination",
        "questionId": "1414"
      },
      "status_code": 10,
      "passedTestCaseCnt": 55,
      "totalTestCaseCnt": 55
    },
    {
      "id": 1766859890,
      "question_id": 297,
      "lang": "python",
      "lang_name": "Python",
      "time": "41minutes",
      "timestamp": 1757572836,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "87 ms",
      "url": "/submissions/detail/1766859890/",
      "is_pending": "Not Pending",
      "title": "Serialize and Deserialize Binary Tree",
      "memory": "23.2 MB",
      "code": "class Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n\n        vals = []\n        def dfs(node):\n            if not node:\n                vals.append('null')\n                return\n            vals.append(str(node.val))\n            dfs(node.left)\n            dfs(node.right)\n        dfs(root)\n        return ','.join(vals)\n        \n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        vals = iter(data.split(','))\n        def dfs():\n            val = next(vals)\n            if val == 'null':\n                return None\n            node = TreeNode(int(val))\n            node.left = dfs()\n            node.right = dfs()\n            return node\n        return dfs()\n        \n\n# Your Codec object will be instantiated and called as such:\n# ser = Codec()\n# deser = Codec()\n# ans = deser.deserialize(ser.serialize(root))                                                         \n    ",
      "compare_result": "11111111111111111111111111111111111111111111111111111",
      "title_slug": "serialize-and-deserialize-binary-tree",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 188,
      "statusCode": 10,
      "totalTestcases": 53,
      "question": {
        "title": "Serialize and Deserialize Binary Tree",
        "titleSlug": "serialize-and-deserialize-binary-tree",
        "questionId": "297"
      },
      "status_code": 10,
      "passedTestCaseCnt": 53,
      "totalTestCaseCnt": 53
    },
    {
      "id": 1766859423,
      "question_id": 297,
      "lang": "php",
      "lang_name": "PHP",
      "time": "42minutes",
      "timestamp": 1757572809,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "247 ms",
      "url": "/submissions/detail/1766859423/",
      "is_pending": "Not Pending",
      "title": "Serialize and Deserialize Binary Tree",
      "memory": "24.4 MB",
      "code": "class Codec {\n    function __construct() {   \n        // No initialization needed\n    }\n  \n    /**\n     * Serializes a binary tree to a single string using level-order traversal (BFS).\n     * @param TreeNode $root\n     * @return String\n     */\n    function serialize($root) {\n        if ($root === null) return '';\n        $queue = [$root];\n        $result = [];\n        while (!empty($queue)) {\n            $node = array_shift($queue);\n            if ($node === null) {\n                $result[] = 'null';\n            } else {\n                $result[] = $node->val;\n                $queue[] = $node->left;\n                $queue[] = $node->right;\n            }\n        }\n        // Remove trailing 'null's for compactness\n        while (end($result) === 'null') {\n            array_pop($result);\n        }\n        return implode(',', $result);\n    }\n  \n    /**\n     * Deserializes your encoded data to tree.\n     * @param String $data\n     * @return TreeNode\n     */\n    function deserialize($data) {\n        if (empty($data)) return null;\n        $nodes = explode(',', $data);\n        $root = new TreeNode(intval($nodes[0]));\n        $queue = [$root];\n        $i = 1;\n        while (!empty($queue)) {\n            $current = array_shift($queue);\n            if ($i < count($nodes)) {\n                $leftVal = $nodes[$i++];\n                if ($leftVal !== 'null') {\n                    $current->left = new TreeNode(intval($leftVal));\n                    $queue[] = $current->left;\n                }\n            }\n            if ($i < count($nodes)) {\n                $rightVal = $nodes[$i++];\n                if ($rightVal !== 'null') {\n                    $current->right = new TreeNode(intval($rightVal));\n                    $queue[] = $current->right;\n                }\n            }\n        }\n        return $root;\n    }\n}\n\n/**\n * Your Codec object will be instantiated and called as such:\n * $ser = Codec();\n * $deser = Codec();\n * $data = $ser->serialize($root);\n * $ans = $deser->deserialize($data);\n*/",
      "compare_result": "11111111111111111111111111111111111111111111111111111",
      "title_slug": "serialize-and-deserialize-binary-tree",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 187,
      "statusCode": 10,
      "totalTestcases": 53,
      "question": {
        "title": "Serialize and Deserialize Binary Tree",
        "titleSlug": "serialize-and-deserialize-binary-tree",
        "questionId": "297"
      },
      "status_code": 10,
      "passedTestCaseCnt": 53,
      "totalTestCaseCnt": 53
    },
    {
      "id": 1766858994,
      "question_id": 297,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "42minutes",
      "timestamp": 1757572781,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "89 ms",
      "url": "/submissions/detail/1766858994/",
      "is_pending": "Not Pending",
      "title": "Serialize and Deserialize Binary Tree",
      "memory": "68.9 MB",
      "code": "/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function(root) {\n    if (!root) return 'null'; // Base case for null nodes\n\n    // Pre-order traversal: root, left, right\n    const leftSerialized = serialize(root.left);\n    const rightSerialized = serialize(root.right);\n\n    // Combine the current node value with serialized left and right subtrees\n    return `${root.val},${leftSerialized},${rightSerialized}`;\n    \n};\n\n/**\n * Decodes your encoded data to tree.\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n    const values = data.split(',').map(val => (val === 'null' ? null : parseInt(val)));\n    let index = 0;\n\n    const buildTree = () => {\n        if (index >= values.length || values[index] === null) {\n            index++;\n            return null;\n        }\n\n        const node = new TreeNode(values[index++]);\n        node.left = buildTree();\n        node.right = buildTree();\n        return node;\n    };\n\n    return buildTree();\n};\n\n/**\n * Your functions will be called as such:\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n   const values = data.split(',').map(val => (val === 'null' ? null : parseInt(val)));\n   let index = 0;\n\n   const buildTree = () => {\n       if (index >= values.length || values[index] === null) {\n           index++;\n           return null;\n       }\n\n       const node = new TreeNode(values[index++]);\n       node.left = buildTree();\n       node.right = buildTree();\n       return node;\n   };\n\n   return buildTree();\n};\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */\n    ",
      "compare_result": "11111111111111111111111111111111111111111111111111111",
      "title_slug": "serialize-and-deserialize-binary-tree",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 186,
      "statusCode": 10,
      "totalTestcases": 53,
      "question": {
        "title": "Serialize and Deserialize Binary Tree",
        "titleSlug": "serialize-and-deserialize-binary-tree",
        "questionId": "297"
      },
      "status_code": 10,
      "passedTestCaseCnt": 53,
      "totalTestCaseCnt": 53
    },
    {
      "id": 1766858534,
      "question_id": 297,
      "lang": "java",
      "lang_name": "Java",
      "time": "42minutes",
      "timestamp": 1757572753,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "11 ms",
      "url": "/submissions/detail/1766858534/",
      "is_pending": "Not Pending",
      "title": "Serialize and Deserialize Binary Tree",
      "memory": "46.8 MB",
      "code": "public class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        if (root == null) {\n            return \"null,\";\n        }\n        StringBuilder sb = new StringBuilder();\n        sb.append(root.val).append(\",\");\n        sb.append(serialize(root.left));\n        sb.append(serialize(root.right));\n        return sb.toString();\n        \n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        String[] values = data.split(\",\");\n        Queue<String> queue = new LinkedList<>(Arrays.asList(values));\n        return deserializeHelper(queue);\n    }\n\n    private TreeNode deserializeHelper(Queue<String> queue) {\n        String value = queue.poll();\n        if (value.equals(\"null\")) {\n            return null;\n        }\n        TreeNode root = new TreeNode(Integer.parseInt(value));\n        root.left = deserializeHelper(queue);\n        root.right = deserializeHelper(queue);\n        return root;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser = new Codec();\n// Codec deser = new Codec();\n// TreeNode ans = deser.deserialize(ser.serialize(root));\n    ",
      "compare_result": "11111111111111111111111111111111111111111111111111111",
      "title_slug": "serialize-and-deserialize-binary-tree",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 185,
      "statusCode": 10,
      "totalTestcases": 53,
      "question": {
        "title": "Serialize and Deserialize Binary Tree",
        "titleSlug": "serialize-and-deserialize-binary-tree",
        "questionId": "297"
      },
      "status_code": 10,
      "passedTestCaseCnt": 53,
      "totalTestCaseCnt": 53
    }
  ]
}