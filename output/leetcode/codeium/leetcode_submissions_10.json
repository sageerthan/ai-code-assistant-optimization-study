{
  "submissions_dump": [
    {
      "id": 1775043917,
      "question_id": 460,
      "lang": "python",
      "lang_name": "Python",
      "time": "0minutes",
      "timestamp": 1758204618,
      "status": 15,
      "status_display": "Runtime Error",
      "runtime": "N/A",
      "url": "/submissions/detail/1775043917/",
      "is_pending": "Not Pending",
      "title": "LFU Cache",
      "memory": "N/A",
      "code": "\nclass LFUCache(object):\n\n    def __init__(self, capacity):\n        \"\"\"\n        :type capacity: int\n        \"\"\"\n        self.capacity = capacity\n        self.key_node = {}\n        self.count_node = {}\n        self.min_count = 0\n        \n\n    def get(self, key):\n        \"\"\"\n        :type key: int\n        :rtype: int\n        \"\"\"\n        if key not in self.key_node:\n            return -1\n        node = self.key_node[key]\n        del self.key_node[key]\n\n        self.count_node[node.count].remove(key)\n\n        if not self.count_node[node.count]:\n            del self.count_node[node.count]\n        node.count += 1\n        self.count_node.setdefault(node.count, set()).add(key)\n        self.key_node[key] = node\n\n        if self.min_count not in self.count_node:\n            self.min_count += 1\n\n        return node.value\n        \n\n    def put(self, key, value):\n        \"\"\"\n        :type key: int\n        :type value: int\n        :rtype: None\n        \"\"\"\n        if not self.capacity:\n            return\n        if key in self.key_node:\n            node = self.key_node[key]\n            del self.key_node[key]\n            self.count_node[node.count].remove(key)\n\n            if not self.count_node[node.count]:\n                del self.count_node[node.count]\n        else:\n            if len(self.key_node) == self.capacity:\n                k, n = self.count_node[self.min_count].popitem(last=False)\n                del self.key_node[k]\n            self.min_count = 1\n        self.key_node[key] = self.Node(value, self.min_count)\n        self.count_node.setdefault(self.min_count, set()).add(key)\n        \n# Your LFUCache object will be instantiated and called as such:\n# obj = LFUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)                                                                 \n    ",
      "compare_result": "0000000000000000000000000",
      "title_slug": "lfu-cache",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 620,
      "statusCode": 15,
      "totalTestcases": 25,
      "question": {
        "title": "LFU Cache",
        "titleSlug": "lfu-cache",
        "questionId": "460"
      },
      "status_code": 15,
      "passedTestCaseCnt": 0,
      "totalTestCaseCnt": 25
    },
    {
      "id": 1775043148,
      "question_id": 460,
      "lang": "php",
      "lang_name": "PHP",
      "time": "1minute",
      "timestamp": 1758204573,
      "status": 11,
      "status_display": "Wrong Answer",
      "runtime": "N/A",
      "url": "/submissions/detail/1775043148/",
      "is_pending": "Not Pending",
      "title": "LFU Cache",
      "memory": "N/A",
      "code": "class LFUCache {\n\n    private $capacity;\n    private $keyNode = [];\n    private $countNode = [];\n    private $minCount = 0;\n\n    /**\n     * @param Integer $capacity\n     */\n    function __construct($capacity) {\n        $this->capacity = $capacity;\n    }\n  \n    /**\n     * @param Integer $key\n     * @return Integer\n     */\n    function get($key) {\n        if (!isset($this->keyNode[$key])) {\n            return -1;\n        }\n        $count = $this->countNode[$key] + 1;\n        $this->countNode[$key] = $count;\n        if ($count === $this->minCount) {\n            $this->minCount = $count + 1;\n        }\n        return $this->keyNode[$key];\n    }\n  \n    /**\n     * @param Integer $key\n     * @param Integer $value\n     * @return NULL\n     */\n    function put($key, $value) {\n        if ($this->capacity <= 0) {\n            return;\n        }\n        if (isset($this->keyNode[$key])) {\n            $this->get($key);\n            $this->keyNode[$key] = $value;\n            return;\n        }\n        if (count($this->keyNode) >= $this->capacity) {\n            ksort($this->countNode);\n            $minCount = min($this->countNode);\n            foreach ($this->countNode as $k => $v) {\n                if ($v === $minCount) {\n                    unset($this->keyNode[$k], $this->countNode[$k]);\n                    break;\n                }\n            }\n        }\n        $this->keyNode[$key] = $value;\n        $this->countNode[$key] = 1;\n        $this->minCount = 1;\n    }\n}\n\n/**\n * Your LFUCache object will be instantiated and called as such:\n * $obj = LFUCache($capacity);\n * $ret_1 = $obj->get($key);\n * $obj->put($key, $value);\n */\n    ",
      "compare_result": "1111111111111001000000000",
      "title_slug": "lfu-cache",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 619,
      "statusCode": 11,
      "totalTestcases": 25,
      "question": {
        "title": "LFU Cache",
        "titleSlug": "lfu-cache",
        "questionId": "460"
      },
      "status_code": 11,
      "passedTestCaseCnt": 14,
      "totalTestCaseCnt": 25
    },
    {
      "id": 1775042224,
      "question_id": 460,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "2minutes",
      "timestamp": 1758204518,
      "status": 15,
      "status_display": "Runtime Error",
      "runtime": "N/A",
      "url": "/submissions/detail/1775042224/",
      "is_pending": "Not Pending",
      "title": "LFU Cache",
      "memory": "N/A",
      "code": "class Node {\n    constructor(key, value) {\n        this.key = key;\n        this.value = value;\n        this.count = 1;\n        this.prev = null;\n        this.next = null;\n    }\n}\n\nclass DoublyLinkedList {\n    constructor() {\n        this.head = new Node(0, 0);\n        this.tail = new Node(0, 0);\n        this.head.next = this.tail;\n        this.tail.prev = this.head;\n        this.size = 0;\n    }\n\n    add(node) {\n        node.prev = this.tail.prev;\n        node.next = this.tail;\n        this.tail.prev.next = node;\n        this.tail.prev = node;\n        this.size++;\n    }\n\n    remove(node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n        this.size--;\n    }\n}\n\n/**\n * @param {number} capacity\n */\nvar LFUCache = function(capacity) {\n    this.capacity = capacity;\n    this.keyNode = {};\n    this.countNode = {};\n    this.minCount = 0;\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLFUCache.prototype.get = function(key) {\n    if (this.keyNode.hasOwnProperty(key)) {\n        const node = this.keyNode[key];\n        const count = node.count;\n        this.countNode[count].remove(node);\n        if (this.countNode[count].size === 0) {\n            delete this.countNode[count];\n            if (count === this.minCount) {\n                this.minCount++;\n            }\n        }\n        node.count++;\n        this.countNode[node.count] = this.countNode[node.count] || new DoublyLinkedList();\n        this.countNode[node.count].add(node);\n        return node.value;\n    }\n    return -1;\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLFUCache.prototype.put = function(key, value) {\n    if (this.capacity <= 0) return;\n    if (this.keyNode.hasOwnProperty(key)) {\n        this.keyNode[key].value = value;\n        this.get(key);\n        return;\n    }\n    if (Object.keys(this.keyNode).length >= this.capacity) {\n        const k = this.countNode[this.minCount].head.next.key;\n        this.countNode[this.minCount].remove(this.keyNode[k]);\n        delete this.keyNode[k];\n        if (this.countNode[this.minCount].size === 0) {\n            delete this.countNode[this.minCount];\n            if (this.minCount === Object.keys(this.countNode)[0]) {\n                this.minCount++;\n            }\n        }\n    }\n    this.keyNode[key] = new Node(key, value);\n    this.countNode[1] = this.countNode[1] || new DoublyLinkedList();\n    this.countNode[1].add(this.keyNode[key]);\n    this.minCount = 1;\n};\n\n/** \n * Your LFUCache object will be instantiated and called as such:\n * var obj = new LFUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n    ",
      "compare_result": "0000000000000000000000000",
      "title_slug": "lfu-cache",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 618,
      "statusCode": 15,
      "totalTestcases": 25,
      "question": {
        "title": "LFU Cache",
        "titleSlug": "lfu-cache",
        "questionId": "460"
      },
      "status_code": 15,
      "passedTestCaseCnt": 0,
      "totalTestCaseCnt": 25
    },
    {
      "id": 1775041053,
      "question_id": 460,
      "lang": "java",
      "lang_name": "Java",
      "time": "3minutes",
      "timestamp": 1758204450,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "74 ms",
      "url": "/submissions/detail/1775041053/",
      "is_pending": "Not Pending",
      "title": "LFU Cache",
      "memory": "138.6 MB",
      "code": "class LFUCache {\n    private int capacity;\n    private Map<Integer, Integer> keyToValue = new HashMap<>();\n    private Map<Integer, Integer> keyToCount = new HashMap<>();\n    private Map<Integer, LinkedHashSet<Integer>> countToLRUKeys = new HashMap<>();\n    private int minCount = 0;\n\n    public LFUCache(int capacity) {\n        this.capacity = capacity;\n    }\n    \n    public int get(int key) {\n        if (!keyToValue.containsKey(key)) {\n            return -1;\n        }\n        int count = keyToCount.get(key);\n        keyToCount.put(key, count + 1);\n        countToLRUKeys.get(count).remove(key);\n\n        if (countToLRUKeys.get(count).size() == 0) {\n            countToLRUKeys.remove(count);\n            if (count == minCount) {\n                minCount++;\n            }\n        }\n\n        countToLRUKeys.computeIfAbsent(count + 1, z -> new LinkedHashSet<>()).add(key);\n        return keyToValue.get(key);\n    }\n    \n    public void put(int key, int value) {\n        if (capacity <= 0) {\n            return;\n        }\n        if (keyToValue.containsKey(key)) {\n            keyToValue.put(key, value);\n            get(key);\n            return;\n        }\n        if (keyToValue.size() >= capacity) {\n            int evict = countToLRUKeys.get(minCount).iterator().next();\n            keyToValue.remove(evict);\n            keyToCount.remove(evict);\n            countToLRUKeys.get(minCount).remove(evict);\n            if (countToLRUKeys.get(minCount).size() == 0) {\n                countToLRUKeys.remove(minCount);\n            }\n        }\n        keyToValue.put(key, value);\n        keyToCount.put(key, 1);\n        minCount = 1;\n        countToLRUKeys.computeIfAbsent(1, z -> new LinkedHashSet<>()).add(key);\n    }\n}\n\n/**\n * Your LFUCache object will be instantiated and called as such:\n * LFUCache obj = new LFUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n    ",
      "compare_result": "1111111111111111111111111",
      "title_slug": "lfu-cache",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 617,
      "statusCode": 10,
      "totalTestcases": 25,
      "question": {
        "title": "LFU Cache",
        "titleSlug": "lfu-cache",
        "questionId": "460"
      },
      "status_code": 10,
      "passedTestCaseCnt": 25,
      "totalTestCaseCnt": 25
    },
    {
      "id": 1775039718,
      "question_id": 312,
      "lang": "python",
      "lang_name": "Python",
      "time": "4minutes",
      "timestamp": 1758204368,
      "status": 15,
      "status_display": "Runtime Error",
      "runtime": "N/A",
      "url": "/submissions/detail/1775039718/",
      "is_pending": "Not Pending",
      "title": "Burst Balloons",
      "memory": "N/A",
      "code": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for length in range(1, n + 1):\n            for left in range(n - length + 1):\n                right = left + length - 1\n                for i in range(left, right + 1):\n                    dp[left][right] = max(dp[left][right], dp[left][i - 1] + dp[i + 1][right] + nums[left - 1] * nums[i] * nums[right + 1])\n        return dp[0][n - 1]\n    ",
      "compare_result": "0000000000000000000000000000000000000000000000000000000000000000000000000",
      "title_slug": "burst-balloons",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 616,
      "statusCode": 15,
      "totalTestcases": 73,
      "question": {
        "title": "Burst Balloons",
        "titleSlug": "burst-balloons",
        "questionId": "312"
      },
      "status_code": 15,
      "passedTestCaseCnt": 0,
      "totalTestCaseCnt": 73
    },
    {
      "id": 1775039039,
      "question_id": 312,
      "lang": "php",
      "lang_name": "PHP",
      "time": "5minutes",
      "timestamp": 1758204326,
      "status": 11,
      "status_display": "Wrong Answer",
      "runtime": "N/A",
      "url": "/submissions/detail/1775039039/",
      "is_pending": "Not Pending",
      "title": "Burst Balloons",
      "memory": "N/A",
      "code": "class Solution {\n\n    /**\n     * @param Integer[] $nums\n     * @return Integer\n     */\n    function maxCoins($nums) {\n        $n = count($nums);\n        $dp = array_fill(0, $n + 2, array_fill(0, $n + 2, 0));\n        for ($length = 1; $length <= $n; $length++) {\n            for ($left = 1; $left <= $n - $length + 1; $left++) {\n                $right = $left + $length - 1;\n                for ($i = $left; $i <= $right; $i++) {\n                    $dp[$left][$right] = max($dp[$left][$right], $dp[$left][$i - 1] + $dp[$i + 1][$right] + $nums[$left - 1] * $nums[$i] * $nums[$right + 1]);\n                }\n            }\n        }\n        return $dp[1][$n];\n    }\n}\n    ",
      "compare_result": "0000000000000000000000000000000000000000000000000000000000000000000000000",
      "title_slug": "burst-balloons",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 615,
      "statusCode": 11,
      "totalTestcases": 73,
      "question": {
        "title": "Burst Balloons",
        "titleSlug": "burst-balloons",
        "questionId": "312"
      },
      "status_code": 11,
      "passedTestCaseCnt": 0,
      "totalTestCaseCnt": 73
    },
    {
      "id": 1775038145,
      "question_id": 312,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "6minutes",
      "timestamp": 1758204270,
      "status": 15,
      "status_display": "Runtime Error",
      "runtime": "N/A",
      "url": "/submissions/detail/1775038145/",
      "is_pending": "Not Pending",
      "title": "Burst Balloons",
      "memory": "N/A",
      "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxCoins = function(nums) {\n    let n = nums.length;\n    let dp = Array(n+2).fill(0).map(() => Array(n+2).fill(0));\n    for (let length = 1; length <= n; length++) {\n        for (let left = 1; left <= n - length + 1; left++) {\n            let right = left + length - 1;\n            for (let i = left; i <= right; i++) {\n                dp[left][right] = Math.max(dp[left][right], dp[left][i-1] + dp[i+1][right] + nums[left-1] * nums[i] * nums[right+1]);\n            }\n        }\n    }\n    return dp[1][n];\n};\n    ",
      "compare_result": "0000000000000000000000000000000000000000000000000000000000000000000000000",
      "title_slug": "burst-balloons",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 614,
      "statusCode": 15,
      "totalTestcases": 73,
      "question": {
        "title": "Burst Balloons",
        "titleSlug": "burst-balloons",
        "questionId": "312"
      },
      "status_code": 15,
      "passedTestCaseCnt": 0,
      "totalTestCaseCnt": 73
    },
    {
      "id": 1775037752,
      "question_id": 312,
      "lang": "java",
      "lang_name": "Java",
      "time": "6minutes",
      "timestamp": 1758204247,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "38 ms",
      "url": "/submissions/detail/1775037752/",
      "is_pending": "Not Pending",
      "title": "Burst Balloons",
      "memory": "42.6 MB",
      "code": "class Solution {\n    public int maxCoins(int[] nums) {\n        int n = nums.length;\n        int[] arr = new int[n + 2];\n        for (int i = 1; i <= n; i++) {\n            arr[i] = nums[i - 1];\n        }\n        arr[0] = arr[n + 1] = 1;\n        int[][] dp = new int[n + 2][n + 2];\n        for (int length = 1; length <= n; length++) {\n            for (int left = 1; left <= n - length + 1; left++) {\n                int right = left + length - 1;\n                for (int i = left; i <= right; i++) {\n                    dp[left][right] = Math.max(dp[left][right], dp[left][i - 1] + dp[i + 1][right] + arr[left - 1] * arr[i] * arr[right + 1]);\n                }\n            }\n        }\n        return dp[1][n];\n    }\n}\n    ",
      "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "burst-balloons",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 613,
      "statusCode": 10,
      "totalTestcases": 73,
      "question": {
        "title": "Burst Balloons",
        "titleSlug": "burst-balloons",
        "questionId": "312"
      },
      "status_code": 10,
      "passedTestCaseCnt": 73,
      "totalTestCaseCnt": 73
    },
    {
      "id": 1775037045,
      "question_id": 124,
      "lang": "python",
      "lang_name": "Python",
      "time": "7minutes",
      "timestamp": 1758204207,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "27 ms",
      "url": "/submissions/detail/1775037045/",
      "is_pending": "Not Pending",
      "title": "Binary Tree Maximum Path Sum",
      "memory": "25.4 MB",
      "code": "class Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int\n        \"\"\"\n        self.max_sum = float('-inf')\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            price_newpath = node.val + left_gain + right_gain\n            self.max_sum = max(self.max_sum, price_newpath)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        max_gain(root)\n        return self.max_sum\n    ",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "binary-tree-maximum-path-sum",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 612,
      "statusCode": 10,
      "totalTestcases": 96,
      "question": {
        "title": "Binary Tree Maximum Path Sum",
        "titleSlug": "binary-tree-maximum-path-sum",
        "questionId": "124"
      },
      "status_code": 10,
      "passedTestCaseCnt": 96,
      "totalTestCaseCnt": 96
    },
    {
      "id": 1775036676,
      "question_id": 124,
      "lang": "php",
      "lang_name": "PHP",
      "time": "7minutes",
      "timestamp": 1758204184,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "5 ms",
      "url": "/submissions/detail/1775036676/",
      "is_pending": "Not Pending",
      "title": "Binary Tree Maximum Path Sum",
      "memory": "25.8 MB",
      "code": "class Solution {\n\n    private $maxSum = -1000;\n    \n    /**\n     * @param TreeNode $root\n     * @return Integer\n     */\n    function maxPathSum($root) {\n        $this->maxSum = -1000;\n        $this->maxGain($root);\n        return $this->maxSum;\n    }\n    \n    private function maxGain($node) {\n        if (!$node) {\n            return 0;\n        }\n        $leftGain = max($this->maxGain($node->left), 0);\n        $rightGain = max($this->maxGain($node->right), 0);\n        \n        $priceNewpath = $node->val + $leftGain + $rightGain;\n        \n        $this->maxSum = max($this->maxSum, $priceNewpath);\n        \n        return $node->val + max($leftGain, $rightGain);\n    }\n}\n    ",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "binary-tree-maximum-path-sum",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 611,
      "statusCode": 10,
      "totalTestcases": 96,
      "question": {
        "title": "Binary Tree Maximum Path Sum",
        "titleSlug": "binary-tree-maximum-path-sum",
        "questionId": "124"
      },
      "status_code": 10,
      "passedTestCaseCnt": 96,
      "totalTestCaseCnt": 96
    },
    {
      "id": 1775036263,
      "question_id": 124,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "8minutes",
      "timestamp": 1758204159,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "2 ms",
      "url": "/submissions/detail/1775036263/",
      "is_pending": "Not Pending",
      "title": "Binary Tree Maximum Path Sum",
      "memory": "63.3 MB",
      "code": "/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxPathSum = function(root) {\n    let maxSum = -Infinity;\n    const maxGain = (node) => {\n        if (!node) return 0;\n        const leftGain = Math.max(maxGain(node.left), 0);\n        const rightGain = Math.max(maxGain(node.right), 0);\n        maxSum = Math.max(maxSum, node.val + leftGain + rightGain);\n        return node.val + Math.max(leftGain, rightGain);\n    };\n    maxGain(root);\n    return maxSum;\n};\n    ",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "binary-tree-maximum-path-sum",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 610,
      "statusCode": 10,
      "totalTestcases": 96,
      "question": {
        "title": "Binary Tree Maximum Path Sum",
        "titleSlug": "binary-tree-maximum-path-sum",
        "questionId": "124"
      },
      "status_code": 10,
      "passedTestCaseCnt": 96,
      "totalTestCaseCnt": 96
    },
    {
      "id": 1775035702,
      "question_id": 124,
      "lang": "java",
      "lang_name": "Java",
      "time": "8minutes",
      "timestamp": 1758204130,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "0 ms",
      "url": "/submissions/detail/1775035702/",
      "is_pending": "Not Pending",
      "title": "Binary Tree Maximum Path Sum",
      "memory": "44.8 MB",
      "code": "class Solution {\n    private int maxSum = Integer.MIN_VALUE;\n    \n    public int maxPathSum(TreeNode root) {\n        maxGain(root);\n        return maxSum;\n    }\n    \n    private int maxGain(TreeNode node) {\n        if (node == null) {\n            return 0;\n        }\n        int leftGain = Math.max(maxGain(node.left), 0);\n        int rightGain = Math.max(maxGain(node.right), 0);\n        \n        int priceNewpath = node.val + leftGain + rightGain;\n        maxSum = Math.max(maxSum, priceNewpath);\n        \n        return node.val + Math.max(leftGain, rightGain);\n    }\n}\n    ",
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
      "title_slug": "binary-tree-maximum-path-sum",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 609,
      "statusCode": 10,
      "totalTestcases": 96,
      "question": {
        "title": "Binary Tree Maximum Path Sum",
        "titleSlug": "binary-tree-maximum-path-sum",
        "questionId": "124"
      },
      "status_code": 10,
      "passedTestCaseCnt": 96,
      "totalTestCaseCnt": 96
    },
    {
      "id": 1775033526,
      "question_id": 1414,
      "lang": "python",
      "lang_name": "Python",
      "time": "11minutes",
      "timestamp": 1758203997,
      "status": 15,
      "status_display": "Runtime Error",
      "runtime": "N/A",
      "url": "/submissions/detail/1775033526/",
      "is_pending": "Not Pending",
      "title": "Shortest Path in a Grid with Obstacles Elimination",
      "memory": "N/A",
      "code": "class Solution(object):\n    def shortestPath(self, grid, k):\n        \"\"\"\n        :type grid: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        m, n = len(grid), len(grid[0])\n        dp = [[[float('inf')] * (k + 1) for _ in range(n)] for _ in range(m)]\n        dp[0][0][0] = 0\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        for i in range(m):\n            for j in range(n):\n                for r in range(min(k + 1, i + j + 1)):\n                    for dx, dy in directions:\n                        nx, ny = i + dx, j + dy\n                        if 0 <= nx < m and 0 <= ny < n:\n                            if grid[nx][ny] == 1:\n                                dp[nx][ny][r + 1] = min(dp[nx][ny][r + 1], dp[i][j][r] + 1)\n                            else:\n                                dp[nx][ny][r] = min(dp[nx][ny][r], dp[i][j][r] + 1)\n        return dp[m - 1][n - 1][k] if dp[m - 1][n - 1][k] != float('inf') else -1\n    ",
      "compare_result": "0000000000000000000000000000000000000000000000000000000",
      "title_slug": "shortest-path-in-a-grid-with-obstacles-elimination",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 608,
      "statusCode": 15,
      "totalTestcases": 55,
      "question": {
        "title": "Shortest Path in a Grid with Obstacles Elimination",
        "titleSlug": "shortest-path-in-a-grid-with-obstacles-elimination",
        "questionId": "1414"
      },
      "status_code": 15,
      "passedTestCaseCnt": 0,
      "totalTestCaseCnt": 55
    },
    {
      "id": 1775032782,
      "question_id": 1414,
      "lang": "php",
      "lang_name": "PHP",
      "time": "11minutes",
      "timestamp": 1758203955,
      "status": 15,
      "status_display": "Runtime Error",
      "runtime": "N/A",
      "url": "/submissions/detail/1775032782/",
      "is_pending": "Not Pending",
      "title": "Shortest Path in a Grid with Obstacles Elimination",
      "memory": "N/A",
      "code": "class Solution {\n\n    /**\n     * @param Integer[][] $grid\n     * @param Integer $k\n     * @return Integer\n     */\n    function shortestPath($grid, $k) {\n        list($m, $n) = [count($grid), count($grid[0])];\n        $dp = array_fill(0, $m, array_fill(0, $n, array_fill(0, $k + 1, INF)));\n        $dp[0][0][0] = 0;\n        $queue = [[0, 0, 0]];\n        while ($queue) {\n            list($x, $y, $z) = array_shift($queue);\n            if ($x === $m - 1 && $y === $n - 1) return $dp[$x][$y][$z];\n            for (list($nx, $ny) as [['x', 1], ['y', 0], ['x', -1], ['y', -1]]) {\n                $i = $x + $nx;\n                $j = $y + $ny;\n                if ($i >= 0 && $i < $m && $j >= 0 && $j < $n && $dp[$i][$j][$z + $grid[$i][$j]] > $dp[$x][$y][$z] + 1) {\n                    $dp[$i][$j][$z + $grid[$i][$j]] = $dp[$x][$y][$z] + 1;\n                    $queue[] = [$i, $j, $z + $grid[$i][$j]];\n                }\n            }\n        }\n        return -1;\n    }\n}\n    ",
      "compare_result": "0000000000000000000000000000000000000000000000000000000",
      "title_slug": "shortest-path-in-a-grid-with-obstacles-elimination",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 607,
      "statusCode": 15,
      "totalTestcases": 55,
      "question": {
        "title": "Shortest Path in a Grid with Obstacles Elimination",
        "titleSlug": "shortest-path-in-a-grid-with-obstacles-elimination",
        "questionId": "1414"
      },
      "status_code": 15,
      "passedTestCaseCnt": 0,
      "totalTestCaseCnt": 55
    },
    {
      "id": 1775032118,
      "question_id": 1414,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "12minutes",
      "timestamp": 1758203914,
      "status": 11,
      "status_display": "Wrong Answer",
      "runtime": "N/A",
      "url": "/submissions/detail/1775032118/",
      "is_pending": "Not Pending",
      "title": "Shortest Path in a Grid with Obstacles Elimination",
      "memory": "N/A",
      "code": "const directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];\n/**\n * @param {number[][]} grid\n * @param {number} k\n * @return {number}\n */\nvar shortestPath = function(grid, k) {\n    const m = grid.length, n = grid[0].length;\n    const seen = Array.from({length: m}, () => Array(n).fill(-1));\n    const queue = [[0, 0, k]];\n    seen[0][0] = k;\n    let step = 0;\n    while (queue.length) {\n        const len = queue.length;\n        for (let i = 0; i < len; i++) {\n            const [x, y, rest] = queue.shift();\n            if (x === m - 1 && y === n - 1) return step;\n            for (const [dx, dy] of directions) {\n                const nx = x + dx, ny = y + dy;\n                if (nx >= 0 && nx < m && ny >= 0 && ny < n && rest + grid[nx][ny] >= 0 && seen[nx][ny] < rest + grid[nx][ny]) {\n                    seen[nx][ny] = rest + grid[nx][ny];\n                    queue.push([nx, ny, rest + grid[nx][ny]]);\n                }\n            }\n        }\n        step++;\n    }\n    return -1;\n};\n    ",
      "compare_result": "1011111111111111111110101011111111011111111111111011100",
      "title_slug": "shortest-path-in-a-grid-with-obstacles-elimination",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 606,
      "statusCode": 11,
      "totalTestcases": 55,
      "question": {
        "title": "Shortest Path in a Grid with Obstacles Elimination",
        "titleSlug": "shortest-path-in-a-grid-with-obstacles-elimination",
        "questionId": "1414"
      },
      "status_code": 11,
      "passedTestCaseCnt": 47,
      "totalTestCaseCnt": 55
    },
    {
      "id": 1775030902,
      "question_id": 1414,
      "lang": "java",
      "lang_name": "Java",
      "time": "13minutes",
      "timestamp": 1758203842,
      "status": 11,
      "status_display": "Wrong Answer",
      "runtime": "N/A",
      "url": "/submissions/detail/1775030902/",
      "is_pending": "Not Pending",
      "title": "Shortest Path in a Grid with Obstacles Elimination",
      "memory": "N/A",
      "code": "\nclass Solution {\n    public int shortestPath(int[][] grid, int k) {\n        int m = grid.length, n = grid[0].length;\n        int[][][] dp = new int[m][n][k + 1];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                Arrays.fill(dp[i][j], -1);\n            }\n        }\n        dp[0][0][0] = 0;\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[] {0, 0, 0});\n        int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n        while (!queue.isEmpty()) {\n            int x = queue.peek()[0], y = queue.peek()[1], z = queue.peek()[2];\n            queue.poll();\n            for (int[] dir : dirs) {\n                int nx = x + dir[0], ny = y + dir[1];\n                if (nx >= 0 && nx < m && ny >= 0 && ny < n && (grid[nx][ny] == 0 || z > 0)) {\n                    int nz = grid[nx][ny] == 1 ? z - 1 : z;\n                    if (dp[nx][ny][nz] == -1) {\n                        dp[nx][ny][nz] = dp[x][y][z] + 1;\n                        queue.offer(new int[] {nx, ny, nz});\n                    }\n                }\n            }\n        }\n        for (int i = k; i >= 0; i--) {\n            if (dp[m - 1][n - 1][i] != -1) return dp[m - 1][n - 1][i];\n        }\n        return -1;\n    }\n}\n    ",
      "compare_result": "0111011001001000111001000000000000100000000000000001000",
      "title_slug": "shortest-path-in-a-grid-with-obstacles-elimination",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 605,
      "statusCode": 11,
      "totalTestcases": 55,
      "question": {
        "title": "Shortest Path in a Grid with Obstacles Elimination",
        "titleSlug": "shortest-path-in-a-grid-with-obstacles-elimination",
        "questionId": "1414"
      },
      "status_code": 11,
      "passedTestCaseCnt": 13,
      "totalTestCaseCnt": 55
    },
    {
      "id": 1775030035,
      "question_id": 297,
      "lang": "python",
      "lang_name": "Python",
      "time": "14minutes",
      "timestamp": 1758203791,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "91 ms",
      "url": "/submissions/detail/1775030035/",
      "is_pending": "Not Pending",
      "title": "Serialize and Deserialize Binary Tree",
      "memory": "22.7 MB",
      "code": "\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        def dfs(node):\n            if node:\n                vals.append(str(node.val))\n                dfs(node.left)\n                dfs(node.right)\n            else:\n                vals.append('#')\n        vals = []\n        dfs(root)\n        return ' '.join(vals)\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        def dfs():\n            val = next(vals)\n            if val == '#':\n                return None\n            node = TreeNode(int(val))\n            node.left = dfs()\n            node.right = dfs()\n            return node\n        vals = iter(data.split())\n        return dfs()\n        \n\n# Your Codec object will be instantiated and called as such:\n# ser = Codec()\n# deser = Codec()\n# ans = deser.deserialize(ser.serialize(root))                                                         \n    ",
      "compare_result": "11111111111111111111111111111111111111111111111111111",
      "title_slug": "serialize-and-deserialize-binary-tree",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 604,
      "statusCode": 10,
      "totalTestcases": 53,
      "question": {
        "title": "Serialize and Deserialize Binary Tree",
        "titleSlug": "serialize-and-deserialize-binary-tree",
        "questionId": "297"
      },
      "status_code": 10,
      "passedTestCaseCnt": 53,
      "totalTestCaseCnt": 53
    },
    {
      "id": 1775029572,
      "question_id": 297,
      "lang": "php",
      "lang_name": "PHP",
      "time": "14minutes",
      "timestamp": 1758203762,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "439 ms",
      "url": "/submissions/detail/1775029572/",
      "is_pending": "Not Pending",
      "title": "Serialize and Deserialize Binary Tree",
      "memory": "24.8 MB",
      "code": "class Codec {\n    private $null = 'X';\n    private $delimiter = ',';\n    \n    function __construct() {\n        \n    }\n  \n    /**\n     * @param TreeNode $root\n     * @return String\n     */\n    function serialize($root) {\n        if (!$root) {\n            return $this->null;\n        }\n        $serialized = $root->val;\n        $serialized .= $this->delimiter . $this->serialize($root->left);\n        $serialized .= $this->delimiter . $this->serialize($root->right);\n        return $serialized;\n    }\n  \n    /**\n     * @param String $data\n     * @return TreeNode\n     */\n    function deserialize($data) {\n        $data = explode($this->delimiter, $data);\n        return $this->deserializeHelper($data);\n    }\n    \n    private function deserializeHelper(&$data) {\n        $val = array_shift($data);\n        if ($val == $this->null) {\n            return null;\n        }\n        $node = new TreeNode($val);\n        $node->left = $this->deserializeHelper($data);\n        $node->right = $this->deserializeHelper($data);\n        return $node;\n    }\n}\n\n/**\n * Your Codec object will be instantiated and called as such:\n * $ser = Codec();\n * $deser = Codec();\n * $data = $ser->serialize($root);\n * $ans = $deser->deserialize($data);\n */\n    ",
      "compare_result": "11111111111111111111111111111111111111111111111111111",
      "title_slug": "serialize-and-deserialize-binary-tree",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 603,
      "statusCode": 10,
      "totalTestcases": 53,
      "question": {
        "title": "Serialize and Deserialize Binary Tree",
        "titleSlug": "serialize-and-deserialize-binary-tree",
        "questionId": "297"
      },
      "status_code": 10,
      "passedTestCaseCnt": 53,
      "totalTestCaseCnt": 53
    },
    {
      "id": 1775027873,
      "question_id": 297,
      "lang": "javascript",
      "lang_name": "JavaScript",
      "time": "16minutes",
      "timestamp": 1758203663,
      "status": 15,
      "status_display": "Runtime Error",
      "runtime": "N/A",
      "url": "/submissions/detail/1775027873/",
      "is_pending": "Not Pending",
      "title": "Serialize and Deserialize Binary Tree",
      "memory": "N/A",
      "code": "/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function(root) {\n    if (!root) return 'X';\n    return root.val + ',' + serialize(root.left) + ',' + serialize(root.right);\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n    let nodes = data.split(',');\n    function helper() {\n        let node = nodes.shift();\n        if (node === 'X') return null;\n        let curr = new TreeNode(node);\n        curr.left = helper();\n        curr.right = helper();\n        return curr;\n    }\n    return helper();\n};\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */\n    ",
      "compare_result": "00000000000000000000000000000000000000000000000000000",
      "title_slug": "serialize-and-deserialize-binary-tree",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 602,
      "statusCode": 15,
      "totalTestcases": 53,
      "question": {
        "title": "Serialize and Deserialize Binary Tree",
        "titleSlug": "serialize-and-deserialize-binary-tree",
        "questionId": "297"
      },
      "status_code": 15,
      "passedTestCaseCnt": 0,
      "totalTestCaseCnt": 53
    },
    {
      "id": 1775027353,
      "question_id": 297,
      "lang": "java",
      "lang_name": "Java",
      "time": "17minutes",
      "timestamp": 1758203634,
      "status": 10,
      "status_display": "Accepted",
      "runtime": "9 ms",
      "url": "/submissions/detail/1775027353/",
      "is_pending": "Not Pending",
      "title": "Serialize and Deserialize Binary Tree",
      "memory": "46.3 MB",
      "code": "public class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        StringBuilder sb = new StringBuilder();\n        serializeHelper(root, sb);\n        return sb.toString();\n    }\n    \n    private void serializeHelper(TreeNode root, StringBuilder sb) {\n        if (root == null) {\n            sb.append(\"X,\");\n            return;\n        }\n        sb.append(root.val).append(',');\n        serializeHelper(root.left, sb);\n        serializeHelper(root.right, sb);\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        Queue<String> queue = new LinkedList<>(Arrays.asList(data.split(\",\")));\n        return deserializeHelper(queue);\n    }\n    \n    private TreeNode deserializeHelper(Queue<String> queue) {\n        String val = queue.poll();\n        if (val.equals(\"X\")) return null;\n        TreeNode root = new TreeNode(Integer.parseInt(val));\n        root.left = deserializeHelper(queue);\n        root.right = deserializeHelper(queue);\n        return root;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser = new Codec();\n// Codec deser = new Codec();\n// TreeNode ans = deser.deserialize(ser.serialize(root));\n    ",
      "compare_result": "11111111111111111111111111111111111111111111111111111",
      "title_slug": "serialize-and-deserialize-binary-tree",
      "has_notes": false,
      "flag_type": 1,
      "frontend_id": 601,
      "statusCode": 10,
      "totalTestcases": 53,
      "question": {
        "title": "Serialize and Deserialize Binary Tree",
        "titleSlug": "serialize-and-deserialize-binary-tree",
        "questionId": "297"
      },
      "status_code": 10,
      "passedTestCaseCnt": 53,
      "totalTestCaseCnt": 53
    }
  ]
}